
* Sun 01 Sep 2013 03:33:01 AM JST
SEC
* Sun 01 Sep 2013 03:33:25 AM JST
gmtime
* Sun 01 Sep 2013 03:45:34 AM JST
import types
import time
from time import sleep

* Sun 01 Sep 2013 03:45:50 AM JST
print 'imported', ['os', 'sys', 're', 'pprint', 'dis', 'subprocess', 'types', 'time']
* Sun 01 Sep 2013 03:51:19 AM JST
messages.
* Sun 01 Sep 2013 03:51:19 AM JST
of messages.
* Sun 01 Sep 2013 03:51:20 AM JST
lot of messages.
* Sun 01 Sep 2013 03:51:53 AM JST
import 
* Sun 01 Sep 2013 03:54:24 AM JST
 / A_DAY_SEC
* Sun 01 Sep 2013 04:25:05 AM JST
if :
* Sun 01 Sep 2013 04:27:18 AM JST
A_DAY_SEC 
* Sun 01 Sep 2013 04:29:54 AM JST
args
* Sun 01 Sep 2013 04:48:34 AM JST
ps = 
* Sun 01 Sep 2013 04:51:21 AM JST
psutil.get_process_list()
* Sun 01 Sep 2013 04:57:32 AM JST
names
* Sun 01 Sep 2013 04:57:38 AM JST

* Sun 01 Sep 2013 04:57:38 AM JST

* Sun 01 Sep 2013 04:57:38 AM JST
        self._names = names

* Sun 01 Sep 2013 04:57:52 AM JST
    for p in psutil.get_process_list():
        if name == p.name:
            return True
    return False

* Sun 01 Sep 2013 04:59:48 AM JST
chrome
* Sun 01 Sep 2013 04:59:54 AM JST
emacs
* Sun 01 Sep 2013 05:24:40 AM JST
[[::
* Sun 01 Sep 2013 05:25:15 AM JST
\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b
* Sun 01 Sep 2013 05:40:07 AM JST
21
* Sun 01 Sep 2013 05:40:08 AM JST
11.21
* Sun 01 Sep 2013 05:40:08 AM JST
1.11.21
* Sun 01 Sep 2013 05:40:08 AM JST
1.1.11.21
* Sun 01 Sep 2013 05:40:08 AM JST
168.1.1.11.21
* Sun 01 Sep 2013 05:40:08 AM JST
192.168.1.1.11.21
* Sun 01 Sep 2013 05:40:09 AM JST
match('192.168.1.1.11.21
* Sun 01 Sep 2013 06:09:58 AM JST
/local/lib/python2.7/dist-packages/psutil
* Sun 01 Sep 2013 06:22:01 AM JST
con
* Sun 01 Sep 2013 06:23:20 AM JST
append
* Sun 01 Sep 2013 06:23:20 AM JST
i
* Sun 01 Sep 2013 06:23:21 AM JST
ip.i
* Sun 01 Sep 2013 06:24:18 AM JST
is
* Sun 01 Sep 2013 06:24:57 AM JST
]
* Sun 01 Sep 2013 06:25:46 AM JST
__all__ = ['T_null_string', 'T_null_tuple', 'T_null_dic', 'T_text',
           'T_tuple', 'T_dic', 'pdir', 'T_n_string', 'T_nullstring',
           'T_nstring', 'T_n_tuple', 'T_nulltuple', 'T_ntuple',
           'T_n_dic', 'T_nulldic', 'T_ndic', 'T_tex', 'T_txt',
           'T_tup', 'T_tu', 'T_notepad_path', 'T_npath']

* Sun 01 Sep 2013 06:30:23 AM JST
@property
def _all():
    """SUMMARY
    
    @Return:
    """
    return __all__

* Sun 01 Sep 2013 06:42:14 AM JST
connections_samba()
* Sun 01 Sep 2013 06:45:00 AM JST

* Sun 01 Sep 2013 06:45:00 AM JST

* Sun 01 Sep 2013 06:45:00 AM JST
    else:

* Sun 01 Sep 2013 06:54:28 AM JST
'hello'
* Sun 01 Sep 2013 06:54:43 AM JST
'world'
* Sun 01 Sep 2013 06:57:04 AM JST

* Sun 01 Sep 2013 06:57:04 AM JST

* Sun 01 Sep 2013 06:57:04 AM JST
    str =  hello

* Sun 01 Sep 2013 06:57:13 AM JST

* Sun 01 Sep 2013 06:57:13 AM JST

* Sun 01 Sep 2013 06:57:13 AM JST
    str2 = world

* Sun 01 Sep 2013 07:06:47 AM JST
class _textdata(object):
    """
    """
    

* Sun 01 Sep 2013 07:07:09 AM JST
'Python is a programming language that lets you work more quickly and integrate your systems more effectively.'
* Sun 01 Sep 2013 07:10:03 AM JST
In the old age black was not counted fair,
Or if it were, it bore not beauty's name;
But now is black beauty's successive heir,
And beauty slandered with a **** shame:
For since each hand hath put on Nature's power,
Fairing the foul with Art's false borrowed face,
Sweet beauty hath no name, no holy bower,
But is profaned, if not lives in disgrace.
Therefore my mistress' eyes are raven black,
Her eyes so suited, and they mourners seem
At such who, not born fair, no beauty lack,
Sland'ring creation with a false esteem:
Yet so they mourn becoming of their woe,
That every tongue says beauty should look so.
* Sun 01 Sep 2013 07:10:40 AM JST
l = 
* Sun 01 Sep 2013 07:12:09 AM JST
When, in disgrace with fortune and men's eyes,
I all alone beweep my outcast state,
And trouble deaf heaven with my bootless cries,
And look upon myself, and curse my fate,
Wishing me like to one more rich in hope,
Featured like him, like him with friends possessed,
Desiring this man's art and that man's scope,
With what I most enjoy contented least;
Yet in these thoughts myself almost despising,
Haply I think on thee—and then my state,
Like to the lark at break of day arising
From sullen earth, sings hymns at heaven's gate;
   For thy sweet love rememb'red such wealth brings
   That then I scorn to change my state with kings.

* Sun 01 Sep 2013 07:16:10 AM JST

* Sun 01 Sep 2013 07:16:10 AM JST

* Sun 01 Sep 2013 07:16:10 AM JST
"""

* Sun 01 Sep 2013 07:16:12 AM JST
longlong = """
* Sun 01 Sep 2013 07:18:12 AM JST

* Sun 01 Sep 2013 07:18:12 AM JST

* Sun 01 Sep 2013 07:18:12 AM JST
    t = text

* Sun 01 Sep 2013 07:18:12 AM JST
    t = text

* Sun 01 Sep 2013 07:18:12 AM JST
    t = text
    txt = text

* Sun 01 Sep 2013 07:18:24 AM JST
['hello', 'world', 'hoge', 'foo', 'bar', 'yahoo', 'google', 'bing']
* Sun 01 Sep 2013 07:19:09 AM JST
list_int
* Sun 01 Sep 2013 07:20:56 AM JST
['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
* Sun 01 Sep 2013 07:21:58 AM JST
T_dic = {'hello':'hello',
         'world':'world',
         'hoge':'hoge',
         'foo':'foo',
         'bar':'bar',
         'yahoo':'yahoo',
         'google':'google',
         'bing':'bing'}

* Sun 01 Sep 2013 07:22:07 AM JST
T_dic
* Sun 01 Sep 2013 07:24:02 AM JST
r'C:\Windows\system32\notepad.exe'
* Sun 01 Sep 2013 07:25:34 AM JST
    def __init__(self, ):
        """
        """
        
* Sun 01 Sep 2013 07:33:12 AM JST
text = txt = tx = t = line
* Sun 01 Sep 2013 07:33:32 AM JST
text = txt = tx = t = line
* Sun 01 Sep 2013 07:34:44 AM JST
str
* Sun 01 Sep 2013 07:37:29 AM JST
dir(d.t)
* Sun 01 Sep 2013 07:38:28 AM JST
dir(self)
* Sun 01 Sep 2013 07:43:40 AM JST
    def __repr__(self):
        """SUMMARY

        @Return:
        """
        msg = '{0:*^30}'.format('Text Data\n')
        lis = []
        for el in dir(self):
            if not el.startswith('_') or not el.endswith('_'):
                lis.append(el)
        return msg + str(lis)

* Sun 01 Sep 2013 07:43:54 AM JST
Text
* Sun 01 Sep 2013 07:44:08 AM JST
    def __repr__(self):
        """SUMMARY

        @Return:
        """
        msg = '{0:*^30}'.format('String Data\n')
        lis = []
        for el in dir(self):
            if not el.startswith('_') or not el.endswith('_'):
                lis.append(el)
        return msg + str(lis)

* Sun 01 Sep 2013 07:45:50 AM JST
String
* Sun 01 Sep 2013 07:45:55 AM JST
my
* Sun 01 Sep 2013 07:48:10 AM JST
 + '\n'
* Sun 01 Sep 2013 07:49:18 AM JST
pprint(
* Sun 01 Sep 2013 07:50:46 AM JST
pprint(lis)
* Sun 01 Sep 2013 07:51:02 AM JST
msg
* Sun 01 Sep 2013 07:54:18 AM JST

* Sun 01 Sep 2013 07:54:18 AM JST

* Sun 01 Sep 2013 07:54:18 AM JST
        print(msg)

* Sun 01 Sep 2013 07:54:18 AM JST
        print(msg)

* Sun 01 Sep 2013 07:54:18 AM JST
        print(msg)
        pprint(lis)

* Sun 01 Sep 2013 07:54:54 AM JST
.replace("',", '\n')
* Sun 01 Sep 2013 07:56:04 AM JST
pprint(
* Sun 01 Sep 2013 07:56:11 AM JST
pprint(
* Sun 01 Sep 2013 07:56:20 AM JST
pprint(
* Sun 01 Sep 2013 07:56:27 AM JST
pprint(
* Sun 01 Sep 2013 07:56:33 AM JST
pprint(
* Sun 01 Sep 2013 08:40:14 AM JST
# define log file name
log_base_dir = '/var/log'
log_name = 'backup_ni.log'
log_path = os.path.join(log_base_dir, log_name)
logging.basicConfig(filename=log_path,
                    level=logging.DEBUG,
                    format='%(asctime)s %(message)s')

* Sun 01 Sep 2013 08:41:14 AM JST
root
* Sun 01 Sep 2013 08:41:24 AM JST
backup_ni
* Sun 01 Sep 2013 08:51:29 AM JST
running times.
* Sun 01 Sep 2013 09:00:14 AM JST
    if args.debug:
* Sun 01 Sep 2013 09:00:45 AM JST
                
* Sun 01 Sep 2013 09:01:33 AM JST

* Sun 01 Sep 2013 09:01:33 AM JST

* Sun 01 Sep 2013 09:01:33 AM JST
        arg

* Sun 01 Sep 2013 09:08:07 AM JST
None
* Sun 01 Sep 2013 09:09:51 AM JST

* Sun 01 Sep 2013 09:09:51 AM JST

* Sun 01 Sep 2013 09:09:52 AM JST
                    choices=None,

* Sun 01 Sep 2013 09:13:36 AM JST

* Sun 01 Sep 2013 09:13:36 AM JST

* Sun 01 Sep 2013 09:13:36 AM JST
                        choices=None,

* Sun 01 Sep 2013 09:14:47 AM JST

* Sun 01 Sep 2013 09:14:48 AM JST

* Sun 01 Sep 2013 09:14:48 AM JST
    if not 0 == args.time:

* Sun 01 Sep 2013 09:23:41 AM JST
int
* Sun 01 Sep 2013 09:24:00 AM JST
int
* Sun 01 Sep 2013 09:25:39 AM JST

* Sun 01 Sep 2013 09:25:39 AM JST

* Sun 01 Sep 2013 09:25:40 AM JST
                        nargs=1,

* Sun 01 Sep 2013 09:39:58 AM JST
psutil.get_users()
* Sun 01 Sep 2013 10:38:50 AM JST
## check process name exists
#
def psexists(name):
    """Check process name exists

    @Arguments:
    - `name`:

    @Return:
    """
    for pid in psutil.get_process_list():
        if name == pid.name:
            return pid
    return None

* Sun 01 Sep 2013 10:45:56 AM JST
/media/Data/MYTEMP/CPRIMER2/
* Sun 01 Sep 2013 10:47:28 AM JST

* Sun 01 Sep 2013 10:47:28 AM JST

* Sun 01 Sep 2013 10:47:29 AM JST
import psutil

* Sun 01 Sep 2013 10:53:08 AM JST
/usr/local/lib/python2.7/dist-packages
* Sun 01 Sep 2013 02:19:25 PM JST
/root/work/sikuli/sleipnir_rss.skl
* Sun 01 Sep 2013 02:20:19 PM JST

* Sun 01 Sep 2013 02:20:19 PM JST

* Sun 01 Sep 2013 02:20:19 PM JST
    print(os.path.exists('/root/work/sikuli/sleipnir_rss.skl'))

* Sun 01 Sep 2013 02:20:22 PM JST
getstatus
* Sun 01 Sep 2013 02:20:22 PM JST
commands.getstatus
* Sun 01 Sep 2013 02:20:28 PM JST
        
* Sun 01 Sep 2013 02:20:33 PM JST
stat = 
* Sun 01 Sep 2013 02:20:34 PM JST
    
* Sun 01 Sep 2013 02:20:37 PM JST

* Sun 01 Sep 2013 02:20:37 PM JST

* Sun 01 Sep 2013 02:20:37 PM JST
    print(stat)

* Sun 01 Sep 2013 02:21:33 PM JST

* Sun 01 Sep 2013 02:21:33 PM JST

* Sun 01 Sep 2013 02:21:33 PM JST
    print('DEBUG-1-daily.py')

* Sun 01 Sep 2013 02:21:34 PM JST

* Sun 01 Sep 2013 02:21:34 PM JST

* Sun 01 Sep 2013 02:21:34 PM JST
    # os.system('/usr/local/bin/s')

* Sun 01 Sep 2013 02:21:35 PM JST

* Sun 01 Sep 2013 02:21:35 PM JST

* Sun 01 Sep 2013 02:21:35 PM JST
print('DEBUG-2-daily.py')

* Sun 01 Sep 2013 02:21:39 PM JST

* Sun 01 Sep 2013 02:21:39 PM JST

* Sun 01 Sep 2013 02:21:39 PM JST
sys.exit()

* Sun 01 Sep 2013 02:21:53 PM JST

* Sun 01 Sep 2013 02:21:53 PM JST

* Sun 01 Sep 2013 02:21:53 PM JST
import commands

* Sun 01 Sep 2013 02:21:54 PM JST

* Sun 01 Sep 2013 02:21:54 PM JST

* Sun 01 Sep 2013 02:21:54 PM JST
import sys

* Sun 01 Sep 2013 03:10:12 PM JST
'"' + '" "'.join(tenkis[::-1]) + '"'
* Sun 01 Sep 2013 03:10:26 PM JST
'"' + '" "'.join(urls) + '"'
* Sun 01 Sep 2013 03:10:41 PM JST
join(
* Sun 01 Sep 2013 03:10:41 PM JST
openchrome('"' + '" "'.join(
* Sun 01 Sep 2013 03:44:04 PM JST

* Sun 01 Sep 2013 03:44:04 PM JST

* Sun 01 Sep 2013 03:44:04 PM JST
g.clear()

* Sun 01 Sep 2013 03:44:37 PM JST
COLLECTION
* Sun 01 Sep 2013 03:46:35 PM JST
0 == 
* Sun 01 Sep 2013 03:47:50 PM JST
0
* Sun 01 Sep 2013 03:50:24 PM JST
enumerate(SEQUENCE, start=0)
* Sun 01 Sep 2013 03:52:25 PM JST
from googlechrome import ChromeBMParse
* Sun 01 Sep 2013 03:52:47 PM JST
g = ChromeBMParse()
* Sun 01 Sep 2013 03:53:07 PM JST
foreign_news = g.get_urls('Foreign News')[::-1]
* Sun 01 Sep 2013 08:57:41 PM JST

* Sun 01 Sep 2013 08:57:41 PM JST

* Sun 01 Sep 2013 08:57:41 PM JST
    # os.system('/usr/local/bin/s')

* Sun 01 Sep 2013 08:57:41 PM JST
    # os.system('/usr/local/bin/s')

* Sun 01 Sep 2013 08:57:41 PM JST
    # os.system('/usr/local/bin/s')
    print('DEBUG-1-daily.py')

* Sun 01 Sep 2013 08:57:42 PM JST

* Sun 01 Sep 2013 08:57:42 PM JST

* Sun 01 Sep 2013 08:57:43 PM JST
print('DEBUG-2-daily.py')

* Sun 01 Sep 2013 08:57:43 PM JST
print('DEBUG-2-daily.py')

* Sun 01 Sep 2013 08:57:43 PM JST
print('DEBUG-2-daily.py')
sys.exit()

* Mon 02 Sep 2013 07:10:58 AM JST
# define log file name
log_name = 'backup_ni.log'
log_base_dir = '/var/log'
log_path = os.path.join(log_base_dir, log_name)
logging.basicConfig(filename=log_path,
                    level=logging.DEBUG,
                    format='%(asctime)s %(message)s')

* Mon 02 Sep 2013 07:11:42 AM JST
    # define log file name
    if args.debug:
        log_base_dir = '/root'
        log_name = 'autohalt.log'
        log_path = os.path.join(log_base_dir, log_name)
        logging.basicConfig(filename=log_path,
                            level=logging.DEBUG,
                            format='%(asctime)s %(message)s')
        logging.log(10, '{0:*^30}'.format(' start '))


* Mon 02 Sep 2013 07:11:55 AM JST

* Mon 02 Sep 2013 07:11:55 AM JST

* Mon 02 Sep 2013 07:11:55 AM JST
if args.debug:

* Mon 02 Sep 2013 07:15:30 AM JST

* Mon 02 Sep 2013 07:15:30 AM JST

* Mon 02 Sep 2013 07:15:30 AM JST
        # logging.log(10, '*** EXECUTED SHUTDOWN')

* Mon 02 Sep 2013 07:15:36 AM JST

* Mon 02 Sep 2013 07:15:36 AM JST

* Mon 02 Sep 2013 07:15:36 AM JST
    # if args.debug:

* Mon 02 Sep 2013 07:22:10 AM JST
class PsChecker(object):
    """
    """

    def __init__(self):
        """

        Arguments:
        - `names`:
        """
        self._ps = psutil.get_process_list()

    def name_exists(self, name):
        """SUMMARY

        @Arguments:

        - `name`:

        @Return:
        """
        for p in self._ps:
            if name == p.name:
                return True
        return False

* Mon 02 Sep 2013 07:22:15 AM JST

* Mon 02 Sep 2013 07:22:15 AM JST

* Mon 02 Sep 2013 07:22:15 AM JST


* Mon 02 Sep 2013 07:23:05 AM JST
def get_running_time():
    """SUMMARY

    @Return:
    """
    return time.time() - psutil.get_boot_time()

def isless_running_time(sec):
    """SUMMARY

    @Arguments:
    - `sec`: epoc time

    @Return:
    """
    return get_running_time() < sec


* Mon 02 Sep 2013 07:24:28 AM JST

* Mon 02 Sep 2013 07:24:28 AM JST

* Mon 02 Sep 2013 07:24:28 AM JST
import time

* Mon 02 Sep 2013 07:25:14 AM JST
get_running_time,
* Mon 02 Sep 2013 07:26:53 AM JST
class PsChecker(object):
    """
    """

    def __init__(self):
        """

        Arguments:
        - `names`:
        """
        self._ps = psutil.get_process_list()

    def name_exists(self, name):
        """SUMMARY

        @Arguments:

        - `name`:

        @Return:
        """
        for p in self._ps:
            if name == p.name:
                return True
        return False


* Mon 02 Sep 2013 07:30:59 AM JST
def get_connects_samba():
    """SUMMARY

    @Return:
    """
    smb_ps = []
    for ps in psutil.get_process_list():
        if ps.name == 'smbd':
            smb_ps.append(ps)
    ip = []
    for ps in smb_ps:
        for con in ps.get_connections():
           if con.raddr:
               ip.append(con.raddr)
    return list(set(ip))


* Mon 02 Sep 2013 07:35:53 AM JST
    parser = argparse.ArgumentParser(description="""
    Auto shutdown for king server.""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,
                        help='Version Strings.')
    parser.add_argument('-d', '--debug',
                        dest='debug',
                        action='store_true',
                        default=False,
                        required=False,
                        # (yas/expand-link "argparse_other_options" t)
                        help='Debug mode.')

    parser.add_argument('--disable-runtimecheck',
                        dest='disable_runtimecheck',
                        action='store_true',
                        default=False,
                        required=False,
                        # (yas/expand-link "argparse_other_options" t)
                        help='A lot of messages.')

    parser.add_argument('-t', '--time',
                        dest='time',
                        action='store',
                        const=None,
                        default=180,
                        type=str,
                        required=False,
                        # (yas/expand-link "argparse_other_options" t)
                        help='A lot of messages.')
                        # (yas/expand-link "argparse_add_argument" t)
    args = parser.parse_args()

* Mon 02 Sep 2013 07:36:27 AM JST

* Mon 02 Sep 2013 07:36:27 AM JST

* Mon 02 Sep 2013 07:36:27 AM JST
    args = parser.parse_args()

* Mon 02 Sep 2013 07:36:47 AM JST
_options_maker()
* Mon 02 Sep 2013 07:36:53 AM JST

* Mon 02 Sep 2013 07:36:53 AM JST

* Mon 02 Sep 2013 07:36:53 AM JST
    args = 

* Mon 02 Sep 2013 07:42:24 AM JST
_options_maker()
* Mon 02 Sep 2013 07:42:51 AM JST
args
* Mon 02 Sep 2013 07:43:10 AM JST
args
* Mon 02 Sep 2013 07:43:58 AM JST
(insert "opt_parse = _options_maker()\n"
               (make-string (current-indentation) 32))
* Mon 02 Sep 2013 07:46:17 AM JST
(make-string (current-indentation) 32)
* Mon 02 Sep 2013 07:48:55 AM JST

* Mon 02 Sep 2013 07:48:55 AM JST

* Mon 02 Sep 2013 07:48:56 AM JST
    args = _options_maker()

* Mon 02 Sep 2013 07:49:34 AM JST

* Mon 02 Sep 2013 07:49:34 AM JST

* Mon 02 Sep 2013 07:49:34 AM JST
    opt_parse = _options_maker()

* Mon 02 Sep 2013 07:49:35 AM JST
    opt_parse = _options_maker()

* Mon 02 Sep 2013 07:49:35 AM JST
    opt_parse = _options_maker()
    opts = opt_parse.parse_args()

* Mon 02 Sep 2013 07:51:00 AM JST
parser = argparse.ArgumentParser(description="""hello""")
* Mon 02 Sep 2013 07:52:09 AM JST
(make-string (current-indentation) 32)
* Mon 02 Sep 2013 07:53:32 AM JST
def _options_maker():
    parser = argparse.ArgumentParser(description="""hello""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,
                        help='Version Strings.')
    # (yas/expand-link "argparse_add_argument" t)
    return parser

* Mon 02 Sep 2013 07:53:39 AM JST
parser = argparse.ArgumentParser(description="""${1: }""")
* Mon 02 Sep 2013 07:53:54 AM JST

* Mon 02 Sep 2013 07:53:54 AM JST

* Mon 02 Sep 2013 07:53:54 AM JST
    parser = argparse.ArgumentParser(description="""${1: }""")

* Mon 02 Sep 2013 07:53:54 AM JST
    parser = argparse.ArgumentParser(description="""${1: }""")

* Mon 02 Sep 2013 07:53:54 AM JST
    parser = argparse.ArgumentParser(description="""${1: }""")
    parser.add_argument('--version',

* Mon 02 Sep 2013 07:53:54 AM JST
    parser = argparse.ArgumentParser(description="""${1: }""")
    parser.add_argument('--version',

* Mon 02 Sep 2013 07:53:54 AM JST
    parser = argparse.ArgumentParser(description="""${1: }""")
    parser.add_argument('--version',
                        dest='version',

* Mon 02 Sep 2013 07:53:54 AM JST
    parser = argparse.ArgumentParser(description="""${1: }""")
    parser.add_argument('--version',
                        dest='version',

* Mon 02 Sep 2013 07:53:54 AM JST
    parser = argparse.ArgumentParser(description="""${1: }""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',

* Mon 02 Sep 2013 07:53:54 AM JST
    parser = argparse.ArgumentParser(description="""${1: }""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',

* Mon 02 Sep 2013 07:53:54 AM JST
    parser = argparse.ArgumentParser(description="""${1: }""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,

* Mon 02 Sep 2013 07:53:54 AM JST
    parser = argparse.ArgumentParser(description="""${1: }""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,

* Mon 02 Sep 2013 07:53:54 AM JST
    parser = argparse.ArgumentParser(description="""${1: }""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,
                        help='Version Strings.')

* Mon 02 Sep 2013 07:53:55 AM JST
    parser = argparse.ArgumentParser(description="""${1: }""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,
                        help='Version Strings.')

* Mon 02 Sep 2013 07:53:55 AM JST
    parser = argparse.ArgumentParser(description="""${1: }""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,
                        help='Version Strings.')
    # (yas/expand-link "argparse_add_argument" t)

* Mon 02 Sep 2013 07:54:04 AM JST
    opt_parse = _options_maker()
    opts = opt_parse.parse_args()

* Mon 02 Sep 2013 07:54:09 AM JST
args = parser.parse_args()
* Mon 02 Sep 2013 07:55:42 AM JST
maker
* Mon 02 Sep 2013 07:55:42 AM JST
options_maker
* Mon 02 Sep 2013 07:55:55 AM JST
maker
* Mon 02 Sep 2013 07:55:56 AM JST
options_maker
* Mon 02 Sep 2013 07:56:59 AM JST
arg_
* Mon 02 Sep 2013 07:58:34 AM JST
opt_
* Mon 02 Sep 2013 07:58:44 AM JST
maker
* Mon 02 Sep 2013 07:58:44 AM JST
options_maker
* Mon 02 Sep 2013 07:59:18 AM JST
opt_
* Mon 02 Sep 2013 08:02:24 AM JST

* Mon 02 Sep 2013 08:02:24 AM JST

* Mon 02 Sep 2013 08:02:24 AM JST
import 

* Mon 02 Sep 2013 12:56:59 PM JST
HookKeyboard
* Mon 02 Sep 2013 12:59:08 PM JST
hm.Unhook
* Mon 02 Sep 2013 12:59:56 PM JST

* Mon 02 Sep 2013 12:59:57 PM JST

* Mon 02 Sep 2013 01:00:02 PM JST
, and the Shape extension.
Homepage: http://python-xli
* Mon 02 Sep 2013 01:08:53 PM JST
    hm = HookManager()
    hm.HookKeyboard()
    hm.HookMouse()
    hm.KeyDown = hm.printevent
    hm.KeyUp = hm.printevent
    hm.MouseAllButtonsDown = hm.printevent
    hm.MouseAllButtonsUp = hm.printevent
    hm.start()
    time.sleep(10)
    hm.cancel()

* Mon 02 Sep 2013 01:09:17 PM JST

hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello

* Mon 02 Sep 2013 01:10:45 PM JST
left
* Mon 02 Sep 2013 01:12:16 PM JST
mouse middle
* Mon 02 Sep 2013 01:12:34 PM JST
100
* Mon 02 Sep 2013 01:14:46 PM JST
mouse right
* Mon 02 Sep 2013 01:16:01 PM JST
return 
* Mon 02 Sep 2013 01:17:06 PM JST
    
* Mon 02 Sep 2013 01:17:07 PM JST
MessageName
* Mon 02 Sep 2013 01:17:31 PM JST
WindowN
* Mon 02 Sep 2013 01:29:17 PM JST

* Mon 02 Sep 2013 01:29:17 PM JST

* Mon 02 Sep 2013 01:29:17 PM JST
        return False

* Mon 02 Sep 2013 01:38:33 PM JST
(event.Ascii not in (ord('a'), ord('A')))
* Mon 02 Sep 2013 01:38:42 PM JST

* Mon 02 Sep 2013 01:38:42 PM JST

* Mon 02 Sep 2013 01:38:42 PM JST
    return 

* Mon 02 Sep 2013 02:00:10 PM JST
print('')
* Mon 02 Sep 2013 02:28:17 PM JST

* Mon 02 Sep 2013 02:28:17 PM JST

* Mon 02 Sep 2013 02:28:17 PM JST
    print(event.Key)

* Mon 02 Sep 2013 02:45:45 PM JST

* Mon 02 Sep 2013 02:46:24 PM JST
(add-to-list)
* Mon 02 Sep 2013 02:50:32 PM JST
    def OnKeyUpEvent(self,event):
        self.ControlKeyHash.update(event)
        return True

* Mon 02 Sep 2013 02:50:49 PM JST
    if event.Key.lower() in ['tab', 'a', 'b', 'c']:
        return False
    else:
        return True

* Mon 02 Sep 2013 02:51:56 PM JST
self,
* Mon 02 Sep 2013 04:03:45 PM JST
ui.close()
* Mon 02 Sep 2013 04:16:34 PM JST
ui.write(evdev.encodes.EV_KEY, evdev.encodes.KEY_H, 1)
* Mon 02 Sep 2013 04:24:47 PM JST
a
* Mon 02 Sep 2013 05:09:41 PM JST
pb = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB,False,8,sz[0],sz[1])
* Mon 02 Sep 2013 05:09:50 PM JST
pb = pb.get_from_drawable(w,w.get_colormap(),0,0,0,0,sz[0],sz[1])
* Mon 02 Sep 2013 05:10:01 PM JST
if (pb != None):
* Mon 02 Sep 2013 05:10:10 PM JST
pb.save("screenshot.png","png")
* Mon 02 Sep 2013 05:21:07 PM JST
import gtk.gdk
Xlib:  extension "RANDR" missing on display ":0.0".

In [5]: w = gtk.gdk.get_default_root_window()

In [6]: sz = w.get_size()

In [7]: pb = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB,False,8,sz[0],sz[1])

In [8]: pb = pb.get_from_drawable(w,w.get_colormap(),0,0,0,0,sz[0],sz[1])

In [9]: if (pb != None):
   ...:     pb.save("screenshot.png","png")
* Mon 02 Sep 2013 05:21:10 PM JST

* Mon 02 Sep 2013 05:21:10 PM JST

* Mon 02 Sep 2013 05:21:10 PM JST
Xlib:  extension "RANDR" missing on display ":0.0".

* Mon 02 Sep 2013 05:21:12 PM JST
In [5]: 
* Mon 02 Sep 2013 05:21:14 PM JST
In [6]: 
* Mon 02 Sep 2013 05:21:17 PM JST
In [7]: 
* Mon 02 Sep 2013 05:21:19 PM JST
In [8]: 
* Mon 02 Sep 2013 05:21:21 PM JST
In [9]: 
* Mon 02 Sep 2013 05:21:23 PM JST
...:
* Mon 02 Sep 2013 05:21:24 PM JST
   ...:
* Mon 02 Sep 2013 05:22:30 PM JST
png
* Mon 02 Sep 2013 05:22:40 PM JST
def screanshot(path):
    """SUMMARY

    @Arguments:
    - `path`:

    @Return:
    """
    w = gtk.gdk.get_default_root_window()
    sz = w.get_size()
    pb = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB,False,8,sz[0],sz[1])
    pb = pb.get_from_drawable(w,w.get_colormap(),0,0,0,0,sz[0],sz[1])
    if (pb != None):
        pb.save(path,"jpg")

* Mon 02 Sep 2013 05:23:31 PM JST
def screanshot(path):
    """SUMMARY

    @Arguments:
    - `path`:

    @Return:
    """
    w = gtk.gdk.get_default_root_window()
    sz = w.get_size()
    pb = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB,False,8,sz[0],sz[1])
    pb = pb.get_from_drawable(w,w.get_colormap(),0,0,0,0,sz[0],sz[1])
    if (pb != None):
        pb.save(path,"jpg")

* Mon 02 Sep 2013 05:23:31 PM JST
def screanshot(path):
    """SUMMARY

    @Arguments:
    - `path`:

    @Return:
    """
    w = gtk.gdk.get_default_root_window()
    sz = w.get_size()
    pb = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB,False,8,sz[0],sz[1])
    pb = pb.get_from_drawable(w,w.get_colormap(),0,0,0,0,sz[0],sz[1])
    if (pb != None):
        pb.save(path,"jpg")

* Mon 02 Sep 2013 05:23:38 PM JST
def screanshot(path):
    """SUMMARY

    @Arguments:
    - `path`:

    @Return:
    """
    w = gtk.gdk.get_default_root_window()
    sz = w.get_size()
    pb = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB,False,8,sz[0],sz[1])
    pb = pb.get_from_drawable(w,w.get_colormap(),0,0,0,0,sz[0],sz[1])
    if (pb != None):
        pb.save(path,"jpg")

* Mon 02 Sep 2013 05:24:46 PM JST
jpg
* Mon 02 Sep 2013 05:24:57 PM JST
def screanshot(path):
    """SUMMARY

    @Arguments:
    - `path`:

    @Return:
    """
    w = gtk.gdk.get_default_root_window()
    sz = w.get_size()
    pb = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB,False,8,sz[0],sz[1])
    pb = pb.get_from_drawable(w,w.get_colormap(),0,0,0,0,sz[0],sz[1])
    if (pb != None):
        pb.save(path,"png")
* Mon 02 Sep 2013 05:31:43 PM JST
def screanshot(path):
    """SUMMARY

    @Arguments:
    - `path`:

    @Return:
    """
    w = gtk.gdk.get_default_root_window()
    sz = w.get_size()
    pb = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB,False,8,sz[0],sz[1])
    pb = pb.get_from_drawable(w,w.get_colormap(),0,0,0,0,sz[0],sz[1])
    if (pb != None):
        pb.save(path,"png")

* Mon 02 Sep 2013 05:39:56 PM JST

* Mon 02 Sep 2013 05:39:56 PM JST

* Mon 02 Sep 2013 05:39:56 PM JST
im = screenshot.grab()

* Mon 02 Sep 2013 05:39:58 PM JST
save()
* Mon 02 Sep 2013 05:40:01 PM JST
im.save()
* Mon 02 Sep 2013 05:41:16 PM JST
time.strftime('%Y%m%d.png'
* Mon 02 Sep 2013 05:41:37 PM JST
time.strftime('%Y%m%d%s.png')
* Mon 02 Sep 2013 05:43:08 PM JST
hm.start()
* Mon 02 Sep 2013 05:43:11 PM JST
time.sleep(10)
* Mon 02 Sep 2013 05:44:49 PM JST
pyscreenshot.
* Mon 02 Sep 2013 05:47:05 PM JST
2013-09-02-173303.junk.py
* Mon 02 Sep 2013 05:48:59 PM JST
/usr/local/lib/python2.7/dist-packages/pyscreenshot/__init__.py
* Mon 02 Sep 2013 05:49:05 PM JST
/usr/local/lib/python2.7/dist-packages/pyscreenshot/
* Mon 02 Sep 2013 05:51:11 PM JST
childprocess = 
* Mon 02 Sep 2013 05:55:52 PM JST
middle
* Mon 02 Sep 2013 10:20:12 PM JST

* Mon 02 Sep 2013 10:20:13 PM JST

* Mon 02 Sep 2013 10:20:13 PM JST
import commands

* Mon 02 Sep 2013 10:23:29 PM JST

* Mon 02 Sep 2013 10:23:29 PM JST

* Mon 02 Sep 2013 10:23:29 PM JST
sys.exit()

* Mon 02 Sep 2013 10:28:32 PM JST

* Mon 02 Sep 2013 10:28:32 PM JST

* Mon 02 Sep 2013 10:28:32 PM JST
from types import ListType

* Mon 02 Sep 2013 10:32:21 PM JST

* Mon 02 Sep 2013 10:32:21 PM JST

* Mon 02 Sep 2013 10:32:21 PM JST
    for n in names:

* Mon 02 Sep 2013 10:37:05 PM JST
'【天気】'.decode('UTF-8')
* Mon 02 Sep 2013 10:37:14 PM JST
'Japan News'
* Mon 02 Sep 2013 10:37:21 PM JST
'Foreign News'
* Mon 02 Sep 2013 10:37:33 PM JST
urls = g.get_urls(n)[::-1]
* Mon 02 Sep 2013 10:37:46 PM JST
openchrome('"' + '" "'.join(urls) + '"')
* Mon 02 Sep 2013 10:37:52 PM JST
g.clear()
* Mon 02 Sep 2013 10:38:06 PM JST
wait_enter(text='Please Enter wil next: ')
* Mon 02 Sep 2013 10:38:55 PM JST
['【天気】'.decode('UTF-8'), 'Japan News', 'Foreign News']
* Mon 02 Sep 2013 10:42:02 PM JST

* Mon 02 Sep 2013 10:42:02 PM JST

* Mon 02 Sep 2013 10:42:02 PM JST
from types import ListType

* Mon 02 Sep 2013 10:45:27 PM JST
True
* Mon 02 Sep 2013 10:45:34 PM JST
False
* Mon 02 Sep 2013 10:45:40 PM JST
True
* Mon 02 Sep 2013 10:55:03 PM JST

* Mon 02 Sep 2013 10:55:03 PM JST

* Mon 02 Sep 2013 10:55:03 PM JST
os.system('evolution mailto:taka16daily@gmail.com')

* Mon 02 Sep 2013 11:20:20 PM JST
os.system('/usr/bin/google-chrome {0}'.format(url))
* Mon 02 Sep 2013 11:22:55 PM JST
pass
* Mon 02 Sep 2013 11:23:16 PM JST
## rss
#
if not psexists('Sleipnir.exe'):
    os.system('/usr/local/bin/s')
    sleep(5)
    os.system('/usr/bin/sikuli-ide -r /root/work/sikuli/sleipnir_rss.skl')


* Mon 02 Sep 2013 11:23:31 PM JST
g = ChromeBMParse()
name_list = ['【天気】'.decode('UTF-8'), 'Japan News', 'Foreign News']
for name in name_list:
    urls = g.get_urls(name)[::-1]
    openchrome('"' + '" "'.join(urls) + '"')
    g.clear()
    if not name == name_list[-1]:
        wait_enter(text='Please Enter wil next: ')
del g


* Mon 02 Sep 2013 11:24:19 PM JST
sleep(300) # 5 min
while 1:
    sleep(5)
    if psutil.cpu_percent(interval=1, percpu=False) < 20.0:
        os.system('evolution mailto:taka16daily@gmail.com')
        break

* Mon 02 Sep 2013 11:25:23 PM JST
    if not psexists('Sleipnir.exe'):
        os.system('/usr/local/bin/s')
        sleep(5)
        os.system('/usr/bin/sikuli-ide -r /root/work/sikuli/sleipnir_rss.skl')


* Mon 02 Sep 2013 11:25:39 PM JST
    g = ChromeBMParse()
    name_list = ['【天気】'.decode('UTF-8'), 'Japan News', 'Foreign News']
    for name in name_list:
        urls = g.get_urls(name)[::-1]
        openchrome('"' + '" "'.join(urls) + '"')
        g.clear()
        if not name == name_list[-1]:
            wait_enter(text='Please Enter wil next: ')
    del g

* Mon 02 Sep 2013 11:25:53 PM JST
    sleep(300) # 5 min
    while 1:
        sleep(5)
        if psutil.cpu_percent(interval=1, percpu=False) < 20.0:
            os.system('evolution mailto:taka16daily@gmail.com')
            break

* Mon 02 Sep 2013 11:28:48 PM JST
# -*- mode: snippet -*-
# name: sleep
# key: sleep
# condition: (not (python-in-string/comment))
# --
sleep(${1:SEC})$0`(py--insert-imports "time[ \t]+import[ \t]+sleep" "from time import sleep")`
* Mon 02 Sep 2013 11:29:39 PM JST
# condition: (not (python-in-string/comment))
* Mon 02 Sep 2013 11:29:45 PM JST

* Mon 02 Sep 2013 11:29:45 PM JST

* Mon 02 Sep 2013 11:29:45 PM JST
# expand-env: ((some-var some-value))

* Mon 02 Sep 2013 11:29:55 PM JST

* Mon 02 Sep 2013 11:29:55 PM JST

* Mon 02 Sep 2013 11:29:55 PM JST
# -*- mode: snippet -*-

* Mon 02 Sep 2013 11:29:55 PM JST
# -*- mode: snippet -*-

* Mon 02 Sep 2013 11:29:55 PM JST
# -*- mode: snippet -*-
# name: sleep

* Mon 02 Sep 2013 11:29:56 PM JST
# -*- mode: snippet -*-
# name: sleep

* Mon 02 Sep 2013 11:29:56 PM JST
# -*- mode: snippet -*-
# name: sleep
# key: sleep

* Mon 02 Sep 2013 11:29:56 PM JST
# -*- mode: snippet -*-
# name: sleep
# key: sleep

* Mon 02 Sep 2013 11:29:56 PM JST
# -*- mode: snippet -*-
# name: sleep
# key: sleep
# condition: (not (python-in-string/comment))

* Mon 02 Sep 2013 11:29:56 PM JST
# -*- mode: snippet -*-
# name: sleep
# key: sleep
# condition: (not (python-in-string/comment))

* Mon 02 Sep 2013 11:29:57 PM JST
# -*- mode: snippet -*-
# name: sleep
# key: sleep
# condition: (not (python-in-string/comment))
# --

* Mon 02 Sep 2013 11:30:16 PM JST
num
* Mon 02 Sep 2013 11:32:28 PM JST

* Mon 02 Sep 2013 11:32:28 PM JST

* Mon 02 Sep 2013 11:32:28 PM JST
import sys

* Mon 02 Sep 2013 11:32:29 PM JST

* Mon 02 Sep 2013 11:32:29 PM JST

* Mon 02 Sep 2013 11:32:29 PM JST
import sys

* Mon 02 Sep 2013 11:32:34 PM JST
sys.exit(1)
* Mon 02 Sep 2013 11:32:53 PM JST
sys.exit(1)
* Mon 02 Sep 2013 11:33:48 PM JST

* Mon 02 Sep 2013 11:33:49 PM JST

* Mon 02 Sep 2013 11:33:49 PM JST
import sys

* Mon 02 Sep 2013 11:34:18 PM JST
sys.exit(1)
* Mon 02 Sep 2013 11:34:22 PM JST

* Mon 02 Sep 2013 11:34:22 PM JST

* Mon 02 Sep 2013 11:34:22 PM JST
import sys

* Mon 02 Sep 2013 11:34:44 PM JST
py--insert-imports
* Mon 02 Sep 2013 11:35:34 PM JST
sys.exit(1)
* Mon 02 Sep 2013 11:35:36 PM JST

* Mon 02 Sep 2013 11:35:36 PM JST

* Mon 02 Sep 2013 11:35:36 PM JST
import sys

* Mon 02 Sep 2013 11:35:42 PM JST
sys.exit(exitcode)
* Mon 02 Sep 2013 11:35:44 PM JST

* Mon 02 Sep 2013 11:35:44 PM JST

* Mon 02 Sep 2013 11:35:44 PM JST
import sys

* Mon 02 Sep 2013 11:35:52 PM JST

* Mon 02 Sep 2013 11:35:52 PM JST

* Mon 02 Sep 2013 11:35:52 PM JST
    sys.exit(1)

* Mon 02 Sep 2013 11:38:00 PM JST
# -*- mode: snippet -*-
# name: sleep
# key: sleep
# condition: (not (python-in-string/comment))
# --

* Mon 02 Sep 2013 11:38:02 PM JST
# condition: (not (python-in-string/comment))
* Mon 02 Sep 2013 11:38:06 PM JST

* Mon 02 Sep 2013 11:38:06 PM JST

* Mon 02 Sep 2013 11:38:06 PM JST
# binding: "keybinding"

* Mon 02 Sep 2013 11:38:31 PM JST
sys.exit(${1:exitcode})$0`(py--insert-imports "sys" "import sys")`
* Mon 02 Sep 2013 11:38:36 PM JST
exit
* Mon 02 Sep 2013 11:38:36 PM JST
sys.exit
* Mon 02 Sep 2013 11:39:46 PM JST
exitcode
* Mon 02 Sep 2013 11:39:56 PM JST
${1:apath}
* Mon 02 Sep 2013 11:40:20 PM JST
$0
* Mon 02 Sep 2013 11:40:45 PM JST
sys
* Mon 02 Sep 2013 11:42:49 PM JST
# -*- mode: snippet -*-
# name: os.path.join
# key: os.path.join
# condition: (not (python-in-string/comment))
# --
os.path.join(${1:APATH}, ${1:BPATH}$0)`(py--insert-imports "os" "import os")`
* Mon 02 Sep 2013 11:43:12 PM JST

* Mon 02 Sep 2013 11:43:12 PM JST

* Mon 02 Sep 2013 11:43:12 PM JST
import os

* Mon 02 Sep 2013 11:44:05 PM JST

* Mon 02 Sep 2013 11:44:05 PM JST

* Mon 02 Sep 2013 11:44:05 PM JST
_os.path.join(APATH, ls)
* Mon 02 Sep 2013 11:44:06 PM JST

* Mon 02 Sep 2013 11:44:06 PM JST

* Mon 02 Sep 2013 11:44:06 PM JST
import os as _os

* Mon 02 Sep 2013 11:45:48 PM JST
_os.path.join('/hello', 'world')
* Mon 02 Sep 2013 11:47:36 PM JST
, *CPATH
* Mon 02 Sep 2013 11:47:52 PM JST

* Mon 02 Sep 2013 11:47:52 PM JST

* Mon 02 Sep 2013 11:47:52 PM JST
os.path.join('/data', 'hello')

* Mon 02 Sep 2013 11:47:52 PM JST
os.path.join('/data', 'hello')

* Mon 02 Sep 2013 11:47:52 PM JST
os.path.join('/data', 'hello')
_os.path.join('/data', 'hello')

* Mon 02 Sep 2013 11:47:52 PM JST
os.path.join('/data', 'hello')
_os.path.join('/data', 'hello')

* Mon 02 Sep 2013 11:47:52 PM JST
os.path.join('/data', 'hello')
_os.path.join('/data', 'hello')
_os.path.join('/hello', 'world')

* Mon 02 Sep 2013 11:47:53 PM JST

* Mon 02 Sep 2013 11:47:53 PM JST

* Mon 02 Sep 2013 11:47:53 PM JST
os.path.join('hello', 'world')
* Mon 02 Sep 2013 11:47:54 PM JST

* Mon 02 Sep 2013 11:47:54 PM JST

* Mon 02 Sep 2013 11:47:54 PM JST
import os as _os

* Mon 02 Sep 2013 11:47:54 PM JST
import os as _os

* Mon 02 Sep 2013 11:47:54 PM JST
import os as _os
import os

* Mon 02 Sep 2013 11:48:29 PM JST

* Mon 02 Sep 2013 11:48:29 PM JST

* Mon 02 Sep 2013 11:48:29 PM JST
os.path.join('hello', 'world')

* Mon 02 Sep 2013 11:49:03 PM JST
# -*- mode: snippet -*-
# name: os.path.join
# key: os.path.join
# condition: (not (python-in-string/comment))
# --
os.path.join(${1:APATH}, ${2:BPATH, *CPATH}$0)`(py--insert-imports "os" "import os")`
* Mon 02 Sep 2013 11:49:11 PM JST
join
* Mon 02 Sep 2013 11:49:14 PM JST
join
* Mon 02 Sep 2013 11:49:26 PM JST
join
* Mon 02 Sep 2013 11:49:42 PM JST
$0
* Mon 02 Sep 2013 11:50:13 PM JST
join
* Mon 02 Sep 2013 11:51:09 PM JST
# -*- mode: snippet -*-
# name: os.path.exists
# key: os.path.exists
# condition: (not (python-in-string/comment))
# --
os.path.exists(${1:PATH})$0`(py--insert-imports "os" "import os")`

* Mon 02 Sep 2013 11:51:24 PM JST
`(py--insert-imports "os[ \t]+as _os" "import os as _os")`
* Mon 02 Sep 2013 11:51:47 PM JST

* Mon 02 Sep 2013 11:51:47 PM JST

* Mon 02 Sep 2013 11:51:47 PM JST
os.path.exists('hello')

* Mon 02 Sep 2013 11:51:48 PM JST

* Mon 02 Sep 2013 11:51:48 PM JST

* Mon 02 Sep 2013 11:51:48 PM JST
import os

* Mon 02 Sep 2013 11:52:26 PM JST

* Mon 02 Sep 2013 11:52:26 PM JST

* Mon 02 Sep 2013 11:52:27 PM JST
os.path.exists('hello')

* Mon 02 Sep 2013 11:52:27 PM JST
os.path.exists('hello')

* Mon 02 Sep 2013 11:52:27 PM JST
os.path.exists('hello')
os.path.exists('hellow')

* Mon 02 Sep 2013 11:52:27 PM JST
os.path.exists('hello')
os.path.exists('hellow')

* Mon 02 Sep 2013 11:52:27 PM JST
os.path.exists('hello')
os.path.exists('hellow')
_os.path.exists('hello')

* Mon 02 Sep 2013 11:53:41 PM JST
# -*- mode: snippet -*-
# name: os.path.exists
# key: os.path.exists
# condition: (not (python-in-string/comment))
# --
os.path.exists(${1:PATH})$0`(py--insert-imports "os" "import os")`

* Mon 02 Sep 2013 11:53:49 PM JST
exists
* Mon 02 Sep 2013 11:53:52 PM JST
exists
* Mon 02 Sep 2013 11:54:02 PM JST
exists
* Mon 02 Sep 2013 11:55:44 PM JST
# -*- mode: snippet -*-
# name: _os.path.exists
# key: _os.path.exists
# condition: (not (python-in-string/comment))
# --
_os.path.exists(${1:PATH})$0`(py--insert-imports "os[ \t]+as _os" "import os as _os")`

* Mon 02 Sep 2013 11:55:51 PM JST
exists
* Mon 02 Sep 2013 11:55:55 PM JST
exists
* Mon 02 Sep 2013 11:56:13 PM JST
exists
* Mon 02 Sep 2013 11:57:17 PM JST
basename
* Mon 02 Sep 2013 11:57:55 PM JST
# -*- mode: snippet -*-
# name: os.path.basename
# key: os.path.basename
# condition: (not (python-in-string/comment))
# --
os.path.basename(${1:PATH})$0`(py--insert-imports "os" "import os")`

* Mon 02 Sep 2013 11:58:04 PM JST
basename
* Mon 02 Sep 2013 11:58:08 PM JST
basename
* Mon 02 Sep 2013 11:58:18 PM JST
basename
* Mon 02 Sep 2013 11:58:51 PM JST
# -*- mode: snippet -*-
# name: _os.path.basename
# key: _os.path.basename
# condition: (not (python-in-string/comment))
# --
_os.path.basename(${1:PATH})$0`(py--insert-imports "os[ \t]+as _os" "import os as _os")`

* Mon 02 Sep 2013 11:59:01 PM JST
basename
* Mon 02 Sep 2013 11:59:04 PM JST
basename
* Mon 02 Sep 2013 11:59:13 PM JST
basename
* Tue 03 Sep 2013 12:00:23 AM JST
curdir
* Tue 03 Sep 2013 12:00:41 AM JST
help(
* Tue 03 Sep 2013 12:01:08 AM JST
curdir
* Tue 03 Sep 2013 12:01:48 AM JST
# -*- mode: snippet -*-
# name: os.path.abspath
# key: os.path.abspath
# condition: (not (python-in-string/comment))
# --
os.path.abspath(${1:PATH})$0`(py--insert-imports "os" "import os")`

* Tue 03 Sep 2013 12:01:55 AM JST
abspath
* Tue 03 Sep 2013 12:01:58 AM JST
abspath
* Tue 03 Sep 2013 12:02:03 AM JST
abspath
* Tue 03 Sep 2013 12:02:30 AM JST
# -*- mode: snippet -*-
# name: _os.path.abspath
# key: _os.path.abspath
# condition: (not (python-in-string/comment))
# --
_os.path.abspath(${1:PATH})$0`(py--insert-imports "os[ \t]+as _os" "import os as _os")`

* Tue 03 Sep 2013 12:02:38 AM JST
abspath
* Tue 03 Sep 2013 12:02:40 AM JST
abspath
* Tue 03 Sep 2013 12:02:49 AM JST
abspath
* Tue 03 Sep 2013 12:03:37 AM JST
dirname
* Tue 03 Sep 2013 12:04:07 AM JST
# -*- mode: snippet -*-
# name: _os.path.dirname
# key: _os.path.dirname
# condition: (not (python-in-string/comment))
# --
_os.path.dirname(${1:PATH})$0`(py--insert-imports "os[ \t]+as _os" "import os as _os")`

* Tue 03 Sep 2013 12:04:13 AM JST
dirname
* Tue 03 Sep 2013 12:04:17 AM JST
dirname
* Tue 03 Sep 2013 12:04:27 AM JST
dirname
* Tue 03 Sep 2013 12:05:39 AM JST
`(py--insert-imports "os" "import os")`
* Tue 03 Sep 2013 12:07:23 AM JST
# -*- mode: snippet -*-
# name: _os.path.abspath
# key: _os.path.abspath
# condition: (not (python-in-string/comment))
# --
_os.path.abspath(${1:PATH})$0`(py--insert-imports "os[ \t]+as _os" "import os as _os")`

* Tue 03 Sep 2013 12:07:30 AM JST
abspath
* Tue 03 Sep 2013 12:07:37 AM JST
abspath
* Tue 03 Sep 2013 12:07:40 AM JST
abspath
* Tue 03 Sep 2013 12:08:03 AM JST
# -*- mode: snippet -*-
# name: _os.path.dirname
# key: _os.path.dirname
# condition: (not (python-in-string/comment))
# --
_os.path.dirname(${1:PATH})$0`(py--insert-imports "os[ \t]+as _os" "import os as _os")`

* Tue 03 Sep 2013 12:08:13 AM JST
dirname
* Tue 03 Sep 2013 12:08:17 AM JST
dirname
* Tue 03 Sep 2013 12:08:24 AM JST
dirname
* Tue 03 Sep 2013 12:09:13 AM JST
expanduser
* Tue 03 Sep 2013 12:09:48 AM JST
# -*- mode: snippet -*-
# name: os.path.expanduser
# key: os.path.expanduser
# condition: (not (python-in-string/comment))
# --
os.path.expanduser(${1:PATH})$0`(py--insert-imports "os" "import os")`

* Tue 03 Sep 2013 12:10:05 AM JST
# -*- mode: snippet -*-
# name: _os.path.expanduser
# key: _os.path.expanduser
# condition: (not (python-in-string/comment))
# --
_os.path.expanduser(${1:PATH})$0`(py--insert-imports "os[ \t]+as _os" "import os as _os")`

* Tue 03 Sep 2013 12:11:27 AM JST
# -*- mode: snippet -*-
# name: os.path.expanduser
# key: os.path.expanduser
# condition: (not (python-in-string/comment))
# --
os.path.expandvars(${1:PATH})$0`(py--insert-imports "os" "import os")`

* Tue 03 Sep 2013 12:11:32 AM JST
expanduser
* Tue 03 Sep 2013 12:11:38 AM JST
expanduser
* Tue 03 Sep 2013 12:11:42 AM JST
expandvars
* Tue 03 Sep 2013 12:12:48 AM JST
# -*- mode: snippet -*-
# name: os.path.isabs
# key: os.path.isabs
# condition: (not (python-in-string/comment))
# --
os.path.isabs(${1:PATH})$0`(py--insert-imports "os" "import os")`

* Tue 03 Sep 2013 12:15:51 AM JST
# -*- mode: snippet -*-
# name: _os.path.expandvars
# key: _os.path.expanduvars
# condition: (not (python-in-string/comment))
# --
_os.path.expandvars(${1:PATH})$0`(py--insert-imports "os[ \t]+as _os" "import os as _os")`

* Tue 03 Sep 2013 12:16:26 AM JST
# -*- mode: snippet -*-
# name: _os.path.isabs
# key: _os.path.isabs
# condition: (not (python-in-string/comment))
# --
_os.path.isabs(${1:PATH})$0`(py--insert-imports "os[ \t]+as _os" "import os as _os")`

* Tue 03 Sep 2013 12:17:30 AM JST
isabs
* Tue 03 Sep 2013 12:18:04 AM JST
# -*- mode: snippet -*-
# name: _os.path.isfile
# key: _os.path.isfile
# condition: (not (python-in-string/comment))
# --
_os.path.isfile(${1:PATH})$0`(py--insert-imports "os[ \t]+as _os" "import os as _os")`

* Tue 03 Sep 2013 12:19:48 AM JST
expandvars
* Tue 03 Sep 2013 12:20:21 AM JST
# -*- mode: snippet -*-
# name: os.path.ismount
# key: os.path.ismount
# condition: (not (python-in-string/comment))
# --
os.path.ismount(${1:PATH})$0`(py--insert-imports "os" "import os")`

* Tue 03 Sep 2013 12:20:29 AM JST
ismount
* Tue 03 Sep 2013 12:20:32 AM JST
ismount
* Tue 03 Sep 2013 12:20:39 AM JST
ismount
* Tue 03 Sep 2013 12:20:59 AM JST
# -*- mode: snippet -*-
# name: _os.path.ismount
# key: _os.path.ismount
# condition: (not (python-in-string/comment))
# --
_os.path.ismount(${1:PATH})$0`(py--insert-imports "os[ \t]+as _os" "import os as _os")`

* Tue 03 Sep 2013 12:21:05 AM JST
ismount
* Tue 03 Sep 2013 12:21:08 AM JST
ismount
* Tue 03 Sep 2013 12:21:12 AM JST
ismount
* Tue 03 Sep 2013 12:22:19 AM JST
# -*- mode: snippet -*-
# name: os.path.normpath
# key: os.path.normpath
# condition: (not (python-in-string/comment))
# --
os.path.normpath(${1:PATH})$0`(py--insert-imports "os" "import os")`

* Tue 03 Sep 2013 12:22:23 AM JST
normpath
* Tue 03 Sep 2013 12:22:26 AM JST
normpath
* Tue 03 Sep 2013 12:22:34 AM JST
normpath
* Tue 03 Sep 2013 12:22:40 AM JST
PATH
* Tue 03 Sep 2013 12:23:00 AM JST
# -*- mode: snippet -*-
# name: _os.path.normpath
# key: _os.path.normpath
# condition: (not (python-in-string/comment))
# --
_os.path.normpath(${1:PATH})$0`(py--insert-imports "os[ \t]+as _os" "import os as _os")`

* Tue 03 Sep 2013 12:23:06 AM JST
normpath
* Tue 03 Sep 2013 12:23:09 AM JST
normpath
* Tue 03 Sep 2013 12:23:14 AM JST
normpath
* Tue 03 Sep 2013 12:23:18 AM JST
PATH
* Tue 03 Sep 2013 12:23:44 AM JST
relpath
* Tue 03 Sep 2013 12:24:26 AM JST
stat
* Tue 03 Sep 2013 12:25:47 AM JST
# -*- mode: snippet -*-
# name: os.path.realpath
# key: os.path.realpath
# condition: (not (python-in-string/comment))
# --
os.path.realpath(${1:FILENAME})$0`(py--insert-imports "os" "import os")`

* Tue 03 Sep 2013 12:25:55 AM JST
realpath
* Tue 03 Sep 2013 12:25:59 AM JST
realpath
* Tue 03 Sep 2013 12:26:04 AM JST
realpath
* Tue 03 Sep 2013 12:26:11 AM JST
FILENAME
* Tue 03 Sep 2013 12:26:19 AM JST
${1:TOP}
* Tue 03 Sep 2013 12:26:24 AM JST
TOP
* Tue 03 Sep 2013 12:26:41 AM JST
${2:FUNC}
* Tue 03 Sep 2013 12:26:48 AM JST
FUNC
* Tue 03 Sep 2013 12:27:37 AM JST
# -*- mode: snippet -*-
# name: _os.path.realpath
# key: _os.path.realpath
# condition: (not (python-in-string/comment))
# --
_os.path.realpath(${1:FILENAME})$0`(py--insert-imports "os[ \t]+as _os" "import os as _os")`

* Tue 03 Sep 2013 12:27:41 AM JST
realpath
* Tue 03 Sep 2013 12:27:44 AM JST
realpath
* Tue 03 Sep 2013 12:27:48 AM JST
realpath
* Tue 03 Sep 2013 12:28:01 AM JST
${1:TOP}, ${2:FUNC}, ${3:ARG}
* Tue 03 Sep 2013 12:29:41 AM JST

* Tue 03 Sep 2013 12:29:41 AM JST

* Tue 03 Sep 2013 12:29:41 AM JST
import os as _os

* Tue 03 Sep 2013 12:29:41 AM JST
import os as _os

* Tue 03 Sep 2013 12:29:41 AM JST
import os as _os
import os

* Tue 03 Sep 2013 12:30:07 AM JST

* Tue 03 Sep 2013 12:30:07 AM JST

* Tue 03 Sep 2013 12:30:07 AM JST
import os

* Tue 03 Sep 2013 12:30:07 AM JST
import os

* Tue 03 Sep 2013 12:30:07 AM JST
import os
import os

* Tue 03 Sep 2013 12:30:31 AM JST

* Tue 03 Sep 2013 12:30:31 AM JST

* Tue 03 Sep 2013 12:30:31 AM JST
import os as _os

* Tue 03 Sep 2013 12:30:55 AM JST

* Tue 03 Sep 2013 12:30:55 AM JST

* Tue 03 Sep 2013 12:30:55 AM JST
_os.path.realpath(FILENAME)

* Tue 03 Sep 2013 12:30:57 AM JST

* Tue 03 Sep 2013 12:30:57 AM JST

* Tue 03 Sep 2013 12:30:57 AM JST
import os as _os

* Tue 03 Sep 2013 12:31:11 AM JST

* Tue 03 Sep 2013 12:31:11 AM JST

* Tue 03 Sep 2013 12:31:11 AM JST
os.path.realpath(FILENAME)

* Tue 03 Sep 2013 12:31:12 AM JST

* Tue 03 Sep 2013 12:31:12 AM JST

* Tue 03 Sep 2013 12:31:12 AM JST
import os

* Tue 03 Sep 2013 12:31:44 AM JST

* Tue 03 Sep 2013 12:31:44 AM JST

* Tue 03 Sep 2013 12:31:44 AM JST
os.path.normpath(PATH)

* Tue 03 Sep 2013 12:31:46 AM JST

* Tue 03 Sep 2013 12:31:46 AM JST

* Tue 03 Sep 2013 12:31:46 AM JST
import os

* Tue 03 Sep 2013 12:32:16 AM JST

* Tue 03 Sep 2013 12:32:16 AM JST

* Tue 03 Sep 2013 12:32:16 AM JST
_os.path.normpath(PATH)

* Tue 03 Sep 2013 12:32:18 AM JST

* Tue 03 Sep 2013 12:32:18 AM JST

* Tue 03 Sep 2013 12:32:18 AM JST
import os as _os

* Tue 03 Sep 2013 12:32:41 AM JST

* Tue 03 Sep 2013 12:32:41 AM JST

* Tue 03 Sep 2013 12:32:41 AM JST
os.path.ismount(PATH)

* Tue 03 Sep 2013 12:32:43 AM JST

* Tue 03 Sep 2013 12:32:43 AM JST

* Tue 03 Sep 2013 12:32:43 AM JST
import os

* Tue 03 Sep 2013 12:33:06 AM JST

* Tue 03 Sep 2013 12:33:06 AM JST

* Tue 03 Sep 2013 12:33:06 AM JST
_os.path.ismount(PATH)

* Tue 03 Sep 2013 12:33:07 AM JST

* Tue 03 Sep 2013 12:33:07 AM JST

* Tue 03 Sep 2013 12:33:07 AM JST
import os as _os

* Tue 03 Sep 2013 12:33:32 AM JST

* Tue 03 Sep 2013 12:33:32 AM JST

* Tue 03 Sep 2013 12:33:32 AM JST
os.path.islink(PATH)

* Tue 03 Sep 2013 12:33:33 AM JST

* Tue 03 Sep 2013 12:33:33 AM JST

* Tue 03 Sep 2013 12:33:33 AM JST
import os

* Tue 03 Sep 2013 12:33:40 AM JST

* Tue 03 Sep 2013 12:33:40 AM JST

* Tue 03 Sep 2013 12:33:40 AM JST
_os.path.islink(PATH)

* Tue 03 Sep 2013 12:33:41 AM JST

* Tue 03 Sep 2013 12:33:41 AM JST

* Tue 03 Sep 2013 12:33:41 AM JST
import os as _os

* Tue 03 Sep 2013 12:33:59 AM JST

* Tue 03 Sep 2013 12:33:59 AM JST

* Tue 03 Sep 2013 12:33:59 AM JST
os.path.isfile(PATH)

* Tue 03 Sep 2013 12:33:59 AM JST
os.path.isfile(PATH)

* Tue 03 Sep 2013 12:34:00 AM JST
os.path.isfile(PATH)
_os.path.isfile(PATH)

* Tue 03 Sep 2013 12:34:01 AM JST

* Tue 03 Sep 2013 12:34:01 AM JST

* Tue 03 Sep 2013 12:34:01 AM JST
import os as _os

* Tue 03 Sep 2013 12:34:01 AM JST
import os as _os

* Tue 03 Sep 2013 12:34:01 AM JST
import os as _os
import os

* Tue 03 Sep 2013 12:34:18 AM JST

* Tue 03 Sep 2013 12:34:18 AM JST

* Tue 03 Sep 2013 12:34:18 AM JST
os.path.isdir(PATH)

* Tue 03 Sep 2013 12:34:19 AM JST
os.path.isdir(PATH)

* Tue 03 Sep 2013 12:34:19 AM JST
os.path.isdir(PATH)
_os.path.isdir()

* Tue 03 Sep 2013 12:34:20 AM JST

* Tue 03 Sep 2013 12:34:20 AM JST

* Tue 03 Sep 2013 12:34:20 AM JST
import os as _os

* Tue 03 Sep 2013 12:34:20 AM JST
import os as _os

* Tue 03 Sep 2013 12:34:20 AM JST
import os as _os
import os

* Tue 03 Sep 2013 12:34:40 AM JST

* Tue 03 Sep 2013 12:34:40 AM JST

* Tue 03 Sep 2013 12:34:40 AM JST
import os as _os

* Tue 03 Sep 2013 12:34:40 AM JST
import os as _os

* Tue 03 Sep 2013 12:34:41 AM JST
import os as _os
import os

* Tue 03 Sep 2013 12:34:42 AM JST

* Tue 03 Sep 2013 12:34:42 AM JST

* Tue 03 Sep 2013 12:34:42 AM JST
os.path.isabs(PATH)

* Tue 03 Sep 2013 12:34:42 AM JST
os.path.isabs(PATH)

* Tue 03 Sep 2013 12:34:42 AM JST
os.path.isabs(PATH)
_os.path.isabs(PATH)

* Tue 03 Sep 2013 12:35:32 AM JST

* Tue 03 Sep 2013 12:35:32 AM JST

* Tue 03 Sep 2013 12:35:32 AM JST
_os.path.expanduser(PATH)

* Tue 03 Sep 2013 12:35:33 AM JST

* Tue 03 Sep 2013 12:35:33 AM JST

* Tue 03 Sep 2013 12:35:33 AM JST
os.path.expandvars()

* Tue 03 Sep 2013 12:35:35 AM JST

* Tue 03 Sep 2013 12:35:35 AM JST

* Tue 03 Sep 2013 12:35:35 AM JST
import os as _os

* Tue 03 Sep 2013 12:35:35 AM JST
import os as _os

* Tue 03 Sep 2013 12:35:35 AM JST
import os as _os
import os

* Tue 03 Sep 2013 12:36:05 AM JST
expanduser
* Tue 03 Sep 2013 12:38:55 AM JST

* Tue 03 Sep 2013 12:38:55 AM JST

* Tue 03 Sep 2013 12:38:55 AM JST
os.path.expandvars(hello)

* Tue 03 Sep 2013 12:38:55 AM JST
os.path.expandvars(hello)

* Tue 03 Sep 2013 12:38:55 AM JST
os.path.expandvars(hello)
_os.path.expandvars(PATH)

* Tue 03 Sep 2013 12:38:57 AM JST

* Tue 03 Sep 2013 12:38:57 AM JST

* Tue 03 Sep 2013 12:38:57 AM JST
import os as _os

* Tue 03 Sep 2013 12:38:57 AM JST
import os as _os

* Tue 03 Sep 2013 12:38:57 AM JST
import os as _os
import os

* Tue 03 Sep 2013 12:39:30 AM JST

* Tue 03 Sep 2013 12:39:31 AM JST

* Tue 03 Sep 2013 12:39:31 AM JST
os.path.dirname(PATH)

* Tue 03 Sep 2013 12:39:31 AM JST
os.path.dirname(PATH)

* Tue 03 Sep 2013 12:39:31 AM JST
os.path.dirname(PATH)
_os.path.dirname(PATH)

* Tue 03 Sep 2013 12:39:55 AM JST

* Tue 03 Sep 2013 12:39:55 AM JST

* Tue 03 Sep 2013 12:39:55 AM JST
import os as _os

* Tue 03 Sep 2013 12:39:55 AM JST
import os as _os

* Tue 03 Sep 2013 12:39:55 AM JST
import os as _os
import os

* Tue 03 Sep 2013 12:40:31 AM JST

* Tue 03 Sep 2013 12:40:32 AM JST

* Tue 03 Sep 2013 12:40:32 AM JST
os.path.abspath(PATH)

* Tue 03 Sep 2013 12:40:32 AM JST
os.path.abspath(PATH)

* Tue 03 Sep 2013 12:40:32 AM JST
os.path.abspath(PATH)
_os.path.abspath(PATH)

* Tue 03 Sep 2013 12:40:33 AM JST

* Tue 03 Sep 2013 12:40:34 AM JST

* Tue 03 Sep 2013 12:40:34 AM JST
import os as _os

* Tue 03 Sep 2013 12:40:34 AM JST
import os as _os

* Tue 03 Sep 2013 12:40:34 AM JST
import os as _os
import os

* Tue 03 Sep 2013 12:41:33 AM JST
basename 
* Tue 03 Sep 2013 12:41:33 AM JST
path.basename 
* Tue 03 Sep 2013 12:41:33 AM JST
os.path.basename 
* Tue 03 Sep 2013 12:41:41 AM JST
os.path.basename 
* Tue 03 Sep 2013 12:42:06 AM JST

* Tue 03 Sep 2013 12:42:06 AM JST

* Tue 03 Sep 2013 12:42:06 AM JST
os.path.basename(PATH)

* Tue 03 Sep 2013 12:42:06 AM JST
os.path.basename(PATH)

* Tue 03 Sep 2013 12:42:07 AM JST
os.path.basename(PATH)
_os.path.basename(PATH)

* Tue 03 Sep 2013 12:42:08 AM JST

* Tue 03 Sep 2013 12:42:09 AM JST

* Tue 03 Sep 2013 12:42:09 AM JST
import os as _os

* Tue 03 Sep 2013 12:42:09 AM JST
import os as _os

* Tue 03 Sep 2013 12:42:09 AM JST
import os as _os
import os

* Tue 03 Sep 2013 12:43:45 AM JST

* Tue 03 Sep 2013 12:43:45 AM JST

* Tue 03 Sep 2013 12:43:45 AM JST
# binding: "keybinding"

* Tue 03 Sep 2013 12:43:45 AM JST
# binding: "keybinding"

* Tue 03 Sep 2013 12:43:45 AM JST
# binding: "keybinding"
# expand-env: ((some-var some-value))

* Tue 03 Sep 2013 12:43:54 AM JST
# condition: (not (python-in-string/comment))
* Tue 03 Sep 2013 12:44:06 AM JST
sleep(${1:SEC})$0`(py--insert-imports "time[ \t]+import[ \t]+sleep" "from time import sleep")`
* Tue 03 Sep 2013 12:44:36 AM JST
sleep
* Tue 03 Sep 2013 12:45:17 AM JST
# -*- mode: snippet -*-
# name: time.sleep
# key: time.sleep
# condition: (not (python-in-string/comment))
# --
time.sleep(${1:SEC})$0`(py--insert-imports "time" "import time")`
* Tue 03 Sep 2013 12:48:55 AM JST
# -*- mode: snippet -*-
# name: time.sleep
# key: time.sleep
# condition: (not (python-in-string/comment))
# --
time.sleep(${1:SEC})$0`(py--insert-imports "time" "import time")`
* Tue 03 Sep 2013 12:49:01 AM JST
sleep
* Tue 03 Sep 2013 12:49:01 AM JST
time.sleep
* Tue 03 Sep 2013 12:49:05 AM JST
sleep
* Tue 03 Sep 2013 12:49:05 AM JST
time.sleep
* Tue 03 Sep 2013 12:49:16 AM JST
sleep
* Tue 03 Sep 2013 12:49:16 AM JST
time.sleep
* Tue 03 Sep 2013 12:49:25 AM JST
SEC
* Tue 03 Sep 2013 12:49:35 AM JST
STRING
* Tue 03 Sep 2013 12:49:40 AM JST
time
* Tue 03 Sep 2013 12:49:43 AM JST
import
* Tue 03 Sep 2013 12:50:01 AM JST
"time[ \t]+import[ \t]+sleep" "from time import sleep"
* Tue 03 Sep 2013 12:50:10 AM JST
time
* Tue 03 Sep 2013 12:50:14 AM JST
sleep
* Tue 03 Sep 2013 12:50:18 AM JST
time
* Tue 03 Sep 2013 12:50:21 AM JST
sleep
* Tue 03 Sep 2013 12:51:45 AM JST
# -*- mode: snippet -*-
# name: _time.sleep
# key: _time.sleep
# condition: (not (python-in-string/comment))
# --
_time.sleep(${1:SEC})$0`(py--insert-imports "time" "import time as _time")`
* Tue 03 Sep 2013 12:51:54 AM JST
getpass(${1:PROMPT})$0`(py--insert-imports "getpass[ \t]+import[ \t]+getpass" "from getpass import getpass")`
* Tue 03 Sep 2013 12:51:58 AM JST
time
* Tue 03 Sep 2013 12:52:01 AM JST
.sleep
* Tue 03 Sep 2013 12:52:03 AM JST
time
* Tue 03 Sep 2013 12:52:06 AM JST
.sleep
* Tue 03 Sep 2013 12:55:44 AM JST
# -*- mode: snippet -*-
# name: getpass
# key: getpass
# condition: (not (python-in-string/comment))
# --
getpass(${1:PROMPT})$0`(py--insert-imports "getpass[ \t]+import[ \t]+getpass" "from getpass import getpass")`
* Tue 03 Sep 2013 12:56:49 AM JST
getpass 
* Tue 03 Sep 2013 12:56:50 AM JST
from getpass 
* Tue 03 Sep 2013 12:57:25 AM JST
# -*- mode: snippet -*-
# name: getpass.getpass
# key: getpass.getpass
# condition: (not (python-in-string/comment))
# --
getpass.getpass(${1:PROMPT})$0`(py--insert-imports "getpass" "import getpass")`

* Tue 03 Sep 2013 12:57:48 AM JST
_getpass.getpass(${1:PROMPT})$0`(py--insert-imports "getpass a
* Tue 03 Sep 2013 12:58:40 AM JST

* Tue 03 Sep 2013 12:58:40 AM JST

* Tue 03 Sep 2013 12:58:40 AM JST
getpass('hello')

* Tue 03 Sep 2013 12:58:42 AM JST

* Tue 03 Sep 2013 12:58:42 AM JST

* Tue 03 Sep 2013 12:58:42 AM JST
from getpass import getpass

* Tue 03 Sep 2013 12:58:55 AM JST

* Tue 03 Sep 2013 12:58:55 AM JST

* Tue 03 Sep 2013 12:58:55 AM JST
_getpass(h)

* Tue 03 Sep 2013 12:58:57 AM JST

* Tue 03 Sep 2013 12:58:57 AM JST

* Tue 03 Sep 2013 12:58:57 AM JST
from getpass import getpass as _getpass

* Tue 03 Sep 2013 12:59:04 AM JST

* Tue 03 Sep 2013 12:59:04 AM JST

* Tue 03 Sep 2013 12:59:04 AM JST
getpass.getpass(PROMPT)

* Tue 03 Sep 2013 12:59:22 AM JST

* Tue 03 Sep 2013 12:59:22 AM JST

* Tue 03 Sep 2013 12:59:22 AM JST
_getpass.getpass(PROMPT)

* Tue 03 Sep 2013 12:59:24 AM JST

* Tue 03 Sep 2013 12:59:24 AM JST

* Tue 03 Sep 2013 12:59:24 AM JST
from getpass import getpass

* Tue 03 Sep 2013 01:04:43 AM JST
# -*- mode: snippet -*-
# name: time.sleep
# key: time.sleep
# condition: (not (python-in-string/comment))
# --
time.sleep(${1:SEC})$0`(py--insert-imports "time" "import time")`
* Tue 03 Sep 2013 01:04:51 AM JST
time
* Tue 03 Sep 2013 01:04:55 AM JST
sleep
* Tue 03 Sep 2013 01:04:58 AM JST
sleep
* Tue 03 Sep 2013 01:05:06 AM JST
time
* Tue 03 Sep 2013 01:05:15 AM JST
time
* Tue 03 Sep 2013 01:05:18 AM JST
sleep
* Tue 03 Sep 2013 01:06:01 AM JST
SEC
* Tue 03 Sep 2013 01:06:08 AM JST
time
* Tue 03 Sep 2013 01:06:12 AM JST
time
* Tue 03 Sep 2013 01:06:38 AM JST
# -*- mode: snippet -*-
# name: _time.sleep
# key: _time.sleep
# condition: (not (python-in-string/comment))
# --
_time.sleep(${1:SEC})$0`(py--insert-imports "time" "import time as _time")`
* Tue 03 Sep 2013 01:06:45 AM JST
sleep
* Tue 03 Sep 2013 01:07:22 AM JST
_shutil.rmtree
* Tue 03 Sep 2013 01:07:39 AM JST
SEC
* Tue 03 Sep 2013 01:07:43 AM JST
time
* Tue 03 Sep 2013 01:08:32 AM JST
time
* Tue 03 Sep 2013 01:10:16 AM JST
# -*- mode: snippet -*-
# name: shutil.rmtree
# key: shutil.rmtree
# condition: (not (python-in-string/comment))
# --
shutil.rmtree(${1:PATH})$0`(py--insert-imports "shutil" "import shutil")`
* Tue 03 Sep 2013 01:10:26 AM JST
rmtree
* Tue 03 Sep 2013 01:10:29 AM JST
rmtree
* Tue 03 Sep 2013 01:10:35 AM JST
rmtree
* Tue 03 Sep 2013 01:10:55 AM JST
rmtree
* Tue 03 Sep 2013 01:11:01 AM JST
PATH
* Tue 03 Sep 2013 01:12:29 AM JST
 
* Tue 03 Sep 2013 01:13:18 AM JST
_shutil.copy(${1:SRC}, ${2:DST})$0`(py--insert-imports "shutil[ \t]+as[ \t]+_shutil" "from 
* Tue 03 Sep 2013 01:13:19 AM JST
from 
* Tue 03 Sep 2013 01:16:44 AM JST
# -*- mode: snippet -*-
# name: shutil.copy
# key: shutil.copy
# condition: (not (python-in-string/comment))
# --
shutil.copy(${1:SRC}, ${2:DST})$0`(py--insert-imports "shutil" "import shutil")`
* Tue 03 Sep 2013 01:17:32 AM JST
"shutil[ \t]+as[ \t]+_shutil" "import shutil as _shutil"
* Tue 03 Sep 2013 01:19:14 AM JST
# -*- mode: snippet -*-
# name: shutil.copy2
# key: shutil.copy2
# condition: (not (python-in-string/comment))
# --
shutil.copy2(${1:SRC}, ${2:DST})$0`(py--insert-imports "shutil" "import shutil")`
* Tue 03 Sep 2013 01:19:20 AM JST
copy2
* Tue 03 Sep 2013 01:19:22 AM JST
copy2
* Tue 03 Sep 2013 01:19:27 AM JST
copy2
* Tue 03 Sep 2013 01:19:36 AM JST
copy2
* Tue 03 Sep 2013 01:21:37 AM JST
# -*- mode: snippet -*-
# name: _shutil.copy2
# key: _shutil.copy2
# condition: (not (python-in-string/comment))
# --
_shutil.copy2(${1:SRC}, ${2:DST})$0`(py--insert-imports "shutil[ \t]+as[ \t]+_shutil" "import shutil as _shutil")`

* Tue 03 Sep 2013 01:21:43 AM JST
copy2
* Tue 03 Sep 2013 01:21:44 AM JST
copy2
* Tue 03 Sep 2013 01:21:50 AM JST
copy2
* Tue 03 Sep 2013 01:22:11 AM JST

* Tue 03 Sep 2013 01:22:11 AM JST

* Tue 03 Sep 2013 01:22:11 AM JST
shutil.move(SRC, DST)

* Tue 03 Sep 2013 01:22:12 AM JST

* Tue 03 Sep 2013 01:22:12 AM JST

* Tue 03 Sep 2013 01:22:12 AM JST
import shutil

* Tue 03 Sep 2013 01:22:34 AM JST

* Tue 03 Sep 2013 01:22:34 AM JST

* Tue 03 Sep 2013 01:22:34 AM JST
import shutil as _shutil

* Tue 03 Sep 2013 01:22:34 AM JST
import shutil as _shutil

* Tue 03 Sep 2013 01:22:34 AM JST
import shutil as _shutil
import shutil

* Tue 03 Sep 2013 01:22:55 AM JST

* Tue 03 Sep 2013 01:22:55 AM JST

* Tue 03 Sep 2013 01:22:55 AM JST
import shutil as _shutil

* Tue 03 Sep 2013 01:22:55 AM JST
import shutil as _shutil

* Tue 03 Sep 2013 01:22:55 AM JST
import shutil as _shutil
import shutil

* Tue 03 Sep 2013 01:23:24 AM JST

* Tue 03 Sep 2013 01:23:24 AM JST

* Tue 03 Sep 2013 01:23:24 AM JST
import shutil as _shutil

* Tue 03 Sep 2013 01:23:25 AM JST
import shutil as _shutil

* Tue 03 Sep 2013 01:23:25 AM JST
import shutil as _shutil
import shutil

* Tue 03 Sep 2013 01:24:29 AM JST
# -*- mode: snippet -*-
# name: shutil.copy2
# key: shutil.copy2
# condition: (not (python-in-string/comment))
# --
shutil.copy2(${1:SRC}, ${2:DST})$0`(py--insert-imports "shutil" "import shutil")`
* Tue 03 Sep 2013 01:24:36 AM JST
copy2
* Tue 03 Sep 2013 01:24:36 AM JST
shutil.copy2
* Tue 03 Sep 2013 01:24:42 AM JST
copy2
* Tue 03 Sep 2013 01:24:43 AM JST
shutil.copy2
* Tue 03 Sep 2013 01:24:50 AM JST
copy2
* Tue 03 Sep 2013 01:24:53 AM JST
shutil
* Tue 03 Sep 2013 01:25:05 AM JST
shutil
* Tue 03 Sep 2013 01:25:09 AM JST
shutil
* Tue 03 Sep 2013 01:25:46 AM JST
# -*- mode: snippet -*-
# name: glob.glob
# key: glob.glob
# condition: (not (python-in-string/comment))
# --
glob.glob(${1:PATHNAME})$0`(py--insert-imports "glob" "import glob")`
* Tue 03 Sep 2013 02:09:05 AM JST
SCREENSHOT ==
* Tue 03 Sep 2013 02:09:56 AM JST
'/tmp/junk/%s.png'
* Tue 03 Sep 2013 02:10:00 AM JST
'/tmp/junk/%s.png'
* Tue 03 Sep 2013 02:11:20 AM JST
time.strftime
* Tue 03 Sep 2013 02:12:16 AM JST
True
* Tue 03 Sep 2013 03:21:04 AM JST
import 
* Tue 03 Sep 2013 03:23:56 AM JST
uinput
* Tue 03 Sep 2013 03:23:58 AM JST
uinput
* Tue 03 Sep 2013 03:24:00 AM JST
uinput
* Tue 03 Sep 2013 03:24:02 AM JST
uinput
* Tue 03 Sep 2013 03:32:59 AM JST
        
* Tue 03 Sep 2013 03:33:04 AM JST
        
* Tue 03 Sep 2013 03:33:10 AM JST
        
* Tue 03 Sep 2013 03:33:15 AM JST
        
* Tue 03 Sep 2013 03:33:21 AM JST
        
* Tue 03 Sep 2013 03:33:27 AM JST
        ui.write(e.EV_KEY, e.KEY_L, 1)
        ui.write(e.EV_KEY, e.KEY_L, 0)

* Tue 03 Sep 2013 03:33:34 AM JST
        
* Tue 03 Sep 2013 03:33:39 AM JST
        
* Tue 03 Sep 2013 03:34:45 AM JST

* Tue 03 Sep 2013 03:34:45 AM JST

* Tue 03 Sep 2013 03:34:45 AM JST
        return

* Tue 03 Sep 2013 11:52:05 AM JST
recursive-directory
* Tue 03 Sep 2013 11:56:41 AM JST
find-lisp-find-dired
* Tue 03 Sep 2013 11:57:03 AM JST
"/root/.emacs.d/elisp/mylisp"
* Tue 03 Sep 2013 12:01:07 PM JST
dired
* Tue 03 Sep 2013 12:01:08 PM JST
find-dired
* Tue 03 Sep 2013 12:01:08 PM JST
lisp-find-dired
* Tue 03 Sep 2013 12:01:08 PM JST
find-lisp-find-dired
* Tue 03 Sep 2013 12:03:02 PM JST
batch-byte-compile
* Tue 03 Sep 2013 12:03:12 PM JST
"/root/.emacs.d/elisp/mylisp/windmove-or-split.el"
* Tue 03 Sep 2013 12:04:08 PM JST
batch-byte-compile-if-not-done
* Tue 03 Sep 2013 12:04:54 PM JST
batch-byte-recompile-directory
* Tue 03 Sep 2013 12:05:13 PM JST
"/root/.emacs.d/elisp/mylisp"
* Tue 03 Sep 2013 12:06:06 PM JST
byte-compile-and-recursion
* Tue 03 Sep 2013 12:10:27 PM JST
mylisp
* Tue 03 Sep 2013 12:14:37 PM JST
file-accessible-directory-p
* Tue 03 Sep 2013 12:14:43 PM JST
"/root/.emacs.d/elisp")
* Tue 03 Sep 2013 12:14:57 PM JST
"/root/.emacs.d/elisp/mylisp/windmove-or-split.el"
* Tue 03 Sep 2013 12:15:00 PM JST

* Tue 03 Sep 2013 12:16:29 PM JST
file-accessible-directory-p
* Tue 03 Sep 2013 12:18:34 PM JST
DIR
* Tue 03 Sep 2013 12:18:59 PM JST
(defun myrecompile-recusively (dir)
  ""
  (interactive)
  (dolist (d (recursive-directory dir))
    (dolist (f (directory-files d 'full ".el$"))
      (unless (file-accessible-directory-p f)
        (batch-byte-compile-file f))))
  )
* Tue 03 Sep 2013 12:43:59 PM JST
BTN_MIDDLE
* Tue 03 Sep 2013 12:44:16 PM JST
from evdev import uinput, ecodes as e
* Tue 03 Sep 2013 12:46:50 PM JST
uinput
* Tue 03 Sep 2013 12:48:51 PM JST
        
* Tue 03 Sep 2013 12:48:53 PM JST
KEY_LEFTCTRL
* Tue 03 Sep 2013 12:49:00 PM JST
ui.write(e.EV_KEY, e.KEY_LEFTCTRL, 1)
* Tue 03 Sep 2013 12:49:04 PM JST
ui.write(e.EV_KEY, e.KEY_W, 1)
* Tue 03 Sep 2013 12:51:17 PM JST
import 
* Tue 03 Sep 2013 12:54:18 PM JST
http://kaizer.se/wiki/python-keybinder/
* Tue 03 Sep 2013 12:55:37 PM JST
/share/pyshared/keybinder/__init__.py
* Tue 03 Sep 2013 12:59:34 PM JST
def catch_button(window, event, label):
        keyval = event.keyval
        name = gtk.gdk.keyval_name(keyval)
        print event.state
        mod = gtk.accelerator_get_label(keyval,event.state)
        label.set_markup('<span size="xx-large">%s\n%d</span>'% (mod, keyval)) 
  
 
window = gtk.Window()
window.set_size_request(640,480)
label = gtk.Label()
label.set_use_markup(True)
window.connect('key-press-event',catch_button, label)
window.connect('destroy', gtk.main_quit)
window.add(label)
window.show_all()
 
gtk.main()
* Tue 03 Sep 2013 01:02:44 PM JST
from Tkinter import *

root = Tk()

def callback(event):
    print "clicked at", event.x, event.y 

frame = Frame(root, width=100, height=100)
frame.bind("<Button-1>", callback)
frame.pack()

root.mainloop()
* Tue 03 Sep 2013 01:04:57 PM JST

* Tue 03 Sep 2013 01:05:04 PM JST
1
* Tue 03 Sep 2013 01:05:12 PM JST
callback
* Tue 03 Sep 2013 01:05:48 PM JST

* Tue 03 Sep 2013 01:05:48 PM JST

* Tue 03 Sep 2013 01:05:48 PM JST
BTN_MIDDLE

* Tue 03 Sep 2013 01:07:58 PM JST
1
* Tue 03 Sep 2013 01:29:25 PM JST
/usr/bin/sikuli-ide
* Tue 03 Sep 2013 01:31:47 PM JST

* Tue 03 Sep 2013 01:35:03 PM JST
local
* Tue 03 Sep 2013 01:36:54 PM JST
 $opt
* Tue 03 Sep 2013 01:41:25 PM JST
sikuliide ] || && 
* Tue 03 Sep 2013 01:59:12 PM JST
tkin
* Tue 03 Sep 2013 01:59:13 PM JST
import tkin
* Tue 03 Sep 2013 02:00:09 PM JST
 import tkMessageBox
* Tue 03 Sep 2013 02:00:14 PM JST
from Tkinter 
* Tue 03 Sep 2013 02:09:47 PM JST
if tkMessageBox.askyesno('hello', 'world'):
    print('hello')
else:
    print('world')


* Tue 03 Sep 2013 02:10:25 PM JST
if yesnodialog('prompt', 'continue?'):
    print('hello')
else:
    print('world')

* Tue 03 Sep 2013 02:11:09 PM JST
import Tkinter
import tkMessageBox

root = Tkinter.Tk()
root.withdraw()


def yesnodialog(title, message):
    """SUMMARY

    @Arguments:
    - `title`:
    - `message`:

    @Return:
    """
    return tkMessageBox.askyesno(title, message)

* Tue 03 Sep 2013 02:11:32 PM JST
root = Tkinter.Tk()
root.withdraw()



* Tue 03 Sep 2013 02:12:21 PM JST
'Please Enter wil next: '
* Tue 03 Sep 2013 02:14:09 PM JST
import Tkinter
import tkMessageBox

root = Tkinter.Tk()
root.withdraw()

def yesnodialog(title, message):
    """SUMMARY

    @Arguments:
    - `title`:
    - `message`:

    @Return:
    """
    return tkMessageBox.askyesno(title, message)

* Tue 03 Sep 2013 02:14:43 PM JST
root = Tkinter.Tk()
root.withdraw()


* Tue 03 Sep 2013 02:14:57 PM JST
def yesnodialog(title, message):
    """SUMMARY

    @Arguments:
    - `title`:
    - `message`:

    @Return:
    """
    root = Tkinter.Tk()
    root.withdraw()
    return tkMessageBox.askyesno(title, message)



* Tue 03 Sep 2013 02:15:25 PM JST
wait_enter
* Tue 03 Sep 2013 02:15:48 PM JST
import Tkinter
import tkMessageBox


* Tue 03 Sep 2013 02:15:51 PM JST
import Tkinter
import tkMessageBox


* Tue 03 Sep 2013 02:16:16 PM JST
from confirm import yesnodialog
* Tue 03 Sep 2013 02:16:31 PM JST

* Tue 03 Sep 2013 02:16:31 PM JST

* Tue 03 Sep 2013 02:16:31 PM JST
from confirm import wait_enter

* Tue 03 Sep 2013 02:16:57 PM JST
wait_enter
* Tue 03 Sep 2013 02:19:55 PM JST

* Tue 03 Sep 2013 02:19:55 PM JST

* Tue 03 Sep 2013 02:19:55 PM JST
            # wait_enter(text='Please Enter wil next: ')

* Tue 03 Sep 2013 04:40:57 PM JST
ntpdate ntp.nict.jp
* Tue 03 Sep 2013 04:43:36 PM JST
# -*- mode: snippet -*-
# name: os.path.isdir
# key: os.path.isdir
# condition: (not (python-in-string/comment))
# --
os.path.isdir(${1:PATH})$0`(py--insert-imports "os" "import os")`

* Tue 03 Sep 2013 04:43:41 PM JST
isdir
* Tue 03 Sep 2013 04:43:42 PM JST
path.isdir
* Tue 03 Sep 2013 04:43:44 PM JST
isdir
* Tue 03 Sep 2013 04:43:45 PM JST
path.isdir
* Tue 03 Sep 2013 04:43:49 PM JST
isdir
* Tue 03 Sep 2013 04:43:49 PM JST
path.isdir
* Tue 03 Sep 2013 04:44:01 PM JST
PATH
* Tue 03 Sep 2013 04:44:32 PM JST
# -*- mode: snippet -*-
# name: _os.path.isabs
# key: _os.path.isabs
# condition: (not (python-in-string/comment))
# --
_os.path.isabs(${1:PATH})$0`(py--insert-imports "os[ \t]+as _os" "import os as _os")`

* Tue 03 Sep 2013 04:44:43 PM JST
isabs
* Tue 03 Sep 2013 04:44:43 PM JST
path.isabs
* Tue 03 Sep 2013 04:44:46 PM JST
isabs
* Tue 03 Sep 2013 04:44:47 PM JST
path.isabs
* Tue 03 Sep 2013 04:44:51 PM JST
isabs
* Tue 03 Sep 2013 04:44:51 PM JST
path.isabs
* Tue 03 Sep 2013 04:44:54 PM JST
PATH
* Tue 03 Sep 2013 04:45:41 PM JST
ntp.nict.jp
* Tue 03 Sep 2013 04:45:43 PM JST

* Tue 03 Sep 2013 04:45:43 PM JST

* Tue 03 Sep 2013 04:45:43 PM JST
    ntpdate ntp.nict.jp

* Tue 03 Sep 2013 04:45:45 PM JST

* Tue 03 Sep 2013 04:45:45 PM JST

* Tue 03 Sep 2013 04:45:45 PM JST
    # TODO: (Atami) [2013/09/03]

* Tue 03 Sep 2013 04:45:50 PM JST
update
* Tue 03 Sep 2013 04:47:37 PM JST
    # ntpdate
    os.system('/usr/sbin/ntpdate ntp.nict.jp')


* Tue 03 Sep 2013 10:11:58 PM JST
http://qiita.com/yuku_t/items/5df06d50c4c349cc0c1b
* Tue 03 Sep 2013 11:08:26 PM JST
/usr/bin/evolution
* Tue 03 Sep 2013 11:09:31 PM JST
cpu_percen
* Wed 04 Sep 2013 04:57:26 AM JST
taka16daily@gmail.com
* Wed 04 Sep 2013 05:10:04 AM JST
today=datetime.date(datetime.now())
* Wed 04 Sep 2013 06:03:43 AM JST
''
* Wed 04 Sep 2013 06:11:14 AM JST
realpath
* Wed 04 Sep 2013 06:11:37 AM JST
join
* Wed 04 Sep 2013 06:12:40 AM JST
datetime.
* Wed 04 Sep 2013 06:12:41 AM JST
                              
* Wed 04 Sep 2013 06:15:59 AM JST
join()
* Wed 04 Sep 2013 06:15:59 AM JST
path.join()
* Wed 04 Sep 2013 06:15:59 AM JST
os.path.join()
* Wed 04 Sep 2013 06:16:04 AM JST
os.path.join(recipe_base_dir, latest)
* Wed 04 Sep 2013 06:16:15 AM JST
sym
* Wed 04 Sep 2013 06:16:20 AM JST
symlink
* Wed 04 Sep 2013 06:17:29 AM JST
week.get(datetime.now().weekday())
* Wed 04 Sep 2013 06:17:48 AM JST
week
* Wed 04 Sep 2013 06:20:55 AM JST
today_base_path
* Wed 04 Sep 2013 06:21:07 AM JST
today_base_path
* Wed 04 Sep 2013 06:21:38 AM JST
today
* Wed 04 Sep 2013 06:21:41 AM JST
today
* Wed 04 Sep 2013 06:22:42 AM JST
week_num
* Wed 04 Sep 2013 06:23:29 AM JST
os.path.basename(weekly_dir)
* Wed 04 Sep 2013 06:25:11 AM JST
dir)
* Wed 04 Sep 2013 06:36:07 AM JST
today_pa
* Wed 04 Sep 2013 06:42:50 AM JST
EVO_FMT.format(ELEMENT)
* Wed 04 Sep 2013 06:46:14 AM JST

* Wed 04 Sep 2013 06:46:14 AM JST

* Wed 04 Sep 2013 06:46:14 AM JST
    body = 'WEATHER: \nTODAYS RECIPE: ' + ', '.join(menus) + '\n'

* Wed 04 Sep 2013 06:46:17 AM JST

* Wed 04 Sep 2013 06:46:17 AM JST

* Wed 04 Sep 2013 06:46:17 AM JST
    body = 

* Wed 04 Sep 2013 06:46:24 AM JST
ELEMENT
* Wed 04 Sep 2013 06:50:20 AM JST
unlink
* Wed 04 Sep 2013 06:50:20 AM JST
path.unlink
* Wed 04 Sep 2013 06:50:26 AM JST
path.
* Wed 04 Sep 2013 06:52:22 AM JST

* Wed 04 Sep 2013 06:52:22 AM JST

* Wed 04 Sep 2013 06:52:22 AM JST
    # ELEMENT = {'bin': CMD.get('evolution'),

* Wed 04 Sep 2013 06:52:22 AM JST
    # ELEMENT = {'bin': CMD.get('evolution'),

* Wed 04 Sep 2013 06:52:22 AM JST
    # ELEMENT = {'bin': CMD.get('evolution'),
    #            'mailto': taka16dailymail,

* Wed 04 Sep 2013 06:52:22 AM JST
    # ELEMENT = {'bin': CMD.get('evolution'),
    #            'mailto': taka16dailymail,

* Wed 04 Sep 2013 06:52:23 AM JST
    # ELEMENT = {'bin': CMD.get('evolution'),
    #            'mailto': taka16dailymail,
    #            'subject': 'daily routines',

* Wed 04 Sep 2013 06:52:23 AM JST
    # ELEMENT = {'bin': CMD.get('evolution'),
    #            'mailto': taka16dailymail,
    #            'subject': 'daily routines',

* Wed 04 Sep 2013 06:52:23 AM JST
    # ELEMENT = {'bin': CMD.get('evolution'),
    #            'mailto': taka16dailymail,
    #            'subject': 'daily routines',
    #            'body': body}

* Wed 04 Sep 2013 06:53:48 AM JST
    
    EVO_FMT = '{0} "mailto:{1}?subject={2}&body={3}"'
    bin_ = CMD.get('evolution')
    mailto = taka16dailymail
    subject = 'daily routines'
    body = 'WEATHER: \nRECIPE: ' + ', '.join(menus) + '\n'

* Wed 04 Sep 2013 06:55:28 AM JST
    week = {1: '1mon',
            2: '2tue',
            3: '3wed',
            4: '4thu',
            5: '5fri',
            6: '6sta',
            7: '0sun'}


* Wed 04 Sep 2013 06:55:46 AM JST
    week = {1: '1mon',
            2: '2tue',
            3: '3wed',
            4: '4thu',
            5: '5fri',
            6: '6sta',
            7: '0sun'}

* Wed 04 Sep 2013 07:06:44 AM JST
listdir
* Wed 04 Sep 2013 07:06:44 AM JST
m.listdir
* Wed 04 Sep 2013 07:06:49 AM JST
today_path
* Wed 04 Sep 2013 07:07:20 AM JST
 # remove extensions
* Wed 04 Sep 2013 07:13:42 AM JST

* Wed 04 Sep 2013 07:13:43 AM JST

* Wed 04 Sep 2013 07:13:43 AM JST
    #

* Wed 04 Sep 2013 07:13:44 AM JST

* Wed 04 Sep 2013 07:13:44 AM JST

* Wed 04 Sep 2013 07:13:44 AM JST
    #

* Wed 04 Sep 2013 07:13:45 AM JST

* Wed 04 Sep 2013 07:13:45 AM JST

* Wed 04 Sep 2013 07:13:45 AM JST
    #

* Wed 04 Sep 2013 07:16:30 AM JST
'{0} "mailto:{1}?subject={2}&body={3}"'
* Wed 04 Sep 2013 07:20:07 AM JST
EVO_FMT
* Wed 04 Sep 2013 07:20:13 AM JST
bin_, 
* Wed 04 Sep 2013 07:20:21 AM JST
format('', 
* Wed 04 Sep 2013 07:20:29 AM JST

* Wed 04 Sep 2013 07:20:29 AM JST

* Wed 04 Sep 2013 07:20:29 AM JST
            bin_ = CMD.get('evolution')

* Wed 04 Sep 2013 07:20:52 AM JST

* Wed 04 Sep 2013 07:20:52 AM JST

* Wed 04 Sep 2013 07:20:52 AM JST
            EVO_FMT = '{0} "mailto:{1}?subject={2}&body={3}"'

* Wed 04 Sep 2013 07:21:26 AM JST
cc,
* Wed 04 Sep 2013 07:23:22 AM JST
cc, 
* Wed 04 Sep 2013 07:27:55 AM JST
&attach={3}
* Wed 04 Sep 2013 07:29:04 AM JST
attach
* Wed 04 Sep 2013 07:29:08 AM JST

* Wed 04 Sep 2013 07:29:08 AM JST

* Wed 04 Sep 2013 07:29:08 AM JST
            attach = '""'

* Wed 04 Sep 2013 11:02:45 AM JST

* Wed 04 Sep 2013 11:02:45 AM JST

* Wed 04 Sep 2013 11:02:45 AM JST
echo $@

* Wed 04 Sep 2013 11:26:45 AM JST
/usr/local/bin/
* Wed 04 Sep 2013 11:27:24 AM JST
/usr/local/bin/
* Wed 04 Sep 2013 11:27:49 AM JST
/usr/local/bin/
* Wed 04 Sep 2013 11:28:25 AM JST
/usr/local/bin/
* Wed 04 Sep 2013 11:29:02 AM JST
/usr/local/bin/
* Wed 04 Sep 2013 11:29:21 AM JST

* Wed 04 Sep 2013 11:29:21 AM JST

* Wed 04 Sep 2013 11:29:21 AM JST
import 

* Wed 04 Sep 2013 11:31:08 AM JST

* Wed 04 Sep 2013 11:31:08 AM JST

* Wed 04 Sep 2013 11:31:08 AM JST
import 

* Wed 04 Sep 2013 11:32:55 AM JST
/usr/local/bin/
* Wed 04 Sep 2013 11:33:17 AM JST
/usr/local/bin/
* Wed 04 Sep 2013 11:33:44 AM JST
/usr/local/bin/
* Wed 04 Sep 2013 11:37:32 AM JST
s
* Wed 04 Sep 2013 11:37:32 AM JST
bin/s
* Wed 04 Sep 2013 11:37:33 AM JST
local/bin/s
* Wed 04 Sep 2013 11:37:34 AM JST
usr/local/bin/s
* Wed 04 Sep 2013 11:38:27 AM JST
/usr/local/bin/
* Wed 04 Sep 2013 11:38:46 AM JST
/usr/local/bin/
* Wed 04 Sep 2013 11:39:11 AM JST
/usr/local/bin/
* Wed 04 Sep 2013 11:52:53 AM JST
~/.zsh/scripts/
* Wed 04 Sep 2013 11:56:10 AM JST
~/.zsh/scripts/
* Wed 04 Sep 2013 12:00:05 PM JST
scripts/
* Wed 04 Sep 2013 12:00:06 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:00:06 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:00:11 PM JST
scripts/
* Wed 04 Sep 2013 12:00:11 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:00:11 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:00:16 PM JST
scripts/
* Wed 04 Sep 2013 12:00:17 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:00:17 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:00:20 PM JST
scripts/
* Wed 04 Sep 2013 12:00:20 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:00:20 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:01:11 PM JST
scripts/
* Wed 04 Sep 2013 12:01:11 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:01:11 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:01:38 PM JST
scripts/
* Wed 04 Sep 2013 12:01:38 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:01:38 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:02:15 PM JST
scripts/
* Wed 04 Sep 2013 12:02:15 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:02:15 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:02:18 PM JST
scripts/
* Wed 04 Sep 2013 12:02:18 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:02:18 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:06:32 PM JST
scripts/
* Wed 04 Sep 2013 12:06:32 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:06:32 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:09:18 PM JST
scripts/
* Wed 04 Sep 2013 12:09:18 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:09:19 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:09:31 PM JST
scripts/
* Wed 04 Sep 2013 12:09:31 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:09:31 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:10:39 PM JST
/root/.pylib/king.py
* Wed 04 Sep 2013 12:12:44 PM JST
scripts/
* Wed 04 Sep 2013 12:12:44 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:12:44 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:14:03 PM JST
scripts/
* Wed 04 Sep 2013 12:14:04 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:14:04 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:17:26 PM JST
scripts/
* Wed 04 Sep 2013 12:17:26 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:17:26 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:18:17 PM JST
scripts/
* Wed 04 Sep 2013 12:18:17 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:18:17 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:18:58 PM JST
scripts/
* Wed 04 Sep 2013 12:19:02 PM JST
scripts/
* Wed 04 Sep 2013 12:19:02 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:19:03 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:20:15 PM JST
scripts/
* Wed 04 Sep 2013 12:20:15 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:20:16 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:20:46 PM JST
scripts/
* Wed 04 Sep 2013 12:20:46 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:20:46 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:23:40 PM JST
scripts/
* Wed 04 Sep 2013 12:23:40 PM JST
zsh/scripts/
* Wed 04 Sep 2013 12:23:40 PM JST
root/.zsh/scripts/
* Wed 04 Sep 2013 12:32:07 PM JST
/media/portable/Internet/sleipnir/users/qua/setting/modules/headlinereader
* Wed 04 Sep 2013 12:34:54 PM JST
PORTABLE_HEADLINEREADER_PATH
* Wed 04 Sep 2013 12:37:34 PM JST
SLEIPNIR_EXE_NAME
* Wed 04 Sep 2013 12:43:18 PM JST
/opt/portable-sleipnir-299/PortableSleipnir/
* Wed 04 Sep 2013 12:45:07 PM JST
/settings/All Users/headlinereader
* Wed 04 Sep 2013 12:47:06 PM JST
return
* Wed 04 Sep 2013 12:57:36 PM JST
PORTABLE_HEADLINEREADER_PATH = ('/media/portable/Internet/sleipnir'
                                '/users/qua/setting/modules/headlinereader')
* Wed 04 Sep 2013 12:57:49 PM JST
os.path.basedir(PORTABLE_HEADLINEREADER_PATH)
* Wed 04 Sep 2013 12:58:00 PM JST
basedir(PORTABLE_HEADLINEREADER_PATH)
* Wed 04 Sep 2013 12:58:18 PM JST
os.path.basename(PORTABLE_HEADLINEREADER_PATH)
* Wed 04 Sep 2013 12:58:31 PM JST
base
* Wed 04 Sep 2013 12:58:37 PM JST
os.path.dirname(PORTABLE_HEADLINEREADER_PATH)
* Wed 04 Sep 2013 01:00:01 PM JST
headlinereader
* Wed 04 Sep 2013 01:00:09 PM JST
headlinereader
* Wed 04 Sep 2013 01:04:23 PM JST
dirname(
* Wed 04 Sep 2013 01:04:23 PM JST
path.dirname(
* Wed 04 Sep 2013 01:04:23 PM JST
os.path.dirname(
* Wed 04 Sep 2013 01:04:51 PM JST
run
* Wed 04 Sep 2013 01:04:52 PM JST
dry-run
* Wed 04 Sep 2013 01:04:52 PM JST
av --dry-run
* Wed 04 Sep 2013 01:05:18 PM JST

* Wed 04 Sep 2013 01:05:18 PM JST

* Wed 04 Sep 2013 01:05:18 PM JST
    # shutil.rmtree(PORTABLE_HEADLINEREADER_PATH)

* Wed 04 Sep 2013 01:13:53 PM JST
PORTABLE_HEADLINEREADER_PATH = ('/media/portable/Internet/sleipnir'
                                '/users/qua/setting/modules/')
LOCAL_HEADLINEREADER_PATH = ('/opt/portable-sleipnir-299/PortableSleipnir'
                                '/settings/"All Users"/headlinereader')


def sync_headlinereader():
    """SUMMARY

    @Return:
    """

    if not os.path.exists(PORTABLE_HEADLINEREADER_PATH):
        print('Does not exists {}'.format(PORTABLE_HEADLINEREADER_PATH))
        return
    if psexists(SLEIPNIR_EXE_NAME):
        print('{} exists'.format(SLEIPNIR_EXE_NAME))
        return
    cmd = CMD.get('rsync') + ' -av --delete --force {0} {1}'.format(
        LOCAL_HEADLINEREADER_PATH, PORTABLE_HEADLINEREADER_PATH)
    print(cmd)
    os.system(cmd)

* Wed 04 Sep 2013 01:19:54 PM JST
PORTABLE_HEADLINEREADER_PATH = ('/media/portable/Internet/sleipnir'
                                '/users/qua/setting/modules/')
LOCAL_HEADLINEREADER_PATH = ('/opt/portable-sleipnir-299/PortableSleipnir'
                                '/settings/"All Users"/headlinereader')

* Wed 04 Sep 2013 01:20:14 PM JST
SLEIPNIR_EXE_NAME = 'Sleipnir.exe'
* Wed 04 Sep 2013 01:20:16 PM JST
SLEIPNIR_EXE_NAME = 'Sleipnir.exe'
* Wed 04 Sep 2013 01:20:50 PM JST
PORTABLE_HEADLINEREADER_PATH
* Wed 04 Sep 2013 01:21:05 PM JST
LOCAL_HEADLINEREADER_PATH
* Wed 04 Sep 2013 01:21:09 PM JST
from ref import (CMD, SLEIPNIR_EXE_NAME, PORTABLE_HEADLINEREADER_PATH,
                 LOCAL_HEADLINEREADER_PATH)

* Wed 04 Sep 2013 01:21:23 PM JST

* Wed 04 Sep 2013 01:21:23 PM JST

* Wed 04 Sep 2013 01:21:23 PM JST
import shutil

* Wed 04 Sep 2013 01:22:46 PM JST
sikuliide="/usr/bin/sikuli-ide"
addrss_sikuli="/root/work/sikuli/addrss.skl"
opt="-r"

* Wed 04 Sep 2013 01:25:06 PM JST
/usr/bin/sikuli-ide
* Wed 04 Sep 2013 01:27:01 PM JST
target
* Wed 04 Sep 2013 01:29:59 PM JST
/root/work/sikuli/addrss.skl
* Wed 04 Sep 2013 01:42:42 PM JST

* Wed 04 Sep 2013 01:42:42 PM JST

* Wed 04 Sep 2013 01:42:42 PM JST
        sleep(10)

* Wed 04 Sep 2013 01:42:47 PM JST

* Wed 04 Sep 2013 01:42:48 PM JST

* Wed 04 Sep 2013 01:42:48 PM JST
from time import sleep

* Wed 04 Sep 2013 01:42:57 PM JST

* Wed 04 Sep 2013 01:42:57 PM JST

* Wed 04 Sep 2013 01:42:57 PM JST
from time import sleep

* Wed 04 Sep 2013 01:43:18 PM JST
'/root/work/sikuli/addrss.skl'
* Wed 04 Sep 2013 01:43:22 PM JST

* Wed 04 Sep 2013 01:43:22 PM JST

* Wed 04 Sep 2013 01:43:22 PM JST
    sleipnir_sikuli = 

* Wed 04 Sep 2013 01:46:24 PM JST
SLEIPNIR_EXE_NAME
* Wed 04 Sep 2013 01:49:13 PM JST
                 
* Wed 04 Sep 2013 01:49:18 PM JST
PORTABLE_HEADLINEREADER_PATH
* Wed 04 Sep 2013 01:49:47 PM JST
from ref import CMD, SLEIPNIR_EXE_NAME
from ref import PORTABLE_HEADLINEREADER_PATH, LOCAL_HEADLINEREADER_PATH

* Wed 04 Sep 2013 01:51:00 PM JST
CMD
* Wed 04 Sep 2013 01:51:02 PM JST
CMD
* Wed 04 Sep 2013 01:59:43 PM JST
/opt/portable-sleipnir-299/PortableSleipnir
* Wed 04 Sep 2013 02:02:11 PM JST
                            
* Wed 04 Sep 2013 02:03:51 PM JST
('/media/portable/Internet/sleipnir'
                                '/users/qua/setting/modules/')
* Wed 04 Sep 2013 02:04:26 PM JST
('/opt/portable-sleipnir-299/PortableSleipnir'
                                '/settings/"All Users"/headlinereader')
* Wed 04 Sep 2013 02:04:42 PM JST
                                
* Wed 04 Sep 2013 02:05:01 PM JST
        
* Wed 04 Sep 2013 02:05:13 PM JST
                                              
* Wed 04 Sep 2013 02:05:28 PM JST
                            
* Wed 04 Sep 2013 02:09:57 PM JST
EVOLUTION_FORMAT = CMD.get('evolution') + ' "mailto:{0}?cc={1}&subject={2}&body={3}"'
EVOLUTION_ATTACH_FORMAT = EVOLUTION_FORMAT + '&attach={4}'

* Wed 04 Sep 2013 02:10:54 PM JST
'/usr/bin/evolution'
* Wed 04 Sep 2013 02:12:14 PM JST
"mailto:{0}?cc={1}&subject={2}&body={3}"
* Wed 04 Sep 2013 02:14:39 PM JST

* Wed 04 Sep 2013 02:14:39 PM JST

* Wed 04 Sep 2013 02:14:39 PM JST
_evolution.setdefault('mailattachformat', _evolution)

* Wed 04 Sep 2013 02:14:41 PM JST

* Wed 04 Sep 2013 02:14:41 PM JST

* Wed 04 Sep 2013 02:14:41 PM JST
EVOLUTION_FORMAT = CMD.get('evolution') + ' "mailto:{0}?cc={1}&subject={2}&body={3}"'

* Wed 04 Sep 2013 02:15:45 PM JST
from ref import 
* Wed 04 Sep 2013 02:16:05 PM JST
from ref import 
* Wed 04 Sep 2013 03:02:46 PM JST
_sleipnir = {
    'name': 'sleipnir',
    'bin': 'Sleipnir.exe',
    'binpath': ('/opt/portable-sleipnir-299/PortableSleipnir/PortableSleipnir.exe'),
    'portable_headlinereader_path': ('/media/portable/Internet/sleipnir/users/'
                                     'qua/setting/modules/'),
    'local_headlinereader_path': ('/opt/portable-sleipnir-299/PortableSleipnir'
                                  '/settings/"All Users"/headlinereader')
             }

* Wed 04 Sep 2013 03:10:10 PM JST
_evolution = {
    'name': 'evolution',
    'bin': 'evolution',
    'binpath': '/usr/bin/evolution',
    'mailformat': '/usr/bin/evolution "mailto:{0}?cc={1}&subject={2}&body={3}"'
    }

* Wed 04 Sep 2013 03:12:44 PM JST
'bin': 'Sleipnir.exe'
* Wed 04 Sep 2013 03:12:54 PM JST

* Wed 04 Sep 2013 03:12:54 PM JST

* Wed 04 Sep 2013 03:12:54 PM JST
    'bin': 'Sleipnir.exe',

* Wed 04 Sep 2013 03:13:01 PM JST
'binpath': ('/opt/portable-sleipnir-299/PortableSleipnir/PortableSleipnir.exe'),
* Wed 04 Sep 2013 03:14:56 PM JST
d)
* Wed 04 Sep 2013 03:16:43 PM JST

* Wed 04 Sep 2013 03:16:43 PM JST

* Wed 04 Sep 2013 03:16:44 PM JST
    for VAR in COLLECTION:

* Wed 04 Sep 2013 03:17:05 PM JST
'Sleipnir.exe'
* Wed 04 Sep 2013 03:17:12 PM JST

* Wed 04 Sep 2013 03:17:12 PM JST

* Wed 04 Sep 2013 03:17:12 PM JST
    SLEIPNIR.set_default('bin', 'Sleipnir.exe')

* Wed 04 Sep 2013 03:17:19 PM JST
'binpath': ('/opt/portable-sleipnir-299/PortableSleipnir/PortableSleipnir.exe'),
* Wed 04 Sep 2013 03:17:53 PM JST
'portable_headlinereader_path': ('/media/portable/Internet/sleipnir/users/'
                                     'qua/setting/modules/'),
* Wed 04 Sep 2013 03:18:12 PM JST
    'local_headlinereader_path': ('/opt/portable-sleipnir-299/PortableSleipnir'
                                  '/settings/"All Users"/headlinereader'),

* Wed 04 Sep 2013 03:18:39 PM JST
    
* Wed 04 Sep 2013 03:18:40 PM JST
    
* Wed 04 Sep 2013 03:19:00 PM JST
        
* Wed 04 Sep 2013 03:20:21 PM JST
from ref.CMD.sleipnir import SLEIPNIR
* Wed 04 Sep 2013 03:24:24 PM JST
evolution 
* Wed 04 Sep 2013 03:26:47 PM JST
    
* Wed 04 Sep 2013 03:27:56 PM JST
ment
* Wed 04 Sep 2013 03:27:57 PM JST
attach ment
* Wed 04 Sep 2013 03:28:28 PM JST

* Wed 04 Sep 2013 03:28:28 PM JST

* Wed 04 Sep 2013 03:28:28 PM JST
# with attached

* Wed 04 Sep 2013 03:30:28 PM JST
CMD.get('evolution') + ' "mailto:{0}?cc={1}&subject={2}&body={3}"'
* Wed 04 Sep 2013 03:30:54 PM JST

* Wed 04 Sep 2013 03:30:55 PM JST

* Wed 04 Sep 2013 03:30:55 PM JST
EVOLUTION_ATTACH_FORMAT = EVOLUTION_FORMAT + '&attach={4}'

* Wed 04 Sep 2013 03:32:50 PM JST
SLEIPNIR_EXE_NAME
* Wed 04 Sep 2013 03:33:38 PM JST
PORTABLE_HEADLINEREADER_PATH
* Wed 04 Sep 2013 03:34:26 PM JST
LOCAL_HEADLINEREADER_PATH
* Wed 04 Sep 2013 03:34:45 PM JST
)
* Wed 04 Sep 2013 03:34:46 PM JST
                 )
* Wed 04 Sep 2013 03:40:07 PM JST
CMD = {
    'ln': '/bin/ln',
    'rm': '/bin/rm',
    'rmdir': '/bin/rmdir',
    'du': '/usr/bin/du',
    'rsync': '/usr/bin/rsync',
    'sshfs': '/usr/bin/sshfs',
    'umount': '/bin/umount',
    'runlevel': '/sbin/runlevel',
    'apt-get': '/usr/bin/apt-get',
    'evolution': '/usr/bin/evolution',
    'sikuli-ide': '/usr/bin/sikuli-ide',
    'google-chrome': '/usr/bin/google-chrome',
       }


* Wed 04 Sep 2013 03:40:44 PM JST
        
* Wed 04 Sep 2013 03:43:07 PM JST
    CMD = {'ln': '/bin/ln',
           'rm': '/bin/rm',
           'rmdir': '/bin/rmdir',
           'du': '/usr/bin/du',
           'rsync': '/usr/bin/rsync',
           'sshfs': '/usr/bin/sshfs',
           'umount': '/bin/umount',
           'runlevel': '/sbin/runlevel',
           'apt-get': '/usr/bin/apt-get',
           'evolution': '/usr/bin/evolution',
           'sikuli-ide': '/usr/bin/sikuli-ide',
           'google-chrome': '/usr/bin/google-chrome',
    }

* Wed 04 Sep 2013 03:45:42 PM JST
CMD = {'ln': '/bin/ln',
       'rm': '/bin/rm',
       'rmdir': '/bin/rmdir',
       'du': '/usr/bin/du',
       'rsync': '/usr/bin/rsync',
       'sshfs': '/usr/bin/sshfs',
       'umount': '/bin/umount',
       'runlevel': '/sbin/runlevel',
       'apt-get': '/usr/bin/apt-get',
       'evolution': '/usr/bin/evolution',
       'sikuli-ide': '/usr/bin/sikuli-ide',
       'google-chrome': '/usr/bin/google-chrome',
}


* Wed 04 Sep 2013 03:46:47 PM JST
if 'nt' == _os.name:
    from nt_ref import *

elif 'posix' == _os.name:
    from posix_ref import *

* Wed 04 Sep 2013 03:46:51 PM JST
import os as _os

if 'nt' == _os.name:
    from nt_ref import *

elif 'posix' == _os.name:
    from posix_ref import *


* Wed 04 Sep 2013 03:47:17 PM JST

* Wed 04 Sep 2013 03:47:17 PM JST

* Wed 04 Sep 2013 03:47:17 PM JST
import os as _os

* Wed 04 Sep 2013 03:53:41 PM JST
/usr/bin/sikuli-ide
* Wed 04 Sep 2013 03:54:15 PM JST
UserWarning
* Wed 04 Sep 2013 03:54:36 PM JST
bin
* Wed 04 Sep 2013 03:58:58 PM JST
listdirs
* Wed 04 Sep 2013 04:00:01 PM JST
SIKULI_EXES
* Wed 04 Sep 2013 04:05:13 PM JST

* Wed 04 Sep 2013 04:05:13 PM JST

* Wed 04 Sep 2013 04:05:13 PM JST
    'exeformat': ''

* Wed 04 Sep 2013 04:06:49 PM JST
SIKULI.get('binpath')
* Wed 04 Sep 2013 04:11:23 PM JST
'/root/.zsh/scripts/sleipnir'
* Wed 04 Sep 2013 04:13:22 PM JST
SLEIPNIR, 
* Wed 04 Sep 2013 04:23:43 PM JST
path
* Wed 04 Sep 2013 04:24:29 PM JST
def sikulirun(path):
    """SUMMARY

    @Arguments:
    - `target`:

    @Return:
    """
    os.system(SIKULI.get('exeformat').format(path))


* Wed 04 Sep 2013 04:24:56 PM JST
SIKULI
* Wed 04 Sep 2013 04:28:47 PM JST
/root/work/sikuli/
* Wed 04 Sep 2013 04:57:00 PM JST

* Wed 04 Sep 2013 04:57:00 PM JST

* Wed 04 Sep 2013 04:57:00 PM JST
       'evolution': '/usr/bin/evolution',

* Wed 04 Sep 2013 04:57:40 PM JST

* Wed 04 Sep 2013 04:57:40 PM JST

* Wed 04 Sep 2013 04:57:40 PM JST
       'sikuli-ide': '/usr/bin/sikuli-ide',

* Wed 04 Sep 2013 05:01:33 PM JST
SLEIPNIR.get('portable_headlinereader_path')
* Wed 04 Sep 2013 05:03:09 PM JST
SLEIPNIR.get('binname')
* Wed 04 Sep 2013 05:03:50 PM JST
SLEIPNIR.get('local_headlinereader_path')
* Wed 04 Sep 2013 05:04:44 PM JST
SLEIPNIR.get('binname')
* Wed 04 Sep 2013 05:05:49 PM JST

* Wed 04 Sep 2013 05:05:49 PM JST

* Wed 04 Sep 2013 05:05:49 PM JST
SLEIPNIR_EXE_NAME = SLEIPNIR.get('binname')

* Wed 04 Sep 2013 05:05:59 PM JST

* Wed 04 Sep 2013 05:06:00 PM JST

* Wed 04 Sep 2013 05:06:00 PM JST
PORTABLE_HEADLINEREADER_PATH = SLEIPNIR.get('portable_headlinereader_path')

* Wed 04 Sep 2013 05:06:09 PM JST

* Wed 04 Sep 2013 05:06:09 PM JST

* Wed 04 Sep 2013 05:06:09 PM JST
LOCAL_HEADLINEREADER_PATH = SLEIPNIR.get('local_headlinereader_path')

* Wed 04 Sep 2013 05:06:25 PM JST
EVOLUTION.get('fmailformat')
* Wed 04 Sep 2013 05:06:37 PM JST

* Wed 04 Sep 2013 05:06:37 PM JST

* Wed 04 Sep 2013 05:06:37 PM JST
EVOLUTION_FORMAT = EVOLUTION.get('fmailformat')

* Wed 04 Sep 2013 05:08:39 PM JST

* Wed 04 Sep 2013 05:08:39 PM JST

* Wed 04 Sep 2013 05:08:39 PM JST
## {'name without exetention': 'skl full path'}

* Wed 04 Sep 2013 05:12:00 PM JST
taka16gmail = 'taka16a23@gmail.com'
* Wed 04 Sep 2013 05:12:34 PM JST
takahiroatsumigmail = 'takahiroatsumi0517@gmail.com'
* Wed 04 Sep 2013 05:13:03 PM JST
taka16dailymail
* Wed 04 Sep 2013 05:13:17 PM JST
'taka16daily@gmail.com'
* Wed 04 Sep 2013 05:13:40 PM JST
MAILADDR
* Wed 04 Sep 2013 05:14:09 PM JST

* Wed 04 Sep 2013 05:14:09 PM JST

* Wed 04 Sep 2013 05:14:09 PM JST
GMAIL = 

* Wed 04 Sep 2013 05:14:55 PM JST
taka16dailymail
* Wed 04 Sep 2013 05:15:14 PM JST
cpu_percent
* Wed 04 Sep 2013 05:15:49 PM JST

* Wed 04 Sep 2013 05:15:49 PM JST

* Wed 04 Sep 2013 05:15:49 PM JST
taka16gmail = 'taka16a23@gmail.com'

* Wed 04 Sep 2013 05:15:49 PM JST
taka16gmail = 'taka16a23@gmail.com'

* Wed 04 Sep 2013 05:15:49 PM JST
taka16gmail = 'taka16a23@gmail.com'
takahiroatsumigmail = 'takahiroatsumi0517@gmail.com'

* Wed 04 Sep 2013 05:15:49 PM JST
taka16gmail = 'taka16a23@gmail.com'
takahiroatsumigmail = 'takahiroatsumi0517@gmail.com'

* Wed 04 Sep 2013 05:15:50 PM JST
taka16gmail = 'taka16a23@gmail.com'
takahiroatsumigmail = 'takahiroatsumi0517@gmail.com'
taka16dailymail = 'taka16daily@gmail.com'

* Wed 04 Sep 2013 05:18:20 PM JST
def sync_headlinereader():
    """SUMMARY

    @Return:
    """

    if not os.path.exists(PORTABLE_HEADLINEREADER_PATH):
        print('Does not exists {}'.format(PORTABLE_HEADLINEREADER_PATH))
        return
    if psexists(SLEIPNIR_EXE_NAME):
        print('{} exists'.format(SLEIPNIR_EXE_NAME))
        return
    cmd = CMD.get('rsync') + ' -av --delete --force {0} {1}'.format(
        LOCAL_HEADLINEREADER_PATH, PORTABLE_HEADLINEREADER_PATH)
    print(cmd)
    os.system(cmd)

* Wed 04 Sep 2013 05:19:25 PM JST
def sync_headlinereader():
    """SUMMARY

    @Return:
    """

    if not os.path.exists(SLEIPNIR.get('portable_headlinereader_path')):
        print('Does not exists {}'.format(
            SLEIPNIR.get('portable_headlinereader_path')))
        return
    if psexists(SLEIPNIR.get('binname')):
        print('{} exists'.format(SLEIPNIR.get('binname')))
        return
    cmd = CMD.get('rsync') + ' -av --delete --force {0} {1}'.format(
        SLEIPNIR.get('local_headlinereader_path'),
        SLEIPNIR.get('portable_headlinereader_path'))
    print(cmd)
    os.system(cmd)

* Wed 04 Sep 2013 05:20:25 PM JST

* Wed 04 Sep 2013 05:20:25 PM JST

* Wed 04 Sep 2013 05:20:25 PM JST
import os as _os

* Wed 04 Sep 2013 05:22:03 PM JST
import
* Wed 04 Sep 2013 05:23:40 PM JST
push_sync_headlinereader
* Wed 04 Sep 2013 05:25:28 PM JST
from
* Wed 04 Sep 2013 05:25:55 PM JST
import os
* Wed 04 Sep 2013 05:41:41 PM JST
FreeRapidDownloader
* Wed 04 Sep 2013 05:42:28 PM JST
'/media/portable/system/FRDPortable/App/FreeRapidDownloader/proxy.txt'
* Wed 04 Sep 2013 05:43:24 PM JST
/media/portable/system/FRDPortable/App/FreeRapidDownloader/frd.jar
* Wed 04 Sep 2013 05:44:01 PM JST
                    
* Wed 04 Sep 2013 05:44:25 PM JST
frd.jar
* Wed 04 Sep 2013 05:46:32 PM JST
                    
* Wed 04 Sep 2013 05:46:36 PM JST
                    
* Wed 04 Sep 2013 05:47:22 PM JST
          
* Wed 04 Sep 2013 05:58:41 PM JST
'http://www.cybersyndrome.net/plr5.html'
* Wed 04 Sep 2013 05:58:48 PM JST
'http://www.cybersyndrome.net/pla5.html'
* Wed 04 Sep 2013 05:59:28 PM JST
proxylist.URL.get('speed')
* Wed 04 Sep 2013 05:59:32 PM JST
speed
* Wed 04 Sep 2013 05:59:49 PM JST

* Wed 04 Sep 2013 05:59:49 PM JST

* Wed 04 Sep 2013 05:59:49 PM JST
url_speed = 'http://www.cybersyndrome.net/plr5.html'

* Wed 04 Sep 2013 05:59:49 PM JST
url_speed = 'http://www.cybersyndrome.net/plr5.html'

* Wed 04 Sep 2013 05:59:49 PM JST
url_speed = 'http://www.cybersyndrome.net/plr5.html'
url_anonymous = 'http://www.cybersyndrome.net/pla5.html'

* Wed 04 Sep 2013 06:01:22 PM JST
lis.append(
* Wed 04 Sep 2013 06:01:34 PM JST

* Wed 04 Sep 2013 06:01:34 PM JST

* Wed 04 Sep 2013 06:01:34 PM JST
    return lis

* Wed 04 Sep 2013 06:01:36 PM JST

* Wed 04 Sep 2013 06:01:36 PM JST

* Wed 04 Sep 2013 06:01:36 PM JST
    lis = []

* Wed 04 Sep 2013 06:01:55 PM JST
Get 
* Wed 04 Sep 2013 06:05:01 PM JST
speed = proxylist.trim_proxy_from_html(proxylist.URL.get('speed'))
* Wed 04 Sep 2013 06:05:05 PM JST
anonymous = proxylist.trim_proxy_from_html(proxylist.URL.get('anonymous'))
* Wed 04 Sep 2013 06:07:46 PM JST
pass
* Wed 04 Sep 2013 06:07:51 PM JST
if not os.path.exists('/media/portable/system'):
    easygui.msgbox('Not mounted', title='Error')
    sys.exit(1)

speed = proxylist.trim_proxy_from_html(proxylist.URL.get('speed'))
anonymous = proxylist.trim_proxy_from_html(proxylist.URL.get('anonymous'))

with open(FRD.get('proxy_path'), 'w') as f:
    f.write('\n'.join(itertools.chain(speed, anonymous)))

try:
    os.system('java -jar'
              ' /media/portable/system/FRDPortable/App/FreeRapidDownloader/frd.jar'
              ' > /dev/null 2>&1 &')
except:
    easygui.msgbox('Fatal Error', title='Error')
    sys.exit(1)

* Wed 04 Sep 2013 06:08:38 PM JST
                  
* Wed 04 Sep 2013 06:08:43 PM JST
                  
* Wed 04 Sep 2013 06:10:16 PM JST
url_anonymous
* Wed 04 Sep 2013 06:10:20 PM JST
url_anonymous
* Wed 04 Sep 2013 06:12:33 PM JST
trim_proxy_from_html
* Wed 04 Sep 2013 06:18:36 PM JST
#!/usr/bin/env python
# -*- coding: utf-8 -*-
""" myinfo -- My personal infomations.

$Revision$


"""


import os as _os

__all__ = []

home_domain = 'taka16.no-ip.info'

king = {'host': 'localhost',
        'user': 't1',
        'ip' : '192.168.1.123',
        'port': 12316,
        'mac': '00:01:80:61:d8:47',
        'crypted_disk': '/dev/mapper/VG-data',
        'decrypted_disk_name': 'data_crypt'}

rook = {'host': home_domain,
        'user': 'root',
        'port': 12316,
        'mac': '00:1D:73:1A:C0:9C',
        'open_port': [12317, 12318, 12319],
        'close_port': [12313, 12314, 12315]
        }

GMAIL = {'taka16': 'taka16a23@gmail.com',
         'takahiroatsumi': 'takahiroatsumi0517@gmail.com',
         'taka16daily': 'taka16daily@gmail.com',
        }


if 'nt' == _os.name:
    from portable import P_SECURITY
    MYTEMP = 'D:\\MYTEMP'
    kagi = _os.path.join(P_SECURITY, 'Password\\kagi\\kagi.ppk')

elif 'posix' == _os.name:
    kagi = _os.path.expanduser('~/.ssh/kagi')
    kagiMD5 = '\xc8\xa6k\xe5\xd9\xef\xa1.[\xd8Y\xc7\xd3\x95[\xd2'



# For Emacs
# Local Variables:
# coding: utf-8
# End:
# myinfo.py ends here

* Wed 04 Sep 2013 06:22:00 PM JST

* Wed 04 Sep 2013 06:22:00 PM JST

* Wed 04 Sep 2013 06:22:00 PM JST
                    nargs=None,

* Wed 04 Sep 2013 06:22:38 PM JST
21
* Wed 04 Sep 2013 06:25:17 PM JST
    parser = argparse.ArgumentParser(description="""Simple FTP Server""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,
                        help='Version Strings.')

    parser.add_argument('-u', '--user',
                        dest='user',
                        action='store',
                        const=None,
                        default='user',
                        type=str,
                        choices=None,
                        required=False,
                        help='Set user name.')

    parser.add_argument('-p', '--passwd', '--password',
                        dest='password',
                        action='store',
                        const=None,
                        default='pass',
                        type=str,
                        choices=None,
                        required=False,
                        # (yas/expand-link "argparse_other_options" t)
                        help='Set password.')

    parser.add_argument('--port',
                        dest='port',
                        action='store',
                        const=None,
                        default=21,
                        type=int,
                        choices=None,
                        required=False,
                        # (yas/expand-link "argparse_other_options" t)
                        help='Set port num default as 21.')
    # (yas/expand-link "argparse_add_argument" t)

* Wed 04 Sep 2013 06:30:42 PM JST

* Wed 04 Sep 2013 06:30:42 PM JST

* Wed 04 Sep 2013 06:30:43 PM JST
    # print('#######################################')

* Wed 04 Sep 2013 06:30:45 PM JST
    print('{0:#^40}'.format(''))
* Wed 04 Sep 2013 06:31:24 PM JST

* Wed 04 Sep 2013 06:31:24 PM JST

* Wed 04 Sep 2013 06:31:24 PM JST
    # print('')

* Wed 04 Sep 2013 06:35:34 PM JST
maker
* Wed 04 Sep 2013 06:35:34 PM JST
options_maker
* Wed 04 Sep 2013 06:36:20 PM JST
    parser = argparse.ArgumentParser(description="""${1: }""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,
                        help='Version Strings.')
    # (yas/expand-link "argparse_add_argument" t)
    return parser

* Wed 04 Sep 2013 06:36:23 PM JST

* Wed 04 Sep 2013 06:36:23 PM JST

* Wed 04 Sep 2013 06:36:23 PM JST
def _parse_args():

* Wed 04 Sep 2013 06:36:29 PM JST
parse
* Wed 04 Sep 2013 06:36:32 PM JST
args
* Wed 04 Sep 2013 06:37:07 PM JST
args
* Wed 04 Sep 2013 06:37:08 PM JST
parse_args
* Wed 04 Sep 2013 08:46:57 PM JST
import
* Wed 04 Sep 2013 08:51:03 PM JST
listdir
* Wed 04 Sep 2013 08:51:38 PM JST
d)
* Wed 04 Sep 2013 08:51:39 PM JST
realpath(d)
* Wed 04 Sep 2013 08:51:39 PM JST
path.realpath(d)
* Wed 04 Sep 2013 08:51:39 PM JST
_os.path.realpath(d)
* Wed 04 Sep 2013 08:52:07 PM JST
                            
* Wed 04 Sep 2013 08:53:11 PM JST
abspath
* Wed 04 Sep 2013 08:53:11 PM JST
path.abspath
* Wed 04 Sep 2013 10:17:22 PM JST
http://www.lifehacker.jp/2013/09/130904love_letter.html
* Thu 05 Sep 2013 01:07:13 AM JST
https://shop.nanairo.coop/front/bb/shiga/top/top
* Thu 05 Sep 2013 01:09:30 AM JST
datetime.now().weekday()
* Thu 05 Sep 2013 01:15:54 AM JST
# define log file name
log_name = 'backup_ki.log'
log_base_dir = '/var/log'
log_path = os.path.join(log_base_dir, log_name)
logging.basicConfig(filename=log_path,
                    level=logging.DEBUG,
                    format='%(asctime)s %(message)s')

* Thu 05 Sep 2013 01:18:44 AM JST

* Thu 05 Sep 2013 01:18:44 AM JST

* Thu 05 Sep 2013 01:18:44 AM JST
# main

* Thu 05 Sep 2013 01:18:45 AM JST

* Thu 05 Sep 2013 01:18:45 AM JST

* Thu 05 Sep 2013 01:18:45 AM JST
#

* Thu 05 Sep 2013 01:19:36 AM JST
# expand-env: ((yas/indent-line 'fixed) (yas/wrap-around-region 'nil))
* Thu 05 Sep 2013 01:19:43 AM JST
# 
* Thu 05 Sep 2013 01:21:28 AM JST

* Thu 05 Sep 2013 01:21:28 AM JST

* Thu 05 Sep 2013 01:21:28 AM JST
# binding: "keybinding"

* Thu 05 Sep 2013 01:21:40 AM JST

* Thu 05 Sep 2013 01:21:40 AM JST

* Thu 05 Sep 2013 01:21:40 AM JST
# expand-env: ((some-var some-value))

* Thu 05 Sep 2013 01:21:49 AM JST
# define log file name
log_name = 'backup_ki.log'
log_base_dir = '/var/log'
log_path = os.path.join(log_base_dir, log_name)
logging.basicConfig(filename=log_path,
                    level=logging.DEBUG,
                    format='%(asctime)s %(message)s')

* Thu 05 Sep 2013 01:23:44 AM JST
${1:$$(yas/choose-value '("string" "int" "long" "choice" "float" "complex"))}
* Thu 05 Sep 2013 01:24:14 AM JST
string
* Thu 05 Sep 2013 01:25:00 AM JST
base_
* Thu 05 Sep 2013 01:25:07 AM JST
base_
* Thu 05 Sep 2013 01:25:41 AM JST
                    
* Thu 05 Sep 2013 01:25:43 AM JST
                    
* Thu 05 Sep 2013 01:34:43 AM JST
((save-excursion
         (goto-char (point-min))
         (re-search-forward "import[ \t]+os[ \t]+as[ \t]+_os" nil 'noerror))
       (insert "_os"))
* Thu 05 Sep 2013 01:35:29 AM JST
(cond ((save-excursion
         (goto-char (point-min))
         (re-search-forward "import[ \t]+os[ \t]+as[ \t]+_os" nil 'noerror))
       (insert "_os"))
      ((save-excursion
         (goto-char (point-min))
         (re-search-forward "import[ \t]+os" nil 'noerror)) (insert "os"))
      (t (py--insert-imports "os" "import os")))
* Thu 05 Sep 2013 01:36:05 AM JST
(cond ((save-excursion
         (goto-char (point-min))
         (re-search-forward "import[ \t]+os[ \t]+as[ \t]+_os" nil 'noerror))
       (insert "_os"))
      ((save-excursion
         (goto-char (point-min))
         (re-search-forward "import[ \t]+os" nil 'noerror)) (insert "os"))
      (t (py--insert-imports "os" "import os")))
* Thu 05 Sep 2013 01:37:10 AM JST
(py--insert-imports "os" "import os")
* Thu 05 Sep 2013 01:40:40 AM JST

* Thu 05 Sep 2013 01:40:40 AM JST

* Thu 05 Sep 2013 01:40:40 AM JST
# binding: "keybinding"

* Thu 05 Sep 2013 01:40:41 AM JST
# binding: "keybinding"

* Thu 05 Sep 2013 01:40:41 AM JST
# binding: "keybinding"
# expand-env: ((some-var some-value))

* Thu 05 Sep 2013 01:43:02 AM JST
    
* Thu 05 Sep 2013 01:43:40 AM JST
format
* Thu 05 Sep 2013 01:43:50 AM JST

* Thu 05 Sep 2013 01:43:50 AM JST

* Thu 05 Sep 2013 01:43:51 AM JST
    logging.log(10, 'We will try rss.')

* Thu 05 Sep 2013 01:44:39 AM JST
diary
* Thu 05 Sep 2013 01:44:47 AM JST
webpag
* Thu 05 Sep 2013 01:45:14 AM JST

* Thu 05 Sep 2013 01:45:14 AM JST

* Thu 05 Sep 2013 01:45:14 AM JST
    logging.log(10, 'We will try create recipe')

* Thu 05 Sep 2013 06:27:11 AM JST
datetime.now().weekday()
* Thu 05 Sep 2013 06:29:52 AM JST
os.path.expanduser('~/work/recipe')
* Thu 05 Sep 2013 06:30:13 AM JST
from  import 
* Thu 05 Sep 2013 06:31:53 AM JST

* Thu 05 Sep 2013 06:31:53 AM JST

* Thu 05 Sep 2013 06:31:53 AM JST
PATH.get('recipedir') = os.path.expanduser('~/work/recipe')

* Thu 05 Sep 2013 06:31:55 AM JST

* Thu 05 Sep 2013 06:31:56 AM JST

* Thu 05 Sep 2013 06:31:56 AM JST
PATH.get('recipedir') = os.path.expanduser('~/work/recipe')

* Thu 05 Sep 2013 06:32:46 AM JST

* Thu 05 Sep 2013 06:32:46 AM JST

* Thu 05 Sep 2013 06:32:48 AM JST

* Thu 05 Sep 2013 06:32:50 AM JST

* Thu 05 Sep 2013 06:32:50 AM JST

* Thu 05 Sep 2013 06:32:50 AM JST
os.path.dirname()

* Thu 05 Sep 2013 06:41:24 AM JST

* Thu 05 Sep 2013 06:41:24 AM JST

* Thu 05 Sep 2013 06:41:25 AM JST
    PATH.get('recipedir') = PATH.get('recipedir')

* Thu 05 Sep 2013 06:41:26 AM JST

* Thu 05 Sep 2013 06:41:26 AM JST

* Thu 05 Sep 2013 06:41:27 AM JST
    PATH.get('recipedir') = PATH.get('recipedir')

* Thu 05 Sep 2013 07:10:35 AM JST
    
* Thu 05 Sep 2013 07:13:58 AM JST
setdefault(
* Thu 05 Sep 2013 07:14:04 AM JST
'mailto'
* Thu 05 Sep 2013 07:14:12 AM JST
GMAIL.get('taka16daily')
* Thu 05 Sep 2013 07:14:14 AM JST

* Thu 05 Sep 2013 07:14:14 AM JST

* Thu 05 Sep 2013 07:14:14 AM JST
            mailto = 

* Thu 05 Sep 2013 07:14:16 AM JST
            mailto = 

* Thu 05 Sep 2013 07:14:16 AM JST
            mailto = 
            cc = ''

* Thu 05 Sep 2013 07:14:30 AM JST
= 'Daily Routines'
* Thu 05 Sep 2013 07:14:42 AM JST

* Thu 05 Sep 2013 07:14:42 AM JST

* Thu 05 Sep 2013 07:14:42 AM JST
            subject = 'Daily Routines'

* Thu 05 Sep 2013 07:14:56 AM JST
= 'WEATHER: \nRECIPE: ' + ', '.join(menus) + '\n'
* Thu 05 Sep 2013 07:15:02 AM JST

* Thu 05 Sep 2013 07:15:02 AM JST

* Thu 05 Sep 2013 07:15:02 AM JST
            body = 'WEATHER: \nRECIPE: ' + ', '.join(menus) + '\n'

* Thu 05 Sep 2013 07:15:05 AM JST
.format(mailto, cc, subject, body)
* Thu 05 Sep 2013 07:15:54 AM JST
3}
* Thu 05 Sep 2013 08:03:48 AM JST
in
* Thu 05 Sep 2013 08:09:27 AM JST

* Thu 05 Sep 2013 08:09:27 AM JST

* Thu 05 Sep 2013 08:09:27 AM JST
        a = self.a

* Thu 05 Sep 2013 08:15:57 AM JST

* Thu 05 Sep 2013 08:15:57 AM JST

* Thu 05 Sep 2013 08:15:57 AM JST
        self.a = 0

* Thu 05 Sep 2013 08:20:19 AM JST

* Thu 05 Sep 2013 08:20:19 AM JST

* Thu 05 Sep 2013 08:20:19 AM JST
# expand-env: ((some-var some-value))

* Thu 05 Sep 2013 08:20:32 AM JST
# expand-env: ((yas/indent-line 'fixed) (yas/wrap-around-region 'nil))
* Thu 05 Sep 2013 08:21:03 AM JST
class ${1:ClassName}(${2:object}):
    """$3
    """

    def __init__(self, $4):
        """$5
        ${4:$
        (let* ((indent
                (concat "\n" (make-string (current-column) 32)))
               (args
                (mapconcat
                 '(lambda (x)
                    (if (not (string= (nth 0 x) ""))
                        (concat "- " (char-to-string 96) (nth 0 x)
                                (char-to-string 96) ":")))
                 (mapcar
                  '(lambda (x)
                     (mapcar
                      (lambda (x)
                        (replace-regexp-in-string "[[:blank:]]*$" ""
                         (replace-regexp-in-string "^[[:blank:]]*" "" x))) x))
                  (mapcar '(lambda (x) (split-string x "="))
                          (split-string text ",")))
                 indent)))
          (if (string= args "")
              (make-string 3 34)
            (mapconcat
             'identity
             (list "" "Arguments:" args (make-string 3 34))
             indent)))
        }
        ${4:$
        (mapconcat
         '(lambda (x)
            (if (not (string= (nth 0 x) ""))
                (concat "self._" (nth 0 x) " = " (nth 0 x))))
         (mapcar
          '(lambda (x)
             (mapcar
              '(lambda (x)
                 (replace-regexp-in-string "[[:blank:]]*$" ""
                  (replace-regexp-in-string "^[[:blank:]]*" "" x)))
              x))
          (mapcar '(lambda (x) (split-string x "="))
                  (split-string text ",")))
         (concat "\n" (make-string (current-column) 32)))
        }
        $0

* Thu 05 Sep 2013 08:22:59 AM JST
class ChromeBMParse(object):
    """
    """

    def __init__(self, bm_path=BOOKMARK_PATH):
        """

        Arguments:
        - `bkmk_path`:
        """
        self._bm_path = bm_path
        self._file = open(self._bm_path, 'r')
        self._lines = self._file.readlines()
        self.line_num = 0
        self.urls = []

    def get_urls(self, name):
        """Get list urls in folder.

        @Arguments:

        - `name`: folders name

        @Return: list of urls.
        """
        self._line_num_by_name(name)
        self._mv_init_line()
        self._parse_urls()
        self._trim_urls()
        return self.urls

    def clear(self):
        """SUMMARY

        @Return:
        """
        self.urls = []

    def _line_num_by_name(self, name):
        """Determine line number of name.

        @Arguments:

        - `name`: elements name

        @Return: line number
        """
        self._file.seek(0)
        # for num, line in enumerate(self._file, 1):
        for num, line in enumerate(self._file):
            if '"name":' in line:
                trimed = line.split('"name":')[1].split('"')[1]
                if name == trimed.decode('unicode-escape', 'ignore'):
                    self.line_num = num - 1

    def _mv_init_line(self):
        """Move initialize line.

        @Return: Nothing
        """
        while -1 == self._lines[self.line_num].find(']') and self.line_num != 0:
            self.line_num -= 1

    def _parse_urls(self):
        """Parse urls"""
        operand = -1
        while operand < 0:
            self.line_num -= 1
            if self._lines[self.line_num].find('}') != -1:
                operand -= 1
            if self._lines[self.line_num].find('{') != -1:
                operand += 1
            if operand == -1:
                if self._lines[self.line_num].find('"url":') != -1:
                    self.urls.append(self._lines[self.line_num])

    def _trim_urls(self):
        """Triming urls by regexp."""
        self.urls = trim_urls(self.urls)

    def __del__(self):
        """Close opened file when deconstract."""
        self._file.close()

* Thu 05 Sep 2013 08:28:57 AM JST
name
* Thu 05 Sep 2013 08:29:11 AM JST

* Thu 05 Sep 2013 08:29:11 AM JST

* Thu 05 Sep 2013 08:29:11 AM JST
        self.line_num = 0

* Thu 05 Sep 2013 08:29:22 AM JST
    def _getline_num(self):
        """Determine line number of name.

        @Arguments:

        - `name`: elements name

        @Return: line number
        """
        self._file.seek(0)
        # for num, line in enumerate(self._file, 1):
        for num, line in enumerate(self._file):
            if '"name":' in line:
                trimed = line.split('"name":')[1].split('"')[1]
                if self._name == trimed.decode('unicode-escape', 'ignore'):
                    self.line_num = num - 1


* Thu 05 Sep 2013 08:30:21 AM JST
    def _mv_init_line(self):
        """Move initialize line.

        @Return: Nothing
        """
        while -1 == self._lines[self.line_num].find(']') and self.line_num != 0:
            self.line_num -= 1

* Thu 05 Sep 2013 08:30:52 AM JST
_mv_init
* Thu 05 Sep 2013 08:33:37 AM JST
_parse_urls
* Thu 05 Sep 2013 08:33:46 AM JST
self.urls.append(
* Thu 05 Sep 2013 08:34:04 AM JST

* Thu 05 Sep 2013 08:34:04 AM JST

* Thu 05 Sep 2013 08:34:04 AM JST
        self.urls = []

* Thu 05 Sep 2013 08:34:30 AM JST
def trim_urls(urls):
    """Triming urls by regexp.

    @Arguments:
    - `urls`: list of urls

    @Return: list of trimed urls
    """
    pattern = "(http|https)://[A-Za-z0-9.?.$,;:&=!*~@_()\\-\\#%+/]+"
    re_url = _re.compile(pattern)
    new = []
    for url in urls:
        result = re_url.search(url)
        if not result is None:
            new.append(result.group())
    return new

* Thu 05 Sep 2013 08:34:48 AM JST

* Thu 05 Sep 2013 08:34:48 AM JST

* Thu 05 Sep 2013 08:34:48 AM JST
    new = []

* Thu 05 Sep 2013 08:34:49 AM JST
    new = []

* Thu 05 Sep 2013 08:34:49 AM JST
    new = []
    for url in urls:

* Thu 05 Sep 2013 08:35:01 AM JST
new.append(
* Thu 05 Sep 2013 08:36:07 AM JST
new
* Thu 05 Sep 2013 08:38:30 AM JST
line = 
* Thu 05 Sep 2013 08:39:19 AM JST
resul
* Thu 05 Sep 2013 08:39:19 AM JST
return resul
* Thu 05 Sep 2013 08:44:16 AM JST

* Thu 05 Sep 2013 08:44:16 AM JST

* Thu 05 Sep 2013 08:44:16 AM JST
        # for num, line in enumerate(self._file, 1):

* Thu 05 Sep 2013 06:11:13 PM JST
_re.compile(pattern)
* Thu 05 Sep 2013 06:11:17 PM JST

* Thu 05 Sep 2013 06:11:17 PM JST

* Thu 05 Sep 2013 06:11:17 PM JST
    re_url = 

* Thu 05 Sep 2013 06:11:23 PM JST
_re.compile(pattern).search(url)
* Thu 05 Sep 2013 06:13:18 PM JST
"(http|https)://[A-Za-z0-9.?.$,;:&=!*~@_()\\-\\#%+/]+"
* Thu 05 Sep 2013 06:14:15 PM JST
pattern
* Thu 05 Sep 2013 06:14:25 PM JST

* Thu 05 Sep 2013 06:14:25 PM JST

* Thu 05 Sep 2013 06:14:25 PM JST
    pattern = "(http|https)://[A-Za-z0-9.?.$,;:&=!*~@_()\\-\\#%+/]+"

* Thu 05 Sep 2013 06:22:03 PM JST
No
* Thu 05 Sep 2013 06:22:08 PM JST
object
* Thu 05 Sep 2013 06:22:13 PM JST

* Thu 05 Sep 2013 06:22:13 PM JST

* Thu 05 Sep 2013 06:22:13 PM JST
    """

* Thu 05 Sep 2013 06:22:13 PM JST
    """

* Thu 05 Sep 2013 06:22:14 PM JST
    """
    """

* Thu 05 Sep 2013 06:22:14 PM JST

* Thu 05 Sep 2013 06:22:14 PM JST

* Thu 05 Sep 2013 06:22:14 PM JST
    def __init__(self, ):

* Thu 05 Sep 2013 06:22:14 PM JST
    def __init__(self, ):

* Thu 05 Sep 2013 06:22:14 PM JST
    def __init__(self, ):
        """

* Thu 05 Sep 2013 06:22:14 PM JST
    def __init__(self, ):
        """

* Thu 05 Sep 2013 06:22:14 PM JST
    def __init__(self, ):
        """
        """

* Thu 05 Sep 2013 06:22:26 PM JST
StandardError
* Thu 05 Sep 2013 06:24:27 PM JST

* Thu 05 Sep 2013 06:24:27 PM JST

* Thu 05 Sep 2013 06:24:27 PM JST
            # TODO: (Atami) [2013/09/05]

* Thu 05 Sep 2013 06:24:27 PM JST
            # TODO: (Atami) [2013/09/05]

* Thu 05 Sep 2013 06:24:27 PM JST
            # TODO: (Atami) [2013/09/05]
            # make Error class

* Thu 05 Sep 2013 09:16:46 PM JST
13 21   * * *   root    /usr/bin/python 
* Thu 05 Sep 2013 09:16:48 PM JST
python 
* Thu 05 Sep 2013 09:21:20 PM JST
19 21   * * *   root    /root/.zsh/scripts/daily
* Thu 05 Sep 2013 09:21:22 PM JST
daily
* Thu 05 Sep 2013 09:21:22 PM JST
scripts/daily
* Thu 05 Sep 2013 09:21:22 PM JST
zsh/scripts/daily
* Thu 05 Sep 2013 09:21:22 PM JST
root/.zsh/scripts/daily
* Thu 05 Sep 2013 09:26:22 PM JST

* Thu 05 Sep 2013 09:26:22 PM JST

* Thu 05 Sep 2013 09:26:22 PM JST
        for u in COLLECTION:

* Thu 05 Sep 2013 09:27:42 PM JST
url + '"'
* Thu 05 Sep 2013 09:27:42 PM JST
openchrome('"' + url + '"'
* Thu 05 Sep 2013 09:28:19 PM JST
            if not yesnodialog('Prompt', 'Please Enter OK will next: '):
                sys.exit(1)

* Thu 05 Sep 2013 09:35:08 PM JST
if not name == name_list[-1]:
* Thu 05 Sep 2013 09:35:19 PM JST
name
* Fri 06 Sep 2013 08:08:51 AM JST

* Fri 06 Sep 2013 08:08:52 AM JST

* Fri 06 Sep 2013 08:08:52 AM JST
                      # '\n***** SSH login {0}({1})[rook]'.format(

* Fri 06 Sep 2013 08:08:53 AM JST
                      # '\n***** SSH login {0}({1})[rook]'.format(

* Fri 06 Sep 2013 08:08:53 AM JST
                      # '\n***** SSH login {0}({1})[rook]'.format(
                    # self._host, gethostbyname(self._host))

* Fri 06 Sep 2013 08:08:54 AM JST
                    
* Fri 06 Sep 2013 08:08:55 AM JST
                    
* Fri 06 Sep 2013 08:13:23 AM JST
PROXY
* Fri 06 Sep 2013 08:13:42 AM JST
URL = {'speed': 'http://www.cybersyndrome.net/plr5.html',
       'anonymous': 'http://www.cybersyndrome.net/pla5.html',
       }

* Fri 06 Sep 2013 08:13:46 AM JST

* Fri 06 Sep 2013 08:13:46 AM JST

* Fri 06 Sep 2013 08:13:46 AM JST
proxy =  

* Fri 06 Sep 2013 08:13:48 AM JST
URL
* Fri 06 Sep 2013 08:15:56 AM JST
                      
* Fri 06 Sep 2013 08:23:31 AM JST
def which(filename):
    """docstring for which"""
    locations = _os.environ.get("PATH").split(_os.pathsep)
    candidates = []
    for location in locations:
        candidate = _os.path.join(location, filename)
        if _os.path.isfile(candidate):
            candidates.append(candidate)
    return candidates

* Fri 06 Sep 2013 08:47:11 AM JST

* Fri 06 Sep 2013 08:47:11 AM JST

* Fri 06 Sep 2013 08:47:11 AM JST
        for m in self._methods:

* Fri 06 Sep 2013 08:47:11 AM JST
        for m in self._methods:

* Fri 06 Sep 2013 08:47:11 AM JST
        for m in self._methods:
            return m

* Fri 06 Sep 2013 08:48:57 AM JST
        for m in dir(self):
            if not m.startswith and inspect.ismethod(m):
                self._methods.append(m)

* Fri 06 Sep 2013 08:50:30 AM JST
        for m in dir(self):
            if not m.startswith('_') and inspect.ismethod(m):
                self._methods.append(m)


* Fri 06 Sep 2013 08:54:31 AM JST

* Fri 06 Sep 2013 08:54:31 AM JST

* Fri 06 Sep 2013 08:54:31 AM JST
        self._methods = []

* Fri 06 Sep 2013 08:59:32 AM JST

* Fri 06 Sep 2013 08:59:32 AM JST

* Fri 06 Sep 2013 08:59:32 AM JST
import inspect

* Fri 06 Sep 2013 09:00:54 AM JST
    def pyreverse(self, detail=True):
        """Pyreverse command.

        @Arguments:
        - `detail`:

        @Return:
        """
        # detarmine pyreverse bin_
        if 'nt' == _os.name:
            bin_ = 'pyreverse.bat'
        elif 'posix' == _os.name:
            bin_ = 'pyreverse'

        # check exists pyreverse bin_
        if not which(bin_):
            raise IOError('File does not exists: %s' % bin_)

        # destination directory
        dst_dir = _os.path.join(self._dir, 'UML')
        # if not exists create it.
        if not _os.path.exists(dst_dir):
            _os.mkdir(dst_dir)

        # Do execute, there are two option.
        # simple output or detail output
        name = _os.path.basename(self._dir)
        if detail:
            cmd = '{0} -SAmy -o png -p {1} {2}'.format(bin_, name, self._target)
        else:
            name = 'Simple_' + name
            cmd = '{0} -o png -p {1} {2}'.format(bin_, name, self._target)
        _os.system(cmd)

        # check output
        src_name = 'classes_{0}.png'.format(name)
        src = _os.path.abspath(src_name)
        # if not exists src, raise error
        path_checker(src)

        # finalyze
        dst = _os.path.join(dst_dir, src_name)
        # first then remove it, if exists dst file.
        if _os.path.exists(dst):
            _os.remove(dst)
        if _os.path.exists(src):
            shutil.move(src, dst)
        elif not _os.path.exists(src):
            raise IOError('File does not exists: %s' % src)

* Fri 06 Sep 2013 09:01:32 AM JST
    def epydoc(self):
        """Epydoc command.

        @Arguments:
        - `target`:

        @Return:
        """
        if not _os.path.isabs(self._target):
            raise ValueError('Set absolute path: %s' % self._target)

        # check exists epydoc
        bin_ = 'epydoc'
        if not which(bin_):
            raise IOError('File does not exists: %s' % bin_)

        # destination directory
        dst = _os.path.join(self._dir, 'epydoc_html')

        # do exec
        cmd = '{0} --graph all --html --output {1} {2}'.format(
            bin_, dst, self._target)
        _os.system(cmd)

        # check output
        if not _os.path.exists(dst):
            raise IOError('File does not exists: {0}'.format(dst))

* Fri 06 Sep 2013 09:02:20 AM JST
    def my_doxygen(self):
        """Doxygen command.

        @Return:
        """
        if 'nt' == _os.name:
            dox_bin = 'doxygen.exe'
            doxygen_conf = _os.path.join(DRIVE_DIR, 'Dos/graphviz/doxygen.conf')
        elif 'posix' == _os.name:
            dox_bin = 'doxygen'
            doxygen_conf = _os.path.expanduser('~/.emacs.d/data_e/doxygen.conf')

        dox_output = 'doxygen_html'
        # check doxygen exec file
        if not which(dox_bin):
            raise IOError('File does not exists: %s' % dox_bin)

        # check doxygen config and target files
        for item in [doxygen_conf, self._target]:
            path_checker(item)

        # set flag if exists target
        isfile = _os.path.isfile(self._target)

        # create tmp directory and go to directory if target is file, .
        if isfile:
            tempdir = tempfile.mkdtemp()
            shutil.copy2(self._target, tempdir)
            _os.chdir(tempdir)
        else:
            _os.chdir(_os.path.dirname(self._target))

        # Execute doxygen
        _os.system(dox_bin + ' ' + doxygen_conf)

        path_checker(dox_output)

        # move outputed directory to orig path if target is file
        if isfile:
            shutil.copytree(dox_output, _os.path.join(self._dir, dox_output))

* Fri 06 Sep 2013 09:02:36 AM JST
object
* Fri 06 Sep 2013 09:03:36 AM JST
my_
* Fri 06 Sep 2013 09:09:56 AM JST
orig_dir = _os.path.curdir()
* Fri 06 Sep 2013 09:10:26 AM JST
curdir()
* Fri 06 Sep 2013 09:14:23 AM JST
m)
* Fri 06 Sep 2013 09:17:20 AM JST

* Fri 06 Sep 2013 09:17:20 AM JST

* Fri 06 Sep 2013 09:17:20 AM JST
            print(type(m))

* Fri 06 Sep 2013 09:18:13 AM JST
has
* Fri 06 Sep 2013 09:21:56 AM JST
getattr(self, m)
* Fri 06 Sep 2013 09:22:04 AM JST
inspect.ismethod(getattr(self, m))
* Fri 06 Sep 2013 09:22:08 AM JST

* Fri 06 Sep 2013 09:22:08 AM JST

* Fri 06 Sep 2013 09:22:08 AM JST
                method = 

* Fri 06 Sep 2013 09:22:08 AM JST
                method = 

* Fri 06 Sep 2013 09:22:08 AM JST
                method = 
                if :

* Fri 06 Sep 2013 09:22:15 AM JST
method()
* Fri 06 Sep 2013 09:23:49 AM JST

* Fri 06 Sep 2013 09:23:49 AM JST

* Fri 06 Sep 2013 09:23:49 AM JST
                print('append')

* Fri 06 Sep 2013 09:26:13 AM JST
                
* Fri 06 Sep 2013 09:31:04 AM JST
m == ''
* Fri 06 Sep 2013 09:31:04 AM JST
if m == ''
* Fri 06 Sep 2013 09:32:16 AM JST
self._methods.append(getattr(self, m))
* Fri 06 Sep 2013 09:33:48 AM JST
NAME
* Fri 06 Sep 2013 09:33:49 AM JST
self._methods.pop()
* Fri 06 Sep 2013 09:34:09 AM JST
    def yahoo(self):
        """SUMMARY

        @Return:
        """
        print('yahoo')


* Fri 06 Sep 2013 09:39:06 AM JST
        for m in dir(self):
            if m.startswith('_') or m in ['next']:
                continue
            if inspect.ismethod(getattr(self, m)):

* Fri 06 Sep 2013 09:39:16 AM JST
self._methods.append(m)
* Fri 06 Sep 2013 09:39:41 AM JST
        try:
            func = getattr(self, self._methods.pop())
        except IndexError:
            raise StopIteration
        return func

* Fri 06 Sep 2013 11:27:34 AM JST
/tmp/tmp7TPeyW
* Fri 06 Sep 2013 11:38:49 AM JST
:
* Fri 06 Sep 2013 11:39:33 AM JST
binpath']
* Fri 06 Sep 2013 11:40:27 AM JST
    
* Fri 06 Sep 2013 11:40:57 AM JST
_os.path.expanduser('~/.emacs.d/data_e/doxygen.conf')
* Fri 06 Sep 2013 11:41:11 AM JST
_os.path.join(DRIVE_DIR, 'Dos/graphviz/doxygen.conf')
* Fri 06 Sep 2013 11:45:46 AM JST
dox_bin
* Fri 06 Sep 2013 11:45:57 AM JST
dox_bin
* Fri 06 Sep 2013 11:46:25 AM JST
exec
* Fri 06 Sep 2013 11:46:35 AM JST
file
* Fri 06 Sep 2013 11:47:07 AM JST
doxygen_conf
* Fri 06 Sep 2013 11:48:57 AM JST
dox_bin
* Fri 06 Sep 2013 11:50:56 AM JST
_os.path.join(DRIVE_DIR, 'Dos/graphviz/doxygen.conf'
* Fri 06 Sep 2013 11:52:26 AM JST
        # Execute doxygen
        _os.system(DOXYGEN.get('bin') + ' ' + doxygen_conf)
        path_checker(dox_output)

* Fri 06 Sep 2013 11:52:32 AM JST
            # Execute doxygen
            _os.system(DOXYGEN.get('bin') + ' ' + doxygen_conf)
            path_checker(dox_output)

* Fri 06 Sep 2013 11:52:39 AM JST
doxygen_conf
* Fri 06 Sep 2013 11:52:49 AM JST
DOXYGEN.get('conf')
* Fri 06 Sep 2013 11:52:59 AM JST
shutil.copytree(dox_output, _os.path.join(self._dir, dox_output))
* Fri 06 Sep 2013 11:54:05 AM JST

* Fri 06 Sep 2013 11:54:05 AM JST

* Fri 06 Sep 2013 11:54:05 AM JST
        if isfile:

* Fri 06 Sep 2013 11:54:06 AM JST
        if isfile:

* Fri 06 Sep 2013 11:54:06 AM JST
        if isfile:
            shutil.copytree(dox_output, _os.path.join(self._dir, dox_output))

* Fri 06 Sep 2013 11:54:13 AM JST
_os.path.isfile(self._target)
* Fri 06 Sep 2013 12:25:19 PM JST
path.
* Fri 06 Sep 2013 01:17:24 PM JST

* Fri 06 Sep 2013 01:17:24 PM JST

* Fri 06 Sep 2013 01:17:24 PM JST
if 'posix' == _os.name or 'java' == _os.name:

* Fri 06 Sep 2013 01:39:34 PM JST
'{0} {1}'.format(CMD.get('google-chrome'), url)
* Fri 06 Sep 2013 01:40:07 PM JST
])
* Fri 06 Sep 2013 01:41:16 PM JST
SLEIPNIR.get('launcher')
* Fri 06 Sep 2013 01:42:02 PM JST
SKL_FILE.get('sleipnir_rss')
* Fri 06 Sep 2013 01:43:41 PM JST
'/usr/bin/xfe {0}'.format(PATH.get('recipedir'))
* Fri 06 Sep 2013 03:15:57 PM JST

* Fri 06 Sep 2013 03:16:00 PM JST
autoreload
* Fri 06 Sep 2013 03:17:09 PM JST

* Fri 06 Sep 2013 04:07:28 PM JST
ELSE
* Fri 06 Sep 2013 04:09:59 PM JST
last-input-event
* Fri 06 Sep 2013 04:15:42 PM JST
    
* Fri 06 Sep 2013 04:19:42 PM JST
 
* Fri 06 Sep 2013 04:19:47 PM JST
Listify-key-sequence
* Fri 06 Sep 2013 04:27:38 PM JST
  
* Fri 06 Sep 2013 04:58:52 PM JST
        while 1: 
            data = conn.recv(blocksize)
            if not data: 
                break
            callback(data)
        conn.close()
* Fri 06 Sep 2013 05:42:32 PM JST
ifmain
* Fri 06 Sep 2013 05:43:02 PM JST
# expand-env: ((yas/indent-line 'fixed) (yas/wrap-around-region 'nil))
* Fri 06 Sep 2013 05:43:40 PM JST
pass
* Fri 06 Sep 2013 05:44:24 PM JST
parser = argparse.ArgumentParser(description="""Backup king server.""")
parser.add_argument('--version',
                    dest='version',
                    action='version',
                    version=__version__,
                    help='Version Strings.')
parser.add_argument('-f', '--force',
                    dest='force',
                    action='store_true',
                    default=False,
                    required=False,
                    # (yas/expand-link "argparse_other_options" t)
                    help='Force Backup.')

parser.add_argument('-d', '--debug',
                    dest='debug',
                    action='store_true',
                    default=False,
                    required=False,
                    # (yas/expand-link "argparse_other_options" t)
                    help='Run as debug mode.')

# (yas/expand-link "argparse_add_argument" t)

* Fri 06 Sep 2013 05:44:45 PM JST

* Fri 06 Sep 2013 05:44:45 PM JST

* Fri 06 Sep 2013 05:44:45 PM JST
opt = parser.parse_args()

* Fri 06 Sep 2013 05:45:28 PM JST
## Define Variables
#
# define log file name
log_name = 'backup_ki.log'
log_base_dir = '/var/log'
log_path = os.path.join(log_base_dir, log_name)
logging.basicConfig(filename=log_path,
                    level=logging.DEBUG,
                    format='%(asctime)s %(message)s')


* Fri 06 Sep 2013 05:45:38 PM JST
# define backup directory name
backup_name = 'king_local'
backup_base_dir = '/data/.backup'
backup_path = os.path.join(backup_base_dir, backup_name)

# define Max incremental backup
MAX = 30

MSG = {'start': '{0:*^30}'.format('Started Local Backup'),
       'nodecrypt': 'Failed: Not decrypted /dev/mapper/data. Will Exit.',
       'notmounted': 'Failed: Not mounted {0}'.format(backup_base_dir),
       'nobkuppath': 'Warnings: Not exists {0}. Will create'.format(backup_path),
       'sshfs_mounting': 'Failed: sshfs mounting /data',
       }


* Fri 06 Sep 2013 05:45:51 PM JST
## check platform
#
if 'nt' == os.name:
    sys.exit('Not support WindowsNT.')

## check root
#
if not 0 == os.geteuid():
    sys.exit('Script must be run as root.')

# wait decrypt
if not opt.debug:
    sleep(600)

* Fri 06 Sep 2013 05:46:12 PM JST

* Fri 06 Sep 2013 05:46:12 PM JST

* Fri 06 Sep 2013 05:46:12 PM JST
    #

* Fri 06 Sep 2013 05:46:19 PM JST

* Fri 06 Sep 2013 05:46:19 PM JST

* Fri 06 Sep 2013 05:46:19 PM JST
    #

* Fri 06 Sep 2013 05:46:40 PM JST
## Start Backup message
#
print(MSG.get('start'))
logging.log(10, MSG.get('start'))


* Fri 06 Sep 2013 05:46:59 PM JST

* Fri 06 Sep 2013 05:46:59 PM JST

* Fri 06 Sep 2013 05:46:59 PM JST
    #

* Fri 06 Sep 2013 05:47:18 PM JST
## check disk exists
#
if not os.path.exists('/dev/mapper/data_crypt'):
    logging.log(10, MSG.get('nodecrypt'))
    sys.exit(MSG.get('nodecrypt'))

if not os.path.exists(backup_base_dir):
    logging.log(10, MSG.get('notmounted'))
    sys.exit(MSG.get('notmounted'))

if not os.path.exists(backup_path):
    logging.log(10, MSG.get('nobkuppath'))
    print(MSG.get('nobkuppath'))
    os.mkdir(backup_path)


* Fri 06 Sep 2013 05:47:32 PM JST

* Fri 06 Sep 2013 05:47:32 PM JST

* Fri 06 Sep 2013 05:47:32 PM JST
    #

* Fri 06 Sep 2013 05:49:50 PM JST
bk.bkupdir
* Fri 06 Sep 2013 05:50:04 PM JST

* Fri 06 Sep 2013 05:50:04 PM JST

* Fri 06 Sep 2013 05:50:04 PM JST
#

* Fri 06 Sep 2013 05:50:53 PM JST
def _predef_options():
    parser = argparse.ArgumentParser(description="""Backup king server.""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,
                        help='Version Strings.')
    parser.add_argument('-f', '--force',
                        dest='force',
                        action='store_true',
                        default=False,
                        required=False,
                        # (yas/expand-link "argparse_other_options" t)
                        help='Force Backup.')
    parser.add_argument('-d', '--debug',
                        dest='debug',
                        action='store_true',
                        default=False,
                        required=False,
                        # (yas/expand-link "argparse_other_options" t)
                        help='Run as debug mode.')
    # (yas/expand-link "argparse_add_argument" t)
    return parser

* Fri 06 Sep 2013 11:16:12 PM JST
root
* Fri 06 Sep 2013 11:16:12 PM JST
chrck root
* Fri 06 Sep 2013 11:16:13 PM JST
and chrck root
* Fri 06 Sep 2013 11:58:33 PM JST
os.path.dirname()
* Sat 07 Sep 2013 01:00:58 AM JST
OpenWrt Kamikaze
* Sat 07 Sep 2013 01:11:18 AM JST
BASE_
* Sat 07 Sep 2013 01:28:19 AM JST
              
* Sat 07 Sep 2013 01:28:20 AM JST
              
* Sat 07 Sep 2013 01:28:25 AM JST
    
* Sat 07 Sep 2013 01:28:27 AM JST
              
* Sat 07 Sep 2013 01:28:28 AM JST
              
* Sat 07 Sep 2013 01:28:31 AM JST
              
* Sat 07 Sep 2013 01:28:33 AM JST
              
* Sat 07 Sep 2013 01:28:35 AM JST
              
* Sat 07 Sep 2013 01:28:37 AM JST
              
* Sat 07 Sep 2013 01:28:38 AM JST
              
* Sat 07 Sep 2013 01:28:40 AM JST
              
* Sat 07 Sep 2013 01:28:42 AM JST
              
* Sat 07 Sep 2013 01:28:43 AM JST
              
* Sat 07 Sep 2013 01:28:45 AM JST
              
* Sat 07 Sep 2013 01:28:46 AM JST
              
* Sat 07 Sep 2013 01:28:49 AM JST
'WIDE', 
* Sat 07 Sep 2013 01:28:50 AM JST
              
* Sat 07 Sep 2013 01:28:51 AM JST
              
* Sat 07 Sep 2013 01:28:53 AM JST
              
* Sat 07 Sep 2013 01:28:54 AM JST
              
* Sat 07 Sep 2013 01:28:56 AM JST
              
* Sat 07 Sep 2013 01:28:57 AM JST
              
* Sat 07 Sep 2013 01:37:56 AM JST
$Revision$
* Sat 07 Sep 2013 01:37:56 AM JST
#!/usr/bin/env python
* Sat 07 Sep 2013 01:37:56 AM JST
# -*- coding: utf-8 -*-
* Sat 07 Sep 2013 01:37:56 AM JST
""" aquos -- for aquos TV handler.
* Sat 07 Sep 2013 01:42:24 AM JST
acha
* Sat 07 Sep 2013 01:44:49 AM JST
cmd[]
* Sat 07 Sep 2013 01:47:53 AM JST

* Sat 07 Sep 2013 01:47:53 AM JST

* Sat 07 Sep 2013 01:47:53 AM JST
IAVD_FMT = 'IAVD{0: <4}\n'

* Sat 07 Sep 2013 01:47:57 AM JST

* Sat 07 Sep 2013 01:47:57 AM JST

* Sat 07 Sep 2013 01:47:57 AM JST
POWER_FMT = 'POWR{0: <4}\n'

* Sat 07 Sep 2013 01:48:04 AM JST
POWER_FMT
* Sat 07 Sep 2013 01:48:15 AM JST
format
* Sat 07 Sep 2013 01:48:30 AM JST
CMD_FORMAT.get('POWR')
* Sat 07 Sep 2013 01:52:46 AM JST
# power command format
* Sat 07 Sep 2013 02:00:17 AM JST
INPUT_AUDIO
* Sat 07 Sep 2013 02:02:38 AM JST

* Sat 07 Sep 2013 02:02:38 AM JST

* Sat 07 Sep 2013 02:02:38 AM JST
CHANNEL_BSD = {}

* Sat 07 Sep 2013 02:04:07 AM JST
'INP4', 'AVMD', 'VOLM', 'HPOS', 'VPOS', 'CLCK',
              'PHSE', 'WIDE', 'MUTE', 'ACSU', 'ACHA', 'OFTM'
* Sat 07 Sep 2013 02:04:34 AM JST
              
* Sat 07 Sep 2013 02:05:58 AM JST

* Sat 07 Sep 2013 02:05:58 AM JST

* Sat 07 Sep 2013 02:05:58 AM JST
# INP4 

* Sat 07 Sep 2013 02:07:05 AM JST

* Sat 07 Sep 2013 02:07:05 AM JST

* Sat 07 Sep 2013 02:07:05 AM JST
    INP4[i] = CMD_FORMAT.get

* Sat 07 Sep 2013 02:07:09 AM JST
4]
* Sat 07 Sep 2013 02:07:09 AM JST
1, 4]
* Sat 07 Sep 2013 02:07:10 AM JST
0, 1, 4]
* Sat 07 Sep 2013 02:23:00 AM JST
                         
* Sat 07 Sep 2013 02:29:25 AM JST
enumerateg
* Sat 07 Sep 2013 02:33:25 AM JST
MUTEg
* Sat 07 Sep 2013 02:33:32 AM JST
MUTEfor
* Sat 07 Sep 2013 02:45:02 AM JST
POWR
* Sat 07 Sep 2013 02:46:25 AM JST
globals()[cmd] = {'check': CMD_FORMAT.get(cmd).format('?')}
* Sat 07 Sep 2013 02:46:28 AM JST

* Sat 07 Sep 2013 02:46:28 AM JST

* Sat 07 Sep 2013 02:46:28 AM JST
# TODO: (Atami) [2013/09/07]

* Sat 07 Sep 2013 02:46:28 AM JST
# TODO: (Atami) [2013/09/07]

* Sat 07 Sep 2013 02:46:28 AM JST
# TODO: (Atami) [2013/09/07]
for cmd in A_PART_CMD:

* Sat 07 Sep 2013 02:47:10 AM JST
INPUT_
* Sat 07 Sep 2013 02:47:27 AM JST
DISPLAY_
* Sat 07 Sep 2013 02:47:53 AM JST
SROUND
* Sat 07 Sep 2013 02:48:02 AM JST
OFFTIMER
* Sat 07 Sep 2013 10:04:24 AM JST

* Sat 07 Sep 2013 10:04:24 AM JST

* Sat 07 Sep 2013 10:04:24 AM JST
POWR = {'check': CMD_FORMAT.get('POWR').format('?')}

* Sat 07 Sep 2013 10:04:26 AM JST

* Sat 07 Sep 2013 10:04:26 AM JST

* Sat 07 Sep 2013 10:04:26 AM JST
IAVD = {'check': CMD_FORMAT.get('IAVD').format('?')}

* Sat 07 Sep 2013 10:04:28 AM JST

* Sat 07 Sep 2013 10:04:28 AM JST

* Sat 07 Sep 2013 10:04:28 AM JST
INP4 = {'check': CMD_FORMAT.get('INP4').format('?')}

* Sat 07 Sep 2013 10:04:30 AM JST

* Sat 07 Sep 2013 10:04:30 AM JST

* Sat 07 Sep 2013 10:04:30 AM JST
AVMD = {'check': CMD_FORMAT.get('AVMD').format('?')}

* Sat 07 Sep 2013 10:05:09 AM JST

* Sat 07 Sep 2013 10:05:09 AM JST

* Sat 07 Sep 2013 10:05:09 AM JST
AVMD = {'check': CMD_FORMAT.get('AVMD').format('?')}

* Sat 07 Sep 2013 10:05:12 AM JST

* Sat 07 Sep 2013 10:05:12 AM JST

* Sat 07 Sep 2013 10:05:12 AM JST
WIDE = {'check': CMD_FORMAT.get('WIDE').format('?')}

* Sat 07 Sep 2013 10:05:14 AM JST

* Sat 07 Sep 2013 10:05:14 AM JST

* Sat 07 Sep 2013 10:05:14 AM JST
MUTE = {'check': CMD_FORMAT.get('MUTE').format('?')}

* Sat 07 Sep 2013 10:05:16 AM JST

* Sat 07 Sep 2013 10:05:16 AM JST

* Sat 07 Sep 2013 10:05:16 AM JST
ACSU = {'check': CMD_FORMAT.get('ACSU').format('?')}

* Sat 07 Sep 2013 10:05:17 AM JST

* Sat 07 Sep 2013 10:05:17 AM JST

* Sat 07 Sep 2013 10:05:17 AM JST
OFTM = {'check': CMD_FORMAT.get('OFTM').format('?')}

* Sat 07 Sep 2013 10:27:10 AM JST

* Sat 07 Sep 2013 10:27:10 AM JST

* Sat 07 Sep 2013 10:27:10 AM JST
    self.

* Sat 07 Sep 2013 10:38:23 AM JST
self.recv(1024)
* Sat 07 Sep 2013 10:48:27 AM JST
pass
* Sat 07 Sep 2013 10:49:17 AM JST
self
* Sat 07 Sep 2013 10:49:34 AM JST
object
* Sat 07 Sep 2013 10:52:49 AM JST
print(
* Sat 07 Sep 2013 10:53:52 AM JST
getattr
* Sat 07 Sep 2013 10:54:10 AM JST
classmethod
* Sat 07 Sep 2013 10:54:26 AM JST
globals()[cls.__name__[1:]].get('check')
* Sat 07 Sep 2013 10:58:09 AM JST

* Sat 07 Sep 2013 10:58:09 AM JST

* Sat 07 Sep 2013 10:58:09 AM JST
        print(self.__name__)

* Sat 07 Sep 2013 10:58:20 AM JST
self
* Sat 07 Sep 2013 11:00:47 AM JST
self
* Sat 07 Sep 2013 11:03:07 AM JST

* Sat 07 Sep 2013 11:03:07 AM JST

* Sat 07 Sep 2013 11:03:07 AM JST
        print(cls.__name__)

* Sat 07 Sep 2013 11:03:58 AM JST
self
* Sat 07 Sep 2013 11:19:05 AM JST

* Sat 07 Sep 2013 11:19:05 AM JST

* Sat 07 Sep 2013 11:19:05 AM JST
    @classmethod

* Sat 07 Sep 2013 11:19:07 AM JST
cls
* Sat 07 Sep 2013 11:23:45 AM JST
print(
* Sat 07 Sep 2013 11:25:05 AM JST
.get('check')
* Sat 07 Sep 2013 11:31:27 AM JST
pass
* Sat 07 Sep 2013 11:36:54 AM JST

* Sat 07 Sep 2013 11:36:54 AM JST

* Sat 07 Sep 2013 11:36:54 AM JST
        # get class name's dictonary

* Sat 07 Sep 2013 11:36:54 AM JST
        # get class name's dictonary

* Sat 07 Sep 2013 11:36:54 AM JST
        # get class name's dictonary
        # print(globals()[cls.__name__[1:]].get('check'))

* Sat 07 Sep 2013 11:36:55 AM JST
        # get class name's dictonary
        # print(globals()[cls.__name__[1:]].get('check'))

* Sat 07 Sep 2013 11:36:55 AM JST
        # get class name's dictonary
        # print(globals()[cls.__name__[1:]].get('check'))
        # cls._send(globals()[cls.__name__[1:]].get('check'))

* Sat 07 Sep 2013 11:36:55 AM JST
        # get class name's dictonary
        # print(globals()[cls.__name__[1:]].get('check'))
        # cls._send(globals()[cls.__name__[1:]].get('check'))

* Sat 07 Sep 2013 11:36:55 AM JST
        # get class name's dictonary
        # print(globals()[cls.__name__[1:]].get('check'))
        # cls._send(globals()[cls.__name__[1:]].get('check'))
        # super()

* Sat 07 Sep 2013 11:37:29 AM JST
True
* Sat 07 Sep 2013 11:51:28 AM JST
pas
* Sat 07 Sep 2013 11:54:05 AM JST
self.__class__.__name__[1:]
* Sat 07 Sep 2013 11:56:09 AM JST
ITGD
* Sat 07 Sep 2013 11:59:05 AM JST
ITGDg
* Sat 07 Sep 2013 11:59:15 AM JST
ITGD
* Sat 07 Sep 2013 11:59:42 AM JST
ITVD
* Sat 07 Sep 2013 11:59:50 AM JST
ITVDfo
* Sat 07 Sep 2013 12:07:20 PM JST
IDEGge
* Sat 07 Sep 2013 12:07:45 PM JST
IDEGfor
* Sat 07 Sep 2013 12:09:36 PM JST
CBSD
* Sat 07 Sep 2013 12:10:02 PM JST
CCSD
* Sat 07 Sep 2013 12:10:26 PM JST
CTBD
* Sat 07 Sep 2013 12:11:51 PM JST
CHUP
* Sat 07 Sep 2013 12:11:57 PM JST
CHUPf
* Sat 07 Sep 2013 12:12:04 PM JST
CHUP['up'] = CMD_FORMATS.get('CHUP').format(' ') 
* Sat 07 Sep 2013 12:15:11 PM JST
class _CBSD(_ConnectAbstract):
    """
    """
    
    def setchannel(self, num):
        """SUMMARY
        
        @Arguments:
        
        - `num`:
        
        @Return:
        """
        assert 0 <= num <= 999
        self._send(self._cmds.get('format').format(num))

* Sat 07 Sep 2013 12:26:17 PM JST
['toggle', 'standard', 'movie', 'game', 'avmemory',
                     'static dynamic', 'dynamic', 'pc']
* Sat 07 Sep 2013 12:28:46 PM JST
name
* Sat 07 Sep 2013 12:30:41 PM JST

* Sat 07 Sep 2013 12:30:41 PM JST

* Sat 07 Sep 2013 12:30:41 PM JST
# ['toggle', 'standard', 'movie', 'game', 'avmemory',

* Sat 07 Sep 2013 12:30:41 PM JST
# ['toggle', 'standard', 'movie', 'game', 'avmemory',

* Sat 07 Sep 2013 12:30:41 PM JST
# ['toggle', 'standard', 'movie', 'game', 'avmemory',
                     # 'static dynamic', 'dynamic', 'pc']

* Sat 07 Sep 2013 12:58:24 PM JST
HPOS
* Sat 07 Sep 2013 12:58:42 PM JST
VPOS
* Sat 07 Sep 2013 12:59:06 PM JST
CLCK
* Sat 07 Sep 2013 12:59:25 PM JST
PHSE
* Sat 07 Sep 2013 01:01:31 PM JST
'toggle', 'normal', 'smartzoom', 'wide4:3',
                             'cinema', 'full', 'full1', 'full2', 'underscan',
                             'dot_by_dot', 'wide16:9'
* Sat 07 Sep 2013 01:03:52 PM JST
smartzoom
* Sat 07 Sep 2013 01:04:31 PM JST
name
* Sat 07 Sep 2013 01:06:11 PM JST
name
* Sat 07 Sep 2013 01:17:47 PM JST
format
* Sat 07 Sep 2013 01:18:04 PM JST
format
* Sat 07 Sep 2013 01:18:07 PM JST
format(' ')
* Sat 07 Sep 2013 01:43:55 PM JST

* Sat 07 Sep 2013 01:43:55 PM JST

* Sat 07 Sep 2013 01:43:55 PM JST
        print(cmd)

* Sat 07 Sep 2013 01:43:55 PM JST
        print(cmd)

* Sat 07 Sep 2013 01:43:55 PM JST
        print(cmd)
        return

* Sat 07 Sep 2013 01:44:26 PM JST
    def _send(self, cmd):
        """SUMMARY

        @Arguments:

        - `cmd`:

        @Return:
        """
        self._sock.send(cmd)
        result = self.recv(1024)
        if 'OK' == result:
            return result
        elif 'ERR' == result:
            raise StandardError(result)
        else:
            raise StandardError('unkown error {}'.format(result))

* Sat 07 Sep 2013 01:47:56 PM JST

* Sat 07 Sep 2013 01:47:56 PM JST

* Sat 07 Sep 2013 01:47:56 PM JST
        self._sock.send(cmd)

* Sat 07 Sep 2013 03:59:32 PM JST
    def _sendcmd(self, cmd):
        """SUMMARY

        @Arguments:

        - `cmd`:

        @Return:
        """
        self._send(self._getcmd(cmd))


* Sat 07 Sep 2013 04:23:06 PM JST
    
* Sat 07 Sep 2013 04:26:53 PM JST
    ## prevent runlevel before connect network
    prevent.allow_runlevel(RUNLEVEL)


* Sat 07 Sep 2013 04:30:51 PM JST
sbp.check_call(['/usr/sbin/service', 'vmware', 'start'])
* Sat 07 Sep 2013 04:36:03 PM JST
self._
* Sat 07 Sep 2013 04:36:42 PM JST
_passwd
* Sat 07 Sep 2013 04:36:42 PM JST
self._passwd
* Sat 07 Sep 2013 04:38:33 PM JST
socket.
* Sat 07 Sep 2013 04:45:10 PM JST
passwd
* Sat 07 Sep 2013 04:48:23 PM JST

* Sat 07 Sep 2013 04:48:23 PM JST

* Sat 07 Sep 2013 04:48:24 PM JST
        self._passwd = passwd

* Sat 07 Sep 2013 04:49:26 PM JST

* Sat 07 Sep 2013 04:49:26 PM JST

* Sat 07 Sep 2013 04:49:26 PM JST
        self._passwd = None # clear password

* Sat 07 Sep 2013 04:50:35 PM JST
host,
* Sat 07 Sep 2013 04:50:42 PM JST
 host, 
* Sat 07 Sep 2013 04:50:50 PM JST
port=10000
* Sat 07 Sep 2013 04:59:34 PM JST
        
* Sat 07 Sep 2013 05:07:11 PM JST
        
* Sat 07 Sep 2013 05:20:48 PM JST

* Sat 07 Sep 2013 05:20:48 PM JST

* Sat 07 Sep 2013 05:20:49 PM JST
        # classname = self.__class__.__name__[1:]

* Sat 07 Sep 2013 05:20:51 PM JST
        # classname = self.__class__.__name__[1:]

* Sat 07 Sep 2013 05:20:51 PM JST
        # classname = self.__class__.__name__[1:]
        # return self._send(globals()[classname].get('check'))

* Sat 07 Sep 2013 05:22:20 PM JST
        self.power = _POWR(sock=self._sock)
        self.inputtoggle = _ITGD(sock=self._sock)
        self.inputtv = _ITVD(sock=self._sock)
        self.input = _IAVD(sock=self._sock)
        self.inputdegital = _IDEG(sock=self._sock)
        # self.channelBS = _CBSD(sock=self._sock)
        # self.channelCS = _CCSD(sock=self._sock)
        # self.channelTB = _CTBD(sock=self._sock)
        self.channel = _Channel(sock=self._sock)
        self.input4 = _INP4(sock=self._sock)
        self.avposition = _AVMD(sock=self._sock)
        self.volume = _VOLM(sock=self._sock)
        self.horizon = _HPOS(sock=self._sock)
        self.vertical = _VPOS(sock=self._sock)
        self.clock = _CLCK(sock=self._sock)
        self.clockphese = _PHSE(sock=self._sock)
        self.display = _WIDE(sock=self._sock)
        self.mute = _MUTE(sock=self._sock)
        self.audio = _ACHA(sock=self._sock)
        self.offtimer = _OFTM(sock=self._sock)

* Sat 07 Sep 2013 11:09:07 PM JST
          ("Python"   ?p "\
** TODO [#C] %?

1\) 背景(問題点)

2\) 対応方法

3\) 優先順位の根拠

4\) 備考

5\) 結果
6\) time/ref
    / cf. %a
   %i" nil "python:")

* Sat 07 Sep 2013 11:09:13 PM JST
Python
* Sat 07 Sep 2013 11:09:24 PM JST
python
* Sat 07 Sep 2013 11:14:03 PM JST

* Sat 07 Sep 2013 11:14:03 PM JST

* Sat 07 Sep 2013 11:14:03 PM JST
    root.wm_attributes('-topmost', 1)

* Sat 07 Sep 2013 11:36:20 PM JST

* Sat 07 Sep 2013 11:36:23 PM JST

* Sat 07 Sep 2013 11:36:23 PM JST

* Sat 07 Sep 2013 11:36:23 PM JST
            sleep(3)

* Sat 07 Sep 2013 11:46:48 PM JST
Section "Extensions"
    Option         "Composite" "Enable"
EndSection
* Sun 08 Sep 2013 12:03:31 AM JST
Source file `/root/.emacs.d/init.el' newer than byte-compiled
* Sun 08 Sep 2013 12:04:42 AM JST
os.path.pardir()
* Sun 08 Sep 2013 12:05:15 AM JST
inspect.is
* Sun 08 Sep 2013 12:06:28 PM JST
http://j.people.com.cn/
* Sun 08 Sep 2013 12:08:32 PM JST

* Sun 08 Sep 2013 12:08:32 PM JST

* Sun 08 Sep 2013 12:08:32 PM JST


* Sun 08 Sep 2013 12:18:05 PM JST
if = == 
* Sun 08 Sep 2013 12:18:16 PM JST
hello' ==
 == 
* Sun 08 Sep 2013 12:19:24 PM JST
if 'h:
* Sun 08 Sep 2013 12:28:29 PM JST
pass
* Sun 08 Sep 2013 12:31:11 PM JST
import argparse
import $0


* Sun 08 Sep 2013 12:31:17 PM JST

* Sun 08 Sep 2013 12:31:17 PM JST

* Sun 08 Sep 2013 12:31:17 PM JST
import $0

* Sun 08 Sep 2013 12:33:24 PM JST
(py--insert-imports "argparse" "import argparse")
* Sun 08 Sep 2013 12:33:36 PM JST
argparse
* Sun 08 Sep 2013 12:33:40 PM JST
argparse
* Sun 08 Sep 2013 12:47:27 PM JST
...       
* Sun 08 Sep 2013 12:48:17 PM JST
>>> import sys
>>> def test_write():
...    sys.stdout.write('hello\n')
...    return True
>>> test_write()
hello
True

* Sun 08 Sep 2013 12:51:04 PM JST
...     
* Sun 08 Sep 2013 12:51:06 PM JST
...     
* Sun 08 Sep 2013 12:51:09 PM JST
...     
* Sun 08 Sep 2013 12:53:55 PM JST
world
* Sun 08 Sep 2013 12:54:27 PM JST

* Sun 08 Sep 2013 12:54:27 PM JST

* Sun 08 Sep 2013 12:54:27 PM JST
"""

* Sun 08 Sep 2013 12:58:14 PM JST

* Sun 08 Sep 2013 12:58:15 PM JST

* Sun 08 Sep 2013 12:58:15 PM JST
    ;;

* Sun 08 Sep 2013 12:59:56 PM JST
    
* Sun 08 Sep 2013 12:59:59 PM JST
buffer
* Sun 08 Sep 2013 12:59:59 PM JST
execute-buffer
* Sun 08 Sep 2013 01:02:09 PM JST

* Sun 08 Sep 2013 01:02:11 PM JST
operator
* Sun 08 Sep 2013 01:02:11 PM JST
smart-operator
* Sun 08 Sep 2013 01:03:09 PM JST
operator
* Sun 08 Sep 2013 01:03:09 PM JST
smart-operator
* Sun 08 Sep 2013 01:05:49 PM JST
    
* Sun 08 Sep 2013 01:05:55 PM JST
    
* Sun 08 Sep 2013 01:06:45 PM JST
;;;###autoload
* Sun 08 Sep 2013 01:06:51 PM JST

* Sun 08 Sep 2013 01:06:51 PM JST

* Sun 08 Sep 2013 01:06:51 PM JST
(eval-after-load 'doctest-mode '(doctest-mode-predefine))

* Sun 08 Sep 2013 01:06:54 PM JST

* Sun 08 Sep 2013 01:06:54 PM JST

* Sun 08 Sep 2013 01:06:54 PM JST
(eval-after-load 'doctest-mode   '(doctest-mode-predefine       ))

* Sun 08 Sep 2013 01:07:12 PM JST
;;;###autoload
(defun doctest-mode-predefine ()
  "For eval-after-load doctest-mode function."
  (message "Loading doctest-mode..")
  (doctest-mode-map-predefine))

;;;###autoload
(defun doctest-mode-map-predefine ()
  "For doctest-mode key bindings."
  (interactive)
  (define-many-keys doctest-mode-map
    ("\C-cD"        'python-mode)
    ("\C-cP"        'python-mode)
    ("\C-cp"        'python-mode)
    ("\C-c\C-p"     'python-mode)
    ))

* Sun 08 Sep 2013 01:25:34 PM JST

* Sun 08 Sep 2013 01:25:34 PM JST

* Sun 08 Sep 2013 01:25:34 PM JST
    print(key)

* Sun 08 Sep 2013 01:33:46 PM JST
File "/usr/lib/python2.7/doctest.py", line 1289, in __run
* Sun 08 Sep 2013 01:34:16 PM JST
compileflags, 1) in test.globs
* Sun 08 Sep 2013 01:34:53 PM JST

* Sun 08 Sep 2013 01:34:53 PM JST

* Sun 08 Sep 2013 01:34:53 PM JST
  File "/usr/lib/python2.7/doctest.py", line 1289, in __run

* Sun 08 Sep 2013 01:34:54 PM JST
  File "/usr/lib/python2.7/doctest.py", line 1289, in __run

* Sun 08 Sep 2013 01:34:54 PM JST
  File "/usr/lib/python2.7/doctest.py", line 1289, in __run
    compileflags, 1) in test.globs

* Sun 08 Sep 2013 01:36:38 PM JST
SyntaxError: 'return' with argument inside generator (<doctest doctest.txt[0]>, l
* Sun 08 Sep 2013 01:45:08 PM JST

* Sun 08 Sep 2013 01:45:08 PM JST

* Sun 08 Sep 2013 01:45:08 PM JST
# binding: "keybinding"

* Sun 08 Sep 2013 01:45:08 PM JST
# binding: "keybinding"

* Sun 08 Sep 2013 01:45:09 PM JST
# binding: "keybinding"
# expand-env: ((some-var some-value))

* Sun 08 Sep 2013 01:53:18 PM JST

* Sun 08 Sep 2013 01:53:18 PM JST

* Sun 08 Sep 2013 01:53:18 PM JST
>>> sys.module # doctest: +ELLIPSIS

* Sun 08 Sep 2013 01:53:18 PM JST
>>> sys.module # doctest: +ELLIPSIS

* Sun 08 Sep 2013 01:53:18 PM JST
>>> sys.module # doctest: +ELLIPSIS
{...'sys': <module 'sys' (built-in)>...}

* Sun 08 Sep 2013 02:06:21 PM JST
+NORMALIZE_WHITESPACE
* Sun 08 Sep 2013 02:12:49 PM JST
multi-term-scroll-to-bottom-on-output
* Sun 08 Sep 2013 02:13:10 PM JST
(setq multi-term-scroll-to-bottom-on-output nil)
* Sun 08 Sep 2013 02:21:03 PM JST

* Sun 08 Sep 2013 02:21:28 PM JST

* Sun 08 Sep 2013 02:21:28 PM JST

* Sun 08 Sep 2013 02:21:28 PM JST
;; (setq overflow-newline-into-fringe nil)

* Sun 08 Sep 2013 02:25:14 PM JST
l         
* Sun 08 Sep 2013 02:27:48 PM JST
l         
* Sun 08 Sep 2013 02:30:56 PM JST
IGNORE_EXCEPTION_DETAIL
* Sun 08 Sep 2013 02:31:19 PM JST
DONT_ACCEPT_TRUE_FOR_1
* Sun 08 Sep 2013 02:31:30 PM JST
DONT_ACCEPT_BLANKLINE
* Sun 08 Sep 2013 02:31:56 PM JST
REPORT_UDIFF
* Sun 08 Sep 2013 02:32:05 PM JST
REPORT_CDIFF
* Sun 08 Sep 2013 02:32:12 PM JST
REPORT_NDIFF
* Sun 08 Sep 2013 02:32:20 PM JST
REPORT_ONLY_FIRST_FAILURE
* Sun 08 Sep 2013 02:41:20 PM JST
.endswith('\')
* Sun 08 Sep 2013 02:45:11 PM JST

* Sun 08 Sep 2013 02:45:11 PM JST

* Sun 08 Sep 2013 02:45:11 PM JST
        for str_ in [user, passwd]:

* Sun 08 Sep 2013 02:45:11 PM JST
        for str_ in [user, passwd]:

* Sun 08 Sep 2013 02:45:11 PM JST
        for str_ in [user, passwd]:
            if str_.endswith('\n'):

* Sun 08 Sep 2013 02:45:11 PM JST
        for str_ in [user, passwd]:
            if str_.endswith('\n'):

* Sun 08 Sep 2013 02:45:12 PM JST
        for str_ in [user, passwd]:
            if str_.endswith('\n'):
                str_

* Sun 08 Sep 2013 03:14:37 PM JST
# 'r' charactor before the first triple-quote for doctest
# don't want escape sequences - e.g '\n'

* Mon 09 Sep 2013 11:12:50 AM JST

* Mon 09 Sep 2013 11:12:50 AM JST

* Mon 09 Sep 2013 11:12:51 AM JST
>>> import operations

* Mon 09 Sep 2013 11:24:04 AM JST
sleep
* Mon 09 Sep 2013 11:24:25 AM JST
>>> obj = mocker.replace('time.sleep
* Mon 09 Sep 2013 11:24:57 AM JST
sleep
* Mon 09 Sep 2013 11:25:00 AM JST
sleep
* Mon 09 Sep 2013 11:25:20 AM JST

* Mon 09 Sep 2013 11:25:20 AM JST

* Mon 09 Sep 2013 11:25:20 AM JST
>>> from time import time

* Mon 09 Sep 2013 11:26:25 AM JST
<mocker.Mock object
* Mon 09 Sep 2013 11:26:44 AM JST


* Mon 09 Sep 2013 11:27:17 AM JST
# doctest: +ELLIPSIS
* Mon 09 Sep 2013 12:03:17 PM JST
if sys.version_info < (2, 4):
    from sets import Set as set # pragma: nocover

* Mon 09 Sep 2013 12:05:31 PM JST
if sys.version_info < (2, 4):
    from sets import Set as set

* Mon 09 Sep 2013 12:06:21 PM JST

* Mon 09 Sep 2013 12:06:21 PM JST

* Mon 09 Sep 2013 12:06:21 PM JST
# binding: "keybinding"

* Mon 09 Sep 2013 12:06:21 PM JST
# binding: "keybinding"

* Mon 09 Sep 2013 12:06:21 PM JST
# binding: "keybinding"
# expand-env: ((some-var some-value))

* Mon 09 Sep 2013 12:06:37 PM JST
# condition: (not (python-in-string/comment))
* Mon 09 Sep 2013 12:07:48 PM JST
`(py--insert-imports "os[ \t]+as _os" "import os as _os")`
* Mon 09 Sep 2013 12:10:32 PM JST
sets import Set as set
* Mon 09 Sep 2013 12:11:19 PM JST
[ \t]+
* Mon 09 Sep 2013 12:11:40 PM JST
if sys.version_info < (2, 4):
    from sets import Set as set # pragma: nocover

* Mon 09 Sep 2013 12:12:04 PM JST
    
* Mon 09 Sep 2013 12:12:53 PM JST

* Mon 09 Sep 2013 12:12:53 PM JST

* Mon 09 Sep 2013 12:12:53 PM JST
set(iterable = [])
* Mon 09 Sep 2013 12:12:54 PM JST

* Mon 09 Sep 2013 12:12:54 PM JST

* Mon 09 Sep 2013 12:12:54 PM JST
set(hello)

* Mon 09 Sep 2013 12:13:31 PM JST
(defun py--insert-imports (modules str)
  "py-insert-imports
MODULES
STR"
  ;; TODO: (Atami) [2013/02/14]
  ;; skip comments or strings
  (let ((region (py--import-region))
        (re (concat "\\(?:from\\|import\\)[ \t]+" modules)))
    (save-excursion
      (save-restriction
        ;; narrowing
        (when region
          (narrow-to-region (car region) (cdr region)))
        (goto-char (point-min))
        (unless (re-search-forward re nil 'noerror)
          (goto-char (point-min))
          (insert (concat str "\n"))
          )
        ))))

* Mon 09 Sep 2013 12:13:44 PM JST
modules
* Mon 09 Sep 2013 12:14:35 PM JST
        
* Mon 09 Sep 2013 12:15:55 PM JST

* Mon 09 Sep 2013 12:17:54 PM JST
"[ \t]+from[ \t]+sets[ \t]+import[ \t]+Set[ \t]+as[ \t]+set"
* Mon 09 Sep 2013 12:20:13 PM JST
py--insert-imports-regexp
* Mon 09 Sep 2013 12:23:29 PM JST
(re-search-forward re nil 'noerror)
* Mon 09 Sep 2013 12:23:39 PM JST
"[ \t]+from[ \t]+sets[ \t]+import[ \t]+Set[ \t]+as[ \t]+set"
* Mon 09 Sep 2013 12:23:41 PM JST
(re-search-forward "[ \t]+from[ \t]+sets[ \t]+import[ \t]+Set[ \t]+as[ \t]+set" nil 'noerror)
* Mon 09 Sep 2013 12:25:22 PM JST
if sys.version_info < (2, 4):
    from sets import Set as set


* Mon 09 Sep 2013 12:25:36 PM JST

* Mon 09 Sep 2013 12:25:36 PM JST

* Mon 09 Sep 2013 12:25:36 PM JST
import re

* Mon 09 Sep 2013 12:30:56 PM JST

* Mon 09 Sep 2013 12:30:56 PM JST

* Mon 09 Sep 2013 12:30:57 PM JST
      ELSE

* Mon 09 Sep 2013 12:30:59 PM JST
  
* Mon 09 Sep 2013 12:32:30 PM JST
(goto-char (point-min))
* Mon 09 Sep 2013 12:32:35 PM JST
            
* Mon 09 Sep 2013 12:33:36 PM JST

* Mon 09 Sep 2013 12:33:36 PM JST

* Mon 09 Sep 2013 12:33:36 PM JST
    set(hello)

* Mon 09 Sep 2013 12:33:36 PM JST
    set(hello)

* Mon 09 Sep 2013 12:33:36 PM JST
    set(hello)
    set(hello)

* Mon 09 Sep 2013 12:36:51 PM JST
(concat "\\(?:from\\|import\\)[ \t]+" modules)
* Mon 09 Sep 2013 12:38:14 PM JST

* Mon 09 Sep 2013 12:38:14 PM JST

* Mon 09 Sep 2013 12:38:14 PM JST
import os

* Mon 09 Sep 2013 12:39:01 PM JST
  
* Mon 09 Sep 2013 12:39:08 PM JST
;;;###autoload
* Mon 09 Sep 2013 12:40:36 PM JST
MODULES
* Mon 09 Sep 2013 12:41:52 PM JST
will insert strings
* Mon 09 Sep 2013 12:42:02 PM JST
if non-nill then insert string tail of imports block."
* Mon 09 Sep 2013 12:46:40 PM JST

* Mon 09 Sep 2013 12:46:40 PM JST

* Mon 09 Sep 2013 12:46:40 PM JST
;;    set regexp as 

* Mon 09 Sep 2013 12:46:42 PM JST
call
* Mon 09 Sep 2013 12:46:58 PM JST
`py--insert-imports-regexp'
* Mon 09 Sep 2013 01:29:16 PM JST
_sock.
* Mon 09 Sep 2013 01:29:20 PM JST
_sock.
* Mon 09 Sep 2013 01:38:02 PM JST

* Mon 09 Sep 2013 01:38:02 PM JST

* Mon 09 Sep 2013 01:38:02 PM JST
>>> 
* Mon 09 Sep 2013 01:38:58 PM JST

* Mon 09 Sep 2013 01:38:58 PM JST

* Mon 09 Sep 2013 01:38:58 PM JST
>>> 
* Mon 09 Sep 2013 02:30:49 PM JST
>>> from mocker import Mocker, IS
>>> mocker = Mocker()
>>> param = [1, 2, 3]
>>> func = mocker.mock()
>>> func(7, IS(param)) # doctest: +ELLIPSIS
<mocker...
>>> mocker.result(5)
>>> mocker.replay()
>>> func(7, param)
5
>>> mocker.restore()
>>> mocker.verify()

* Mon 09 Sep 2013 02:31:36 PM JST
param
* Mon 09 Sep 2013 02:32:44 PM JST
param
* Mon 09 Sep 2013 02:38:35 PM JST

* Mon 09 Sep 2013 02:38:35 PM JST

* Mon 09 Sep 2013 02:38:35 PM JST
>>> from 
* Mon 09 Sep 2013 02:38:39 PM JST
>>> from mocker import Mocker, IS
>>> mocker = Mocker()

* Mon 09 Sep 2013 02:40:56 PM JST

* Mon 09 Sep 2013 02:40:56 PM JST

* Mon 09 Sep 2013 02:40:56 PM JST
>>> 
* Mon 09 Sep 2013 02:42:50 PM JST

* Mon 09 Sep 2013 02:42:50 PM JST

* Mon 09 Sep 2013 02:42:50 PM JST
>>> 

* Mon 09 Sep 2013 02:45:46 PM JST
>>> func(7, 19)
5

* Mon 09 Sep 2013 02:46:00 PM JST
>>> func(7, 19)
5

* Mon 09 Sep 2013 02:46:19 PM JST
>>> func(7, IN([45, 68, 19])) # doctest: +ELLIPSIS
<mocker...
>>> mocker.result(5)

* Mon 09 Sep 2013 02:46:41 PM JST
>>> func(7, 19)
5

* Mon 09 Sep 2013 02:46:45 PM JST
19
* Mon 09 Sep 2013 02:59:35 PM JST
def is_odd(val):
* Mon 09 Sep 2013 04:21:18 PM JST
>>> 
* Mon 09 Sep 2013 04:45:42 PM JST
mocker
* Mon 09 Sep 2013 04:45:45 PM JST
mocker
* Mon 09 Sep 2013 04:45:47 PM JST
mocker
* Mon 09 Sep 2013 05:24:20 PM JST
>>> mock_time() # doctest: +ELLIPSIS
<mocker...
>>> mocker.result(1.3)

* Mon 09 Sep 2013 05:24:31 PM JST

* Mon 09 Sep 2013 05:24:31 PM JST

* Mon 09 Sep 2013 05:24:31 PM JST
>>> 

* Mon 09 Sep 2013 05:24:33 PM JST
>>> mock_time() # doctest: +ELLIPSIS
<mocker...
>>> mocker.result(2.7)

* Mon 09 Sep 2013 05:25:14 PM JST
>>> '%1.3g' % time()
'1.3'

* Mon 09 Sep 2013 05:29:53 PM JST
>>> from time import time
>>> from mocker import Mocker
>>> mocker = Mocker()
>>> mock_time = mocker.replace('time.time')
>>> mock_time() # doctest: +ELLIPSIS
<mocker...
>>> mocker.result(1.3)
>>> mock_time() # doctest: +ELLIPSIS
<mocker...
>>> mocker.result(2.7)
>>> mock_time() # doctest: +ELLIPSIS
<mocker...
>>> mocker.result(3.12)
>>> mocker.replay()
>>> '%1.3g' % time()
'1.3'
>>> '%1.3g' % time()
'2.7'
>>> '%1.3g' % time()
'3.12'
>>> mocker.restore()
>>> mocker.verify()

* Mon 09 Sep 2013 05:30:04 PM JST
time
* Mon 09 Sep 2013 05:30:08 PM JST
time
* Mon 09 Sep 2013 05:37:08 PM JST
10
* Mon 09 Sep 2013 05:37:54 PM JST

* Mon 09 Sep 2013 05:37:55 PM JST

* Mon 09 Sep 2013 05:37:55 PM JST
>>> mocker.result(1)

* Mon 09 Sep 2013 05:37:58 PM JST

* Mon 09 Sep 2013 05:37:58 PM JST

* Mon 09 Sep 2013 05:37:58 PM JST
1

* Mon 09 Sep 2013 10:21:28 PM JST
linkname
* Mon 09 Sep 2013 10:23:04 PM JST
os.path.join(PATH.get('recipedir')
* Mon 09 Sep 2013 10:23:41 PM JST
os.path.join(
* Mon 09 Sep 2013 10:24:00 PM JST
os.symlink(os.path.join(PATH.get('recipedir'), str(dir_num)),
* Mon 09 Sep 2013 10:24:09 PM JST
os.path.join(PATH.get('recipedir'), linkname))
* Tue 10 Sep 2013 12:24:12 AM JST
image-forward-hscroll
* Tue 10 Sep 2013 12:26:20 AM JST
image-backward-hscroll
* Tue 10 Sep 2013 12:27:03 AM JST
image-next-line
* Tue 10 Sep 2013 12:27:08 AM JST
    
* Tue 10 Sep 2013 12:27:22 AM JST
image-previous-line
* Tue 10 Sep 2013 12:27:36 AM JST
    
* Tue 10 Sep 2013 12:27:49 AM JST
image-next-file
* Tue 10 Sep 2013 12:28:15 AM JST
    
* Tue 10 Sep 2013 12:28:25 AM JST
image-forward-hscroll
* Tue 10 Sep 2013 12:28:39 AM JST
image-backward-hscroll
* Tue 10 Sep 2013 12:28:43 AM JST

* Tue 10 Sep 2013 12:29:34 AM JST
image-next-line
* Tue 10 Sep 2013 12:29:41 AM JST
    
* Tue 10 Sep 2013 01:53:14 AM JST
Maintained
* Tue 10 Sep 2013 01:53:41 AM JST
object
* Tue 10 Sep 2013 01:53:51 AM JST
    def __init__(self, ):
        r"""
        """

* Tue 10 Sep 2013 01:53:52 AM JST

* Tue 10 Sep 2013 01:53:52 AM JST

* Tue 10 Sep 2013 01:53:52 AM JST
    r"""

* Tue 10 Sep 2013 01:53:52 AM JST
    r"""

* Tue 10 Sep 2013 01:53:52 AM JST
    r"""
    """

* Tue 10 Sep 2013 01:57:05 AM JST
TestCase
* Tue 10 Sep 2013 02:00:56 AM JST

* Tue 10 Sep 2013 02:01:12 AM JST

* Tue 10 Sep 2013 11:11:41 AM JST

* Tue 10 Sep 2013 11:11:41 AM JST

* Tue 10 Sep 2013 11:11:42 AM JST
	;; ("\C-x"        'w3m-tab-move-right)

* Tue 10 Sep 2013 11:11:42 AM JST
	;; ("\C-x"        'w3m-tab-move-right)

* Tue 10 Sep 2013 11:11:42 AM JST
	;; ("\C-x"        'w3m-tab-move-right)
	;; ("\C-z"        'w3m-tab-move-left)

* Tue 10 Sep 2013 11:13:40 AM JST
(w3m-next-buffer 1)
* Tue 10 Sep 2013 11:13:49 AM JST
  
* Tue 10 Sep 2013 11:13:54 AM JST
(defsubst my-w3m-next-buffer ()
  (interactive)
  (w3m-next-buffer 1))

* Tue 10 Sep 2013 11:15:28 AM JST
(w3m-goto-url-new-session w3m-home-page)
* Tue 10 Sep 2013 11:15:49 AM JST
session
* Tue 10 Sep 2013 11:15:49 AM JST
new-session
* Tue 10 Sep 2013 11:15:49 AM JST
url-new-session
* Tue 10 Sep 2013 11:16:11 AM JST
(w3m-goto-url-new-session w3m-home-page)
* Tue 10 Sep 2013 11:16:27 AM JST
my-w3m-go-home-page
* Tue 10 Sep 2013 11:17:05 AM JST
my-w3m-next-buffer
* Tue 10 Sep 2013 11:17:25 AM JST
my-w3m-next-buffer
* Tue 10 Sep 2013 11:17:30 AM JST
my-w3m-previous-buffer
* Tue 10 Sep 2013 11:17:35 AM JST
my-w3m-go-home-page
* Tue 10 Sep 2013 11:19:34 AM JST
py--import-statement-end-point
* Tue 10 Sep 2013 11:20:35 AM JST

* Tue 10 Sep 2013 11:20:35 AM JST
   
* Tue 10 Sep 2013 11:20:35 AM JST
   do add history

* Tue 10 Sep 2013 11:22:57 AM JST
history
* Tue 10 Sep 2013 11:23:45 AM JST
command 
* Tue 10 Sep 2013 01:11:32 PM JST
sbp()
* Tue 10 Sep 2013 01:11:51 PM JST

* Tue 10 Sep 2013 01:11:51 PM JST

* Tue 10 Sep 2013 01:11:51 PM JST
from confirm import yesnodialog

* Tue 10 Sep 2013 01:11:58 PM JST

* Tue 10 Sep 2013 01:11:58 PM JST

* Tue 10 Sep 2013 01:11:58 PM JST
import subprocess as sbp

* Tue 10 Sep 2013 01:11:59 PM JST

* Tue 10 Sep 2013 01:11:59 PM JST

* Tue 10 Sep 2013 01:12:00 PM JST
import argparse

* Tue 10 Sep 2013 01:12:02 PM JST

* Tue 10 Sep 2013 01:12:03 PM JST

* Tue 10 Sep 2013 01:12:03 PM JST
import mirror

* Tue 10 Sep 2013 01:12:18 PM JST
import cgitb
cgitb.enable(format='text')


* Tue 10 Sep 2013 01:12:22 PM JST

* Tue 10 Sep 2013 01:12:22 PM JST

* Tue 10 Sep 2013 01:12:22 PM JST
# for debug

* Tue 10 Sep 2013 01:13:03 PM JST
os
* Tue 10 Sep 2013 01:13:06 PM JST
system
* Tue 10 Sep 2013 01:17:45 PM JST
EASYGUI_ABOUT_INFORMATION
* Tue 10 Sep 2013 01:18:53 PM JST
launch
* Tue 10 Sep 2013 01:18:56 PM JST

* Tue 10 Sep 2013 01:18:56 PM JST

* Tue 10 Sep 2013 01:18:56 PM JST
        easygui.msgbox('')

* Tue 10 Sep 2013 01:27:17 PM JST
str()p.output
* Tue 10 Sep 2013 01:27:30 PM JST
[ output if ]
* Tue 10 Sep 2013 01:33:43 PM JST
 + '\n\n' + 
* Tue 10 Sep 2013 01:34:55 PM JST
easyguie
* Tue 10 Sep 2013 03:00:26 PM JST
import os as _os

if 'nt' == _os.name:
    from nt_tunnel import Tunneling, TunnelError

elif 'posix' == _os.name:
    from posix_tunnel import Tunneling, TunnelError


* Tue 10 Sep 2013 03:02:19 PM JST
class AgentUtils(object):
    """
    """
    def haskeyring(self):
        """Check key in agent.
        """
        return self._haskeyring(self._kagiMD5)

    def _haskeyring(self, md5):
        """Check key in agent.
        """
        keys = self.get_keys()
        if not keys == [] and md5 in [x.get_fingerprint() for x in keys]:
            return True
        return False

    def get_keys(self):
        """summary
        """
        return paramiko.Agent().get_keys()

    def add_keys(self):
        """summary
        """
        add_keys(self._kagi)

* Tue 10 Sep 2013 03:03:40 PM JST
__revision__ = "$Revision$"
__version__ = "0.1.1"


* Tue 10 Sep 2013 03:18:47 PM JST
constractor
* Tue 10 Sep 2013 03:18:51 PM JST
constractor
* Tue 10 Sep 2013 03:19:27 PM JST
class Aquos(object):
    """
    """

    def __init__(self, user,  host, port=10000, passwd=None):
        """

        Arguments:
        - `user`:
        - `passwd`:
        - `ip`:
        - `port`:
        """
        self._user = user
        self._host = host
        self._port = port
        self._sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        if not self.login(passwd=passwd):
            raise StandardError
        self._setcommand()

    def login(self, user=None, passwd=None):
        """SUMMARY

        @Arguments:

        - `user`:
        - `passwd`:

        @Return:
        """
        if user is None:
            user = self._user
        if passwd is None:
            passwd = _getpass('Aquos {} password: '.format(user))
        self._sock.connect((self._host, self._port))
        if 'Login:' == self._sock.recv(1024):
            result = self.send(user)
        if 'Password:' == result:
            result = self.send(passwd)
            del passwd
        if 'OK' == result:
            return True
        return False

    def relogin(self, user, passwd):
        """SUMMARY

        @Arguments:

        - `user`:
        - `passwd`:

        @Return:
        """
        self.login(user=user, passwd=passwd)
        self._setcommand()

    def send(self, cmd):
        r"""SUMMARY

        @Arguments:

        - `cmd`:

        @Return:
        """
        if not cmd.endswith('\n'):
            cmd += '\n'
        self._sock.send(cmd)
        return self._sock.recv(1024)

    def _setcommand(self):
        """SUMMARY

        @Return:
        """
        self.power = _POWR(sock=self._sock)
        self.inputtoggle = _ITGD(sock=self._sock)
        self.inputtv = _ITVD(sock=self._sock)
        self.input = _IAVD(sock=self._sock)
        self.inputdegital = _IDEG(sock=self._sock)
        # self.channelBS = _CBSD(sock=self._sock)
        # self.channelCS = _CCSD(sock=self._sock)
        # self.channelTB = _CTBD(sock=self._sock)
        self.channel = _Channel(sock=self._sock)
        self.input4 = _INP4(sock=self._sock)
        self.avposition = _AVMD(sock=self._sock)
        self.volume = _VOLM(sock=self._sock)
        self.horizon = _HPOS(sock=self._sock)
        self.vertical = _VPOS(sock=self._sock)
        self.clock = _CLCK(sock=self._sock)
        self.clockphese = _PHSE(sock=self._sock)
        self.display = _WIDE(sock=self._sock)
        self.mute = _MUTE(sock=self._sock)
        self.audio = _ACHA(sock=self._sock)
        self.offtimer = _OFTM(sock=self._sock)

* Tue 10 Sep 2013 03:19:57 PM JST
socket.
* Tue 10 Sep 2013 03:20:11 PM JST
from socket import _socket
* Tue 10 Sep 2013 03:20:37 PM JST
imp
* Tue 10 Sep 2013 03:21:51 PM JST
class _ConnectAbstract(object):
    """
    """

    def __init__(self, sock):
        """
        """
        self._sock = sock
        self._cmds = globals()[self.__class__.__name__[1:]]

    def _sendcmd(self, cmd):
        """SUMMARY

        @Arguments:

        - `cmd`:

        @Return:
        """
        return self._send(self._getcmd(cmd))

    def _getcmd(self, cmd):
        """SUMMARY

        @Arguments:

        - `cmd`:

        @Return:
        """
        return self._cmds.get(cmd)

    def _send(self, cmd):
        """SUMMARY

        @Arguments:

        - `cmd`:

        @Return:
        """
        self._sock.send(cmd)
        return self._sock.recv(1024)

    def getstatus(self):
        """SUMMARY

        @Return:
        """
        return self._cmds.get('check')


class _POWR(_ConnectAbstract):
    """
    """

    def on(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('on')

    def off(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('off')


class _ITGD(_ConnectAbstract):
    """
    """

    def toggle(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('toggle')


class _ITVD(_ConnectAbstract):
    """
    """

    def tv(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('tv')


class _IAVD(_ConnectAbstract):
    """
    """

    def input(self, num):
        """SUMMARY

        @Arguments:

        - `num`:

        @Return:
        """
        assert 1 <= num <= 5
        self._sendcmd(num)


class _IDEG(_ConnectAbstract):
    """
    """
    def toggle(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('toggle')


class _CBSD(_ConnectAbstract):
    """
    """

    def setchannel(self, num):
        """SUMMARY

        @Arguments:

        - `num`:

        @Return:
        """
        assert 0 <= num <= 999
        self._send(self._cmds.get('format').format(num))


class _CCSD(_ConnectAbstract):
    """
    """

    def setchannel(self, num):
        """SUMMARY

        @Arguments:

        - `num`:

        @Return:
        """
        assert 0 <= num <= 999
        self._send(self._cmds.get('format').format(num))


class _CTSD(_ConnectAbstract):
    """
    """

    def setchannel(self, num):
        """SUMMARY

        @Arguments:

        - `num`:

        @Return:
        """
        assert 0 <= num <= 999
        self._send(self._cmds.get('format').format(num))


class _CHUP(_ConnectAbstract):
    """
    """

    def up(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('up')


class _CHDW(_ConnectAbstract):
    """
    """

    def down(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('down')


class _INP4(_ConnectAbstract):
    """
    """

    def auto(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd(0)

    def d_plug(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd(1)

    def video_plug(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd(4)


class _AVMD(_ConnectAbstract):
    """
    """

    def toggle(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('toggle')

    def standard(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('standard')

    def movie(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('movie')

    def game(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('game')

    def avmemory(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('avmemory')

    def static_dynamic(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('static_dynamic')

    def dynamic(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('dynamic')

    def pc(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('pc')


class _VOLM(_ConnectAbstract):
    """
    """

    def setvolume(self, num):
        """SUMMARY

        @Arguments:

        - `num`:

        @Return:
        """
        assert 0 <= num <= 100
        self._send(self._cmds.get('format').format(num))


class _HPOS(_ConnectAbstract):
    """
    """
    pass


class _VPOS(_ConnectAbstract):
    """
    """
    pass


class _CLCK(_ConnectAbstract):
    """
    """
    pass


class _PHSE(_ConnectAbstract):
    """
    """
    pass


class _WIDE(_ConnectAbstract):
    """
    """
    def toggle(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('toggle')

    def normal(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('smartzoom')

    def wide43(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('wide4:3')

    def cinema(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('cinema')

    def full(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('full')

    def full1(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('full1')

    def full2(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('full2')

    def underscan(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('underscan')

    def dot_by_dot(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('dot_by_dot')

    def wide169(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('wide:16:9')


class _MUTE(_ConnectAbstract):
    """
    """
    def toggle(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd(0)

    def on(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd(1)

    def off(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd(0)


class _ACHA(_ConnectAbstract):
    """
    """

    def toggle(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('toggle')


class _OFTM(_ConnectAbstract):
    """
    """

    def reset(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('reset')

    def min30(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('30min')

    def h1(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('1h')

    def h1min30(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('1h30min')

    def h2(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('2h')

    def h2min30(self):
        """SUMMARY

        @Return:
        """
        self._sendcmd('2h30min')


class _Channel(object):
    """
    """

    def __init__(self, sock):
        """
        """
        self._sock = sock
        self._channelup = _CHUP(sock=self._sock)
        self._channeldw = _CHDW(sock=self._sock)
        self.BS = _CBSD(sock=self._sock)
        self.CS = _CCSD(sock=self._sock)
        self.CT = _CTBD(sock=self._sock)

    def up(self):
        """SUMMARY

        @Return:
        """
        self._channelup.up()

    def down(self):
        """SUMMARY

        @Return:
        """
        self._channeldw.down()


* Tue 10 Sep 2013 03:25:30 PM JST
A_PART_CMDS = ['POWR', 'ITGD', 'ITVD', 'IAVD', 'IDEG', 'CBSD', 'CCSD', 'CTBD',
              'CHUP', 'CHDW', 'INP4', 'AVMD', 'VOLM', 'HPOS', 'VPOS', 'CLCK',
              'PHSE', 'WIDE', 'MUTE', 'ACSU', 'ACHA', 'OFTM']

# make each command format and set check '?' command
CMD_FORMATS = {}
for cmd in A_PART_CMDS:
    CMD_FORMATS[cmd] = cmd + '{0: <4}\n'
    globals()[cmd] = {'check': CMD_FORMATS.get(cmd).format('?')}

# POWR
for key, Bpart in [('on', 1), ('off', 0)]:
    POWR[key] = CMD_FORMATS.get('POWR').format(Bpart)

# ITGD
ITGD['toggle'] = CMD_FORMATS.get('ITGD').format(' ')

# ITVD
ITVD['tv'] = CMD_FORMATS.get('ITVD').format(' ')

# IAVD
for i in range(1, 6):
    IAVD[i] = CMD_FORMATS.get('IAVD').format(i)

# IDEG
IDEG['toggle'] = CMD_FORMATS.get('IDEG').format(' ')

# CBSD
CBSD['format'] = CMD_FORMATS.get('CBSD')

# CCSD
CCSD['format'] = CMD_FORMATS.get('CCSD')

# CTBD
CTBD['format'] = CMD_FORMATS.get('CTBD')

# CHUP
CHUP['up'] = CMD_FORMATS.get('CHUP').format(' ')

# CHDW
CHDW['down'] = CMD_FORMATS.get('CHDW').format(' ')

# INP4
for key, Bpart in [('auto', 0), ('Dbus', 1), ('video', 4)]:
    INP4[key] = CMD_FORMATS.get('INP4').format(Bpart)

# AVMD
AVMD['photo'] = 11
for Bpart, key in enumerate(['toggle', 'standard', 'movie', 'game', 'avmemory',
                     'static dynamic', 'dynamic', 'pc']):
    AVMD[key] = CMD_FORMATS.get('AVMD').format(Bpart)

# VOLM
VOLM['format'] = CMD_FORMATS.get('VOLM')

# HPOS
HPOS['format'] = CMD_FORMATS.get('HPOS')

# VPOS
VPOS['format'] = CMD_FORMATS.get('VPOS')

# CLCK
CLCK['format'] = CMD_FORMATS.get('CLCK')

# PHSE
PHSE['format'] = CMD_FORMATS.get('PHSE')

# WIDE
for Bpart, key in enumerate(['toggle', 'normal', 'smartzoom', 'wide4:3',
                             'cinema', 'full', 'full1', 'full2', 'underscan',
                             'dot_by_dot', 'wide16:9']):
    WIDE[key] = CMD_FORMATS.get('WIDE').format(Bpart)

# MUTE
for Bpart, key in enumerate(['toggle', 'on', 'off']):
    MUTE[key] = CMD_FORMATS.get('MUTE').format(Bpart)

# ACSU
for Bpart, key in enumerate(['toggle', 'on', 'off', 'auto']):
    ACSU[key] = CMD_FORMATS.get('ACSU').format(Bpart)

# ACHA
ACHA['toggle'] = CMD_FORMATS.get('ACHA').format(' ')

# OFTM
for Bpart, key in enumerate(['reset', '30min', '1h', '1h30min',
                             '2h', '2h30min']):
    OFTM[key] = CMD_FORMATS.get('OFTM').format(Bpart)

* Tue 10 Sep 2013 03:26:33 PM JST

* Tue 10 Sep 2013 03:26:33 PM JST

* Tue 10 Sep 2013 03:26:33 PM JST
# ITGD

* Tue 10 Sep 2013 03:26:34 PM JST

* Tue 10 Sep 2013 03:26:34 PM JST

* Tue 10 Sep 2013 03:26:34 PM JST
# ITVD

* Tue 10 Sep 2013 03:26:39 PM JST

* Tue 10 Sep 2013 03:26:39 PM JST

* Tue 10 Sep 2013 03:26:39 PM JST
# IDEG

* Tue 10 Sep 2013 03:26:39 PM JST

* Tue 10 Sep 2013 03:26:40 PM JST

* Tue 10 Sep 2013 03:26:40 PM JST
# CBSD

* Tue 10 Sep 2013 03:26:41 PM JST

* Tue 10 Sep 2013 03:26:41 PM JST

* Tue 10 Sep 2013 03:26:41 PM JST
# CCSD

* Tue 10 Sep 2013 03:26:43 PM JST

* Tue 10 Sep 2013 03:26:43 PM JST

* Tue 10 Sep 2013 03:26:43 PM JST
# CTBD

* Tue 10 Sep 2013 03:26:44 PM JST

* Tue 10 Sep 2013 03:26:44 PM JST

* Tue 10 Sep 2013 03:26:44 PM JST
# CHUP

* Tue 10 Sep 2013 03:26:45 PM JST

* Tue 10 Sep 2013 03:26:45 PM JST

* Tue 10 Sep 2013 03:26:45 PM JST
# CHDW

* Tue 10 Sep 2013 03:26:52 PM JST

* Tue 10 Sep 2013 03:26:52 PM JST

* Tue 10 Sep 2013 03:26:52 PM JST
# VOLM

* Tue 10 Sep 2013 03:26:54 PM JST

* Tue 10 Sep 2013 03:26:54 PM JST

* Tue 10 Sep 2013 03:26:54 PM JST
# HPOS

* Tue 10 Sep 2013 03:26:55 PM JST

* Tue 10 Sep 2013 03:26:55 PM JST

* Tue 10 Sep 2013 03:26:55 PM JST
# VPOS

* Tue 10 Sep 2013 03:26:56 PM JST

* Tue 10 Sep 2013 03:26:56 PM JST

* Tue 10 Sep 2013 03:26:56 PM JST
# CLCK

* Tue 10 Sep 2013 03:26:57 PM JST

* Tue 10 Sep 2013 03:26:57 PM JST

* Tue 10 Sep 2013 03:26:57 PM JST
# PHSE

* Tue 10 Sep 2013 03:27:01 PM JST

* Tue 10 Sep 2013 03:27:01 PM JST

* Tue 10 Sep 2013 03:27:01 PM JST
# ACHA

* Tue 10 Sep 2013 03:27:13 PM JST

* Tue 10 Sep 2013 03:27:13 PM JST

* Tue 10 Sep 2013 03:27:13 PM JST
import sys as _sys

* Tue 10 Sep 2013 03:32:01 PM JST

* Tue 10 Sep 2013 03:32:01 PM JST

* Tue 10 Sep 2013 03:32:01 PM JST
all = ['A_PART_CMDS', 'CMD_FORMATS']

* Tue 10 Sep 2013 03:32:22 PM JST
A_PART_CMDS
* Tue 10 Sep 2013 04:07:26 PM JST


* Tue 10 Sep 2013 04:07:29 PM JST
MCD
* Tue 10 Sep 2013 04:12:34 PM JST
{'check': FORMATS.get(cmd).format('?')}
* Tue 10 Sep 2013 04:18:16 PM JST

* Tue 10 Sep 2013 04:18:16 PM JST

* Tue 10 Sep 2013 04:18:16 PM JST
CMDS['CBSD']['format'] = FORMATS.get('CBSD')

* Tue 10 Sep 2013 04:18:16 PM JST
CMDS['CBSD']['format'] = FORMATS.get('CBSD')

* Tue 10 Sep 2013 04:18:16 PM JST
CMDS['CBSD']['format'] = FORMATS.get('CBSD')
CMDS['CCSD']['format'] = FORMATS.get('CCSD')

* Tue 10 Sep 2013 04:18:17 PM JST
CMDS['CBSD']['format'] = FORMATS.get('CBSD')
CMDS['CCSD']['format'] = FORMATS.get('CCSD')

* Tue 10 Sep 2013 04:18:17 PM JST
CMDS['CBSD']['format'] = FORMATS.get('CBSD')
CMDS['CCSD']['format'] = FORMATS.get('CCSD')
CMDS['CTBD']['format'] = FORMATS.get('CTBD')

* Tue 10 Sep 2013 04:18:21 PM JST

* Tue 10 Sep 2013 04:18:22 PM JST

* Tue 10 Sep 2013 04:18:22 PM JST
CMDS['VOLM']['format'] = FORMATS.get('VOLM')

* Tue 10 Sep 2013 04:18:22 PM JST
CMDS['VOLM']['format'] = FORMATS.get('VOLM')

* Tue 10 Sep 2013 04:18:22 PM JST
CMDS['VOLM']['format'] = FORMATS.get('VOLM')
CMDS['HPOS']['format'] = FORMATS.get('HPOS')

* Tue 10 Sep 2013 04:18:22 PM JST
CMDS['VOLM']['format'] = FORMATS.get('VOLM')
CMDS['HPOS']['format'] = FORMATS.get('HPOS')

* Tue 10 Sep 2013 04:18:22 PM JST
CMDS['VOLM']['format'] = FORMATS.get('VOLM')
CMDS['HPOS']['format'] = FORMATS.get('HPOS')
CMDS['VPOS']['format'] = FORMATS.get('VPOS')

* Tue 10 Sep 2013 04:18:22 PM JST
CMDS['VOLM']['format'] = FORMATS.get('VOLM')
CMDS['HPOS']['format'] = FORMATS.get('HPOS')
CMDS['VPOS']['format'] = FORMATS.get('VPOS')

* Tue 10 Sep 2013 04:18:22 PM JST
CMDS['VOLM']['format'] = FORMATS.get('VOLM')
CMDS['HPOS']['format'] = FORMATS.get('HPOS')
CMDS['VPOS']['format'] = FORMATS.get('VPOS')
CMDS['CLCK']['format'] = FORMATS.get('CLCK')

* Tue 10 Sep 2013 04:18:22 PM JST
CMDS['VOLM']['format'] = FORMATS.get('VOLM')
CMDS['HPOS']['format'] = FORMATS.get('HPOS')
CMDS['VPOS']['format'] = FORMATS.get('VPOS')
CMDS['CLCK']['format'] = FORMATS.get('CLCK')

* Tue 10 Sep 2013 04:18:22 PM JST
CMDS['VOLM']['format'] = FORMATS.get('VOLM')
CMDS['HPOS']['format'] = FORMATS.get('HPOS')
CMDS['VPOS']['format'] = FORMATS.get('VPOS')
CMDS['CLCK']['format'] = FORMATS.get('CLCK')
CMDS['PHSE']['format'] = FORMATS.get('PHSE')

* Tue 10 Sep 2013 04:24:58 PM JST
 #+ APART_NAMES
* Tue 10 Sep 2013 04:25:01 PM JST

* Tue 10 Sep 2013 04:25:01 PM JST

* Tue 10 Sep 2013 04:25:01 PM JST
    # globals()[cmd] = {'check': FORMATS.get(cmd).format('?')}

* Tue 10 Sep 2013 04:26:20 PM JST
globals()
* Tue 10 Sep 2013 04:27:31 PM JST

* Tue 10 Sep 2013 04:38:03 PM JST

* Tue 10 Sep 2013 04:38:03 PM JST

* Tue 10 Sep 2013 04:38:03 PM JST
__all__ = [ 'FORMATS', 'CMDS', 'APART_NAMES', 'Aquos']

* Tue 10 Sep 2013 04:45:19 PM JST
# for debug
import cgitb as _cgitb
_cgitb.enable(format='text')


* Tue 10 Sep 2013 04:47:05 PM JST
class CmdMissingError(Exception):
    pass

* Tue 10 Sep 2013 05:21:55 PM JST
import os as _os
import sys as _sys
import logging as _logging
import shutil as _shutil
import subprocess as _sbp

from glob import glob as _glob
from datetime import date as _date

from ref import CMD

# for debug
import cgitb as _cgitb
_cgitb.enable(format='text')


__revision__ = '$Revision$'
__version__ = '0.1.0'


class CmdMissingError(Exception):
    pass


link_dest = '--link-dest='

DATE_FORMAT_DEFAULT = '%Y%m%d'

EXCLUDE_DEFALUT = ['/lost+found',
                   '/sys/*',
                   '/dev/*',
                   '/proc/*',
                   '/run/*',
                   '/tmp/*',
                   '/share/*',
                   '/media/*',
                   '/mnt/*',
                   '/var/run/*',
                   '/var/lock/*',
                   '/lib/udev/devices/console',
                   '/lib/udev/devices/loop0',
                   '/lib/udev/devices/null',
                   '/lib/udev/devices/ppp',
                   '/lib/udev/devices/net/tun',
                   '/lib/modules/*/volatile/.mounted',
                   '/data/*',
                   '/etc/fstab',
                   '/etc/crypttab',
                   '/var/cache/apt/archive/*',
                   '/home/*/.mozilla/firefox/*.default/Cache/*',
                   '/home/*/.cache/google-chrome/Default/*',
                   '/root/.mozilla/firefox/*.default/Cache/*',
                   '/root/.cache/google-chrome/Default/*',
                   '/root/.local/share/Trash/files/*',
                   '/root/.local/share/Trash/info/*',
                   ]

def add2list(list_, additions):
    """SUMMARY



    @Arguments:

    - `list_`:
    - `additions`:

    @Return: unique list
    """
    from types import StringType, ListType
    if type(additions) == StringType:
        list_.append(additions)
    elif type(additions) == ListType:
        list_ += additions
    else:
        raise ValueError('Set only string or list type.'
                         '\nYou setted {0}'.format(type(additions)))
    return list(set(list_))




class LinkDestLocalBackup(object):
    """
    """
    _datefmt = '%Y%m%d'
    _full_ext = '.full'
    _incr_ext = '.incr'
    _opt = ['-a']
    _link_dest = '--link-dest='
    _excludes = EXCLUDE_DEFALUT
    _lotate_max = 30
    _log = _logging
    _bkupname = ''
    _bkupmethod = ''
    _bkupfullpath = ''
    _linkname = 'latest'
    _linkrealpath = ''

    def __init__(self, src, bkupdir, lotate=False, logname=None):
        """

        Arguments:
        - `src`:
        - `dest`:
        """
        if logname:
            self._log.basicConfig(filename=_os.path.join('/var/log', logname),
                                    level=_logging.DEBUG,
                                    format='%(asctime)s %(message)s')
        else:
            self._log = None

        self.src = src
        self.bkupdir = bkupdir
        self._lotate = lotate

        # for v in [src, dest]:
            # if not _os.path.exists(v):
                # raise ValueError('{0} does not exists'.format(v))

    def add_exclude(self, ext):
        """SUMMARY

        @Arguments:

        - `ext`:

        @Return:
        """
        self._excludes = add2list(self._excludes, ext)

    def add_opt(self, opt):
        """SUMMARY

        @Arguments:

        - `opt`:

        @Return:
        """
        self._opt = add2list(self._opt, opt)

    def backup(self):
        """SUMMARY

        @Return:
        """
        if self.bkupmethod == self._incr_ext:
            if self._log:
                self._log.log(10, 'Start: Incremental Backup')
            self.lotate()
            self.incrementalbackup()
        else: # full backup
            if self._log:
                self._log.log(10, 'Start: Full Backup')
            self.fullbackup()
        self.makelink()

    def fullbackup(self):
        """SUMMARY

        @Return:
        """
        self._backup()

    def incrementalbackup(self):
        """SUMMARY

        @Return:
        """
        if -1 == ''.join(self._opt).find('--link-dest='):
            self._opt.append('--link-dest=' + self.linkrealpath)
        self._backup()

    def _backup(self):
        """SUMMARY

        @Return:
        """
        cmdline = self.cmdline
        print(cmdline)
        if self._log:
            self._log.log(10, 'Execute: '.format(cmdline))
        try:
            _sbp.check_call(cmdline, shell=True)
        except _sbp.CalledProcessError:
            _sys.exit(1)

    @property
    def cmdline(self):
        """SUMMARY

        @Return:
        """
        return ' '.join([CMD.get('rsync')] + [self.options] +
                        [self.src, self.bkupfullpath])

    @property
    def options(self):
        """SUMMARY

        @Return:
        """
        return ' '.join(self._opt + [self.excludes])

    @property
    def excludes(self):
        """SUMMARY

        @Return:
        """
        return ' '.join(['--exclude=' + x for x in self._excludes])

    @property
    def bkupfullpath(self):
        """SUMMARY

        @Return:
        """
        if not self._bkupfullpath:
            self._bkupfullpath = _os.path.join(self.bkupdir, self.bkupname)
        return self._bkupfullpath

    @property
    def bkupname(self):
        """SUMMARY

        @Return:
        """
        if not self._bkupname:
            self._bkupname = _date.today().strftime(self._datefmt)
            self._bkupname += self.bkupmethod
        return self._bkupname

    @property
    def linkrealpath(self):
        """SUMMARY

        @Return:
        """
        if not self._linkrealpath:
            self._linkrealpath = _os.path.realpath(
                _os.path.join(self.bkupdir, self._linkname))
        return self._linkrealpath

    @property
    def bkupmethod(self):

        """SUMMARY

        @Return:
        """
        if not self._bkupmethod:
            if self._isfullexists():
                self._bkupmethod = self._incr_ext
            else:
                self._bkupmethod = self._full_ext
        return self._bkupmethod


    def _isfullexists(self):
        """SUMMARY

        @Return:
        """
        return self._globbkupdir('*' + self._full_ext) != []

    def _globbkupdir(self, str_):
        """SUMMARY

        @Arguments:

        - `str_`:

        @Return:
        """
        return _glob(_os.path.join(self.bkupdir, str_))

    def lotate(self):
        """SUMMARY

        @Return:
        """
        if not self._lotate:
            return
        globs = self._globbkupdir(self._incr_ext)
        while self._lotate_max <= len(globs):
            oldest = globs.sort().pop(0)
            if self._log:
                self._log.log(10, 'Lotate: Removed {0}'.format(oldest))
            _shutil.rmtree(oldest)

    def makelink(self):
        """SUMMARY

        @Return:
        """
        latestfullpath = _os.path.join(self.bkupdir, self._linkname)
        if _os.path.islink(latestfullpath):
            _os.unlink(latestfullpath)
        cmdline = [CMD.get('ln'), '-s', self._bkupfullpath, latestfullpath]
        print(' '.join(cmdline))
        if self._log:
            self._log.log(10, 'Link: {0}'.format(' '.join(cmdline)))
        _sbp.call(cmdline)
        if _os.path.islink(latestfullpath):
            self._log.log(10, 'Link: {0}'.format('OK exists'))


class LinkDestRemoteBackup(LinkDestLocalBackup):
    """
    """
    _mntpoint = '/mnt/sshfs'

    def __init__(self, src, bkupdir, rname, lotate=False, logname=None):
        """
        """
        self.src = src
        self.rname = rname
        self.bkupdir = bkupdir
        self.lbkupdir = self._mntpoint
        self.rbkupdir = self.rname + ':' + self.bkupdir
        self.linkpath = _os.path.join(self.bkupdir, self._linkname)
        self._lotate = lotate
        if logname:
            self._log = _logging.basicConfig(
                filename=_os.path.join('/var/log', logname),
                level=_logging.DEBUG,
                format='%(asctime)s %(message)s')
        else:
            self._log = None

    def backup(self):
        """SUMMARY

        @Return:
        """
        self._sshfs()
        if self.bkupmethod == self._incr_ext:
            if self._log:
                self._log.log(10, 'Start: Incremental Backup')
            self.lotate()
            self.incrementalbackup()
        else: # full buckup
            if self._log:
                self._log.log(10, 'Start: Full Backup')
            self.fullbackup()
        self.makelink()

    def restore(self):
        """SUMMARY

        @Return:
        """
        self.add_opt(['-z', '-v'])
        cmdline = ' '.join([CMD.get('rsync')] + ['--delete', '--force'] +
                           [self.options] +
                           [self.rname + ':' + self.linkpath + '/'] +
                           ['/'])
        _sbp.check_call(cmdline, shell=True)

    @property
    def linkrealpath(self):
        """SUMMARY

        @Return:
        """
        if not self._linkrealpath:
            self._linkrealpath = _os.path.realpath(
                _os.path.join(self.lbkupdir, self._linkname))
        return self._linkrealpath

    @property
    def cmdline(self):
        """SUMMARY

        @Return:
        """
        return ' '.join([CMD.get('rsync')] + [self.options] +
                        [self.src, self.rname + ':' + self.bkupfullpath])

    def _globbkupdir(self, str_):
        """SUMMARY

        @Arguments:

        - `str_`:

        @Return:
        """
        return _glob(_os.path.join(self.lbkupdir, str_))

    def lotate(self):
        """SUMMARY

        @Return:
        """
        pass

    def makelink(self):
        """SUMMARY

        @Return:
        """
        # delete link
        linklocalfullpath = _os.path.join(self.lbkupdir, self._linkname)
        if _os.path.islink(linklocalfullpath):
            _os.unlink(linklocalfullpath)
        # make link
        cmdline = ['ssh', self.rname, "'" + CMD.get('ln'),
                         '-s', self.bkupfullpath,
                         _os.path.join(self.bkupdir, self._linkname) + "'"]
        if self._log:
            self._log.log(10, 'Link: {0}'.format(' '.join(cmdline)))
        print(' '.join(cmdline))
        _sbp.check_call([' '.join(cmdline)], shell=True)

    def _sshfs(self):
        """SUMMARY

        @Return:
        """
        if _os.path.ismount('/mnt'):
            _sbp.Popen([CMD.get('umount'), '/mnt'])
        if _os.path.ismount(self._mntpoint):
            _sbp.Popen([CMD.get('umount'), self._mntpoint])
        if not _os.path.exists(self._mntpoint):
            _os.mkdir(self._mntpoint)
        _sbp.check_call([CMD.get('sshfs'), self.rbkupdir, self._mntpoint])

    def __exit__(self):
        """SUMMARY

        @Return:
        """
        for command, location in [('umount', self._mntpoint),
                              ('rmdir', self._mntpoint)]:
            try:
                _sbp.Popen([CMD.get(command), location])
            except:
                pass


def test():
    pass


if __name__ == '__main__':
    test()


# For Emacs
# Local Variables:
# coding: utf-8
# End:
# RsyncBackup.py ends here

* Tue 10 Sep 2013 05:24:58 PM JST
import sys

__revision__ = "$Revision$"
__version__ = "0.1.0"

__all__ = ['confirm', 'sys']


def confirm(prompt='Confirm'):
    """Yes or No prompt."""
    prompt = '%s "y" or "n": ' % (prompt)
    yes = ['y', 'Y', 'yes', 'YES']
    nop = ['n', 'N', 'no', 'NO']
    yesnop = yes + nop
    while 1:
        ans = raw_input(prompt)
        if not ans or ans not in yesnop:
            print "Set input " + ", ".join(yesnop)
            continue
        if ans in yes:
            return True
        if ans in nop:
            return False

def yesno(text='\rPlease enter yes/no[y/n]: '):
    """Yes No prompt.

    @Arguments:
    - `text`:

    @Return:
    yes = True
    no = False
    """
    while 1:
        sys.stdout.write(text)
        query = raw_input().lower()
        if 'y' == query[0]:
            return True
        if 'n' == query[0]:
            return False

def wait_enter(text='\rPlease enter: '):
    """SUMMARY

    @Arguments:
    - `text`:

    @Return:
    """
    sys.stdout.write(text)
    raw_input()
    return

def yesnodialog(title, message):
    """SUMMARY

    @Arguments:
    - `title`:
    - `message`:

    @Return:
    """
    import Tkinter
    import tkMessageBox
    root = Tkinter.Tk()
    root.withdraw()
    return tkMessageBox.askyesno(title, message)

* Tue 10 Sep 2013 05:25:15 PM JST

* Tue 10 Sep 2013 05:25:15 PM JST

* Tue 10 Sep 2013 05:25:15 PM JST
__all__ = [ '' ]

* Tue 10 Sep 2013 05:30:26 PM JST
# for debug
import cgitb as _cgitb
_cgitb.enable(format='text')


* Tue 10 Sep 2013 05:30:56 PM JST
""" googlechrome -- handling for google chrome.

Changelog:
inpremented iterator `ChromeMBParse`

$Revision$

"""


import os as _os
import re as _re
from ref.regexp import _REGEXP

# for debug
import cgitb as _cgitb
_cgitb.enable(format='text')


__revision__ = '$Revision$'
__version__ = '0.2.0'


if _os.name in ['posix', 'java']:
    BOOKMARK_BASE_PATH = '~/.config/google-chrome/Default/Bookmarks'
    BOOKMARK_PATH = _os.path.expanduser(BOOKMARK_BASE_PATH)

elif 'nt' == _os.name:
    BOOKMARK_BASE_PATH = (
'Local Settings/Application Data/Google/Chrome/User Data/Default/Bookmarks')
    BOOKMARK_PATH = _os.path.join(_os.environ['userprofile'], BOOKMARK_BASE_PATH)


def trim_url(url):
    """Triming urls by regexp.

    @Arguments:
    - `urls`: list of urls

    @Return: list of trimed urls
    """
    result = _re.compile(_REGEXP.get('http')).search(url)
    if not result is None:
        return result.group()
    return None


class ExistsNameError(Exception):
    pass


class ChromeBMParse(object):
    """
    """

    def __init__(self, name, bmpath=BOOKMARK_PATH):
        """

        Arguments:
        - `bkmk_path`:
        """
        self._name = name
        self._bmpath = bmpath
        self._file = open(self._bmpath, 'r')
        self._lines = self._file.readlines()
        self.line_num = 0
        self._getline_num()
        self._mvblockend()

    def __iter__(self):
        """SUMMARY

        @Return:
        """
        return self

    def _getline_num(self):
        """Determine line number of name.

        @Arguments:

        - `name`: elements name

        @Return: line number
        """
        self._file.seek(0)
        for num, line in enumerate(self._file):
            if '"name":' in line:
                trimed = line.split('"name":')[1].split('"')[1]
                if self._name == trimed.decode('unicode-escape', 'ignore'):
                    self.line_num = num - 1
        if 0 == self.line_num:
            raise ExistsNameError(
                'Not exists bookmarks folder "{}"'.format(self._name))

    def _mvblockend(self):
        """Move initialize line.

        @Return: Nothing
        """
        while -1 == self._lines[self.line_num].find(']') and self.line_num != 0:
            self.line_num -= 1

    def next(self):
        """Parse urls"""
        operand = -1
        while operand < 0:
            self.line_num -= 1
            if self._lines[self.line_num].find('}') != -1:
                operand -= 1
            if self._lines[self.line_num].find('{') != -1:
                operand += 1
            if operand == -1:
                if self._lines[self.line_num].find('"url":') != -1:
                    result = trim_url(self._lines[self.line_num])
                    if result:
                        return result
        raise StopIteration

    def __del__(self):
        """Close opened file when deconstract."""
        self._file.close()


def get_urls(name):
    """SUMMARY

    @Arguments:
    - `name`:

    @Return:
    """
    g = ChromeBMParse(name)
    urls = []
    for u in g:
        urls.append(u)
    return urls


def test():
    pass


if __name__ == '__main__':
    test()


* Tue 10 Sep 2013 08:52:02 PM JST
window 
* Tue 10 Sep 2013 08:52:02 PM JST
opening window 
* Tue 10 Sep 2013 08:54:36 PM JST
enable 
* Tue 10 Sep 2013 08:55:02 PM JST
window
* Wed 11 Sep 2013 02:05:43 PM JST
"""
$Revision: 380 $
$LastChangedRevision: 380 $
$LastChangedDate: 2012-08-07 21:43:00 +0900 (Tue, 07 Aug 2012) $

sleep_progress.py

Countdown progress
"""

import sys, time

def sleep_progress(sec, strformat='Waiting %d'):
    """sleeping progress

    Arguments:
    - `time`:
    """
    sec = int(sec)
    # if 0 == sec:
        # sys.exit("Do not set {0}".format(sec))

    for remaining in range(sec, -1, -1):
        sys.stdout.write('\r')
        sys.stdout.write(strformat % remaining)
        sys.stdout.flush()
        time.sleep(1)

    sys.stdout.write("\n")
    sys.stdout.flush()

* Wed 11 Sep 2013 02:05:53 PM JST
"""
$Revision: 380 $
$LastChangedRevision: 380 $
$LastChangedDate: 2012-08-07 21:43:00 +0900 (Tue, 07 Aug 2012) $

sleep_progress.py

Countdown progress
"""

* Wed 11 Sep 2013 02:08:10 PM JST
""" whatismyip -- check my global ip

$Revision$

"""


import urllib
import random
import re

__version__ = '1.0'

ip_regex = re.compile("(([0-9]{1,3}\.){3}[0-9]{1,3})")


def whatismyip():
    ''' Returns your public IP address.
        Output: The IP address in string format.
                None if not internet connection available.
    '''
    # List of host which return the public IP address:
    hosts = ['http://www.whatismyip.com/',
             'http://adresseip.com',
             'http://www.aboutmyip.com/',
             'http://www.ipchicken.com/',
             'http://www.showmyip.com/',
             'http://monip.net/',
             'http://checkrealip.com/',
             'http://ipcheck.rehbein.net/',
             'http://checkmyip.com/',
             'http://www.raffar.com/checkip/',
             'http://www.thisip.org/',
             'http://www.lawrencegoetz.com/programs/ipinfo/',
             'http://www.mantacore.se/whoami/',
             'http://www.edpsciences.org/htbin/ipaddress',
             'http://mwburden.com/cgi-bin/getipaddr',
             'http://checkipaddress.com/',
             'http://www.glowhost.com/support/your.ip.php',
             'http://www.tanziars.com/',
             'http://www.naumann-net.org/',
             'http://www.godwiz.com/',
             'http://checkip.eurodyndns.org/',]
    for i in range(3):
        host = random.choice(hosts)

        try:
            results = ip_regex.findall(urllib.urlopen(host).read(200000))
            assert isinstance(results, object)
            if results:
                return results[0][0]
        except:
            pass # Let's try another host
    return None


def _main():
    print(whatismyip())

if __name__ == '__main__':
    _main()

* Wed 11 Sep 2013 02:10:41 PM JST
import types

from lxmllib import lxml_soup

__revision__ = '$Revision$'
__version__ = '0.1.0'

def feed_finder(url, cache=True, verbose=False):
    """SUMMARY

    @Arguments:
    - `doc`:

    @Return:
    """
    assert type(url) is types.StringType, "'url' is must be a strings"

    feed_link = []

    doc = lxml_soup(url, cache, verbose=verbose)
    el = doc.xpath('//link[@rel="alternate"][contains(@type, "rss")'
                   ' or contains(@type, "atom") or contains(@type, "rdf")]')
    if el:
        for e in el:
            feed_link.append(e.attrib['href'])
    else:
        extensions = ['.rss', '.xml', '.rdf']
        a = doc.xpath('//a')
        for el in a:
            link = ''
            try:
                if el.attrib.has_key('href'):
                    link = el.attrib['href']
            except KeyError:
                continue
            for ext in extensions:
                if link and link.endswith(ext):
                    feed_link.append(link)
    return feed_link

* Wed 11 Sep 2013 02:10:49 PM JST

import types

from lxmllib import lxml_soup

__revision__ = '$Revision$'
__version__ = '0.1.0'

* Wed 11 Sep 2013 02:13:16 PM JST
import os
import urllib2

import lxml.html

from portable import DRIVE
from ref.url import URLS


proxy_file = DRIVE + '\\system\\FRDPortable\\proxy.txt'


def parse_pxurl(url):
    """Generator for get proxy list from url.

    Arguments:
    - `url`:
    """
    html = urllib2.urlopen(url).read()
    root = lxml.html.fromstring(html)
    anchors = root.xpath('//a')
    for anchor in anchors:
        if type(anchor.text) is str:
            if '.' in anchor.text and ':' in anchor.text:
                yield anchor.text


def _main():
    # force delete
    try:
        os.remove(proxy_file)
    except WindowsError:
        pass
    lis = parse_pxurl(URLS['proxy']['anonymous'])
    with open(proxy_file, 'w') as f:
        f.write('\n'.join(lis))

if __name__ == '__main__':
    _main()

* Wed 11 Sep 2013 02:14:34 PM JST
_DRIVE
* Wed 11 Sep 2013 02:17:00 PM JST
"""
$Revision: 380 $
$LastChangedRevision: 380 $
$LastChangedDate: 2012-08-07 21:43:00 +0900 (Tue, 07 Aug 2012) $

Program Name get_confirm_pass.py


Get password user input 2 times.
"""
from getpass import getpass


def getcmfpass(msg='Password: ', leng=0):
    """
    Get Password user input 2 times and confirm

    Arguments:
    - `leng`: Password length of the minimum.

    """
    for i in range(3):
        pass1 = getpass(msg)
        pass2 = getpass("Confirm: ")
        if pass1 == pass2:
            pass2 = None
            if len(pass1) == 0:
                print "Not set password!!\n"
                continue
            if 0 < leng and len(pass1) <= leng:
                print "Too short!! Set more long password!!\n"
                continue
            return pass1
        print ""

* Wed 11 Sep 2013 02:17:06 PM JST
"""
$Revision: 380 $
$LastChangedRevision: 380 $
$LastChangedDate: 2012-08-07 21:43:00 +0900 (Tue, 07 Aug 2012) $

Program Name get_confirm_pass.py


Get password user input 2 times.
"""

* Wed 11 Sep 2013 02:17:14 PM JST

* Wed 11 Sep 2013 02:17:14 PM JST

* Wed 11 Sep 2013 02:17:14 PM JST
from getpass import getpass

* Wed 11 Sep 2013 02:19:11 PM JST
from time import sleep
import os
import urllib2
import tempfile
import datetime
import contextlib
import urlparse

import lxml.html
from sleep_progress import sleep_progress


__revision__ = '$Revision$'
__version__ = '0.1.0'

def _get_html_filename(url):
    """SUMMARY

    @Arguments:
    - `url`:

    @Return:
    """
    if url.endswith('/'):
        url = url[:-1]
    name = url.split('/')[-1]
    if 'index.html' == name:
        import urlparse
        netloc = urlparse.urlsplit(url).netloc
        name = netloc + '.' + name
    return name


def lxml_soup(url, wait=0, cache=True, verbose=False):
    """SUMMARY

    @Arguments:
    - `url`:
    - `cache`:

    @Return:
    """
    # val = URLValidator(verify_exists=False)
    # try:
        # val(url)
    # except ValidationError, e:
        # print(e)

    if not url:
        return

    parse = urlparse.urlparse(url)
    tmpdir = os.path.join(tempfile.gettempdir(), 'urllib_cache', parse.netloc)

    if not os.path.exists(tmpdir):
        os.makedirs(tmpdir)
    name = _get_html_filename(url)
    if not name:
        import string
        import random
        name = ''.join(random.sample(string.lowercase, 5))
    fname = os.path.join(tmpdir, name)

    if os.path.exists(fname) and 0 == os.path.getsize(fname):
        os.remove(fname)

    if os.path.exists(fname):
        mtime = datetime.datetime.fromtimestamp(os.path.getmtime(fname))
        yesterday = datetime.datetime.now() - datetime.timedelta(1)
        obsoluted = mtime < yesterday
    else:
        obsoluted = False

    if not os.path.exists(fname) or obsoluted or cache is False:
        # force delete
        try:
            os.remove(fname)
        except OSError:
            pass

        with open(fname, 'w') as f:
            opener = urllib2.build_opener()
            agent_str = (u'Mozilla/5.0 (X11; Linux i686) '
                         'AppleWebKit/537.31 (KHTML, like Gecko) '
                         'Chrome/26.0.1410.63 Safari/537.31')
            opener.addheaders = [('User-agent', agent_str)]
            if verbose:
                sleep_progress(wait)
            else:
                sleep(wait)
            if verbose:
                print('Accessing: ' + url)
            with contextlib.closing(opener.open(url)) as page:
                try:
                    f.write(page.read())
                except IOError as e:
                    print('IOError errorno: [%d]' % e.errno)
                    return False
    if verbose:
        print('Reading: ' + fname)
    with open(fname, 'r') as file_:
        html = file_.read()
    return lxml.html.fromstring(html)


wikija = 'http://ja.wikipedia.org/wiki/'

def wikisoup(query, wait=10, verbose=False):
    """SUMMARY

    @Arguments:
    - `query`:

    @Return:
    """
    url = wikija + query
    doc = lxml_soup(url.encode('utf-8'), wait=wait, verbose=verbose)
    return doc

* Wed 11 Sep 2013 02:20:54 PM JST

* Wed 11 Sep 2013 02:20:54 PM JST

* Wed 11 Sep 2013 02:20:54 PM JST
        import urlparse

* Wed 11 Sep 2013 02:22:15 PM JST

* Wed 11 Sep 2013 02:22:15 PM JST

* Wed 11 Sep 2013 02:22:15 PM JST
__revision__ = "$Revision$"

* Wed 11 Sep 2013 02:22:15 PM JST
__revision__ = "$Revision$"

* Wed 11 Sep 2013 02:22:15 PM JST
__revision__ = "$Revision$"
__version__ = "0.1.0"

* Wed 11 Sep 2013 02:22:20 PM JST
__all__ = [ '' ]


* Wed 11 Sep 2013 02:25:26 PM JST
import urlparse
from lxmllib import lxml_soup


__revision__ = '$Revision$'
__version__ = '0.1.0'

url = 'http://www.google.com/search?hl=ja&q=%(query)s&num=1'

def google_feeling_lucky(query, verbose=False):
    """SUMMARY

    @Arguments:
    - `query`:

    @Return:
    """
    query = query.encode('utf-8')
    if verbose:
        print(query)
    search_url = (url % vars())
    search_url = search_url.replace(' ', '+').replace('　', '+')
    print(search_url)
    soup = lxml_soup(search_url, wait=10)
    try:
        link = soup.xpath('//*[@class="r"]/a')[0].attrib['href']
        link = filter_result(link)
    except IndexError:
        link = ''
    return link

def filter_result(link):
    try:

        # Valid results are absolute URLs not pointing to a Google domain
        # like images.google.com or googleusercontent.com
        o = urlparse.urlparse(link, 'http')
        if o.netloc and 'google' not in o.netloc:
            return link

        # Decode hidden URLs.
        if link.startswith('/url?'):
            link = urlparse.parse_qs(o.query)['q'][0]

            # Valid results are absolute URLs not pointing to a Google domain
            # like images.google.com or googleusercontent.com
            o = urlparse.urlparse(link, 'http')
            if o.netloc and 'google' not in o.netloc:
                return link

    # Otherwise, or on error, return None.
    except Exception:
        pass
    return None

* Wed 11 Sep 2013 02:25:36 PM JST
import urlparse
from lxmllib import lxml_soup



* Wed 11 Sep 2013 02:30:21 PM JST
""" prevent -- prevent script startup

$Revision$

"""


# for debug
# import cgitb as _cgitb
# _cgitb.enable(format='text')

import sys
import commands
from types import IntType


__revision__ = '$Revision$'
__version__ = '0.1.0'

MSG = {'allow_runlevel':
       'Runlevel Errors: Could not execute this script on this runnlevel.',
       }
ERR = {'err001': 'Command runlevel failed.',
       }


class CommandError(Exception):
    pass

def getrunlevel():
    """SUMMARY

    @Return: string number
    """
    status, out = commands.getstatusoutput('/sbin/runlevel')
    if not 0 == status:
        raise CommandError(ERR.get('err001'))
    return out.replace('N ', '').replace('\n', '')

def allow_runlevel(num, txt=MSG.get('allow_runlevel')):
    """SUMMARY

    @Arguments:
    - `num`:

    @Return:
    """
    if type(num) == IntType:
        num = [num]
    if not getrunlevel() in map(str, num):
            sys.exit(txt)

def disallow_runlevel(num, txt=MSG.get('allow_runlevel')):
    """SUMMARY

    @Return:
    """
    if type(num) == IntType:
        num = [num]
    if getrunlevel() in map(str, num):
            sys.exit(txt)


def test():
    pass


if __name__ == '__main__':
    test()

* Wed 11 Sep 2013 02:30:28 PM JST
""" prevent -- prevent script startup

$Revision$

"""

* Wed 11 Sep 2013 02:30:39 PM JST

* Wed 11 Sep 2013 02:30:39 PM JST

* Wed 11 Sep 2013 02:30:39 PM JST


* Wed 11 Sep 2013 02:30:42 PM JST
# for debug
# import cgitb as _cgitb
# _cgitb.enable(format='text')

* Wed 11 Sep 2013 02:30:45 PM JST
# for debug
# import cgitb as _cgitb
# _cgitb.enable(format='text')


* Wed 11 Sep 2013 02:30:49 PM JST
import sys
import commands
from types import IntType

# for debug
# import cgitb as _cgitb
# _cgitb.enable(format='text')


* Wed 11 Sep 2013 02:30:52 PM JST

* Wed 11 Sep 2013 02:30:52 PM JST

* Wed 11 Sep 2013 02:30:52 PM JST
__revision__ = "$Revision$"

* Wed 11 Sep 2013 02:30:52 PM JST
__revision__ = "$Revision$"

* Wed 11 Sep 2013 02:30:53 PM JST
__revision__ = "$Revision$"
__version__ = "0.1.0"

* Wed 11 Sep 2013 02:30:56 PM JST
__revision__ = '$Revision$'
__version__ = '0.1.0'

* Wed 11 Sep 2013 02:32:15 PM JST
from contextlib import closing
import struct
import socket

__revision__ = '$Revision$'
__version__ = '0.1.0'


def wakeonlan(mac_addr):
    """Send magic packet.

    @Arguments:
    - `mac_address`: like '00:00:00:00:00:00'
    """
    hex_addr = ''.join([
        struct.pack('B', int(x, 16)) for x in mac_addr.split(':')])

    packet = '\xff' * 6 + hex_addr * 16
    with closing(socket.socket(socket.AF_INET, socket.SOCK_DGRAM)) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        sock.sendto(packet, ('192.168.1.255', 9))

* Wed 11 Sep 2013 02:33:11 PM JST

* Wed 11 Sep 2013 02:33:11 PM JST

* Wed 11 Sep 2013 02:33:11 PM JST
__revision__ = "$Revision$"

* Wed 11 Sep 2013 02:33:11 PM JST
__revision__ = "$Revision$"

* Wed 11 Sep 2013 02:33:11 PM JST
__revision__ = "$Revision$"
__version__ = "0.1.0"

* Wed 11 Sep 2013 02:33:14 PM JST
__all__ = [ '' ]



* Wed 11 Sep 2013 02:34:39 PM JST
"""
$Revision: 380 $
$LastChangedRevision: 380 $
$LastChangedDate: 2012-08-07 21:43:00 +0900 (Tue, 07 Aug 2012) $

2012-07-18-161158knock.py

"""

import socket
import sys
from types import IntType
from contextlib import closing

def scan(host, port, timeout=0.5):
    """Send packet.

    """
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    timeout = float(timeout)
    s.settimeout(timeout)
    try:
        status = s.connect_ex((host, port))
    except:
        print "Cannot connect", host
        s.close()
        sys.exit(1)
    s.close()
    if 0 == status:
        return True
    else:
        return False


def tcpscan(host, port, timeout=0.5):
    """Simple tcp scan.

    """
    if (not type(port) is IntType) or (not (1 <= port <= 65535)):
        raise ValueError('port must be int. and range of 1~65535.')
    with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as sock:
        timeout = float(timeout)
        sock.settimeout(timeout)
        try:
            status = sock.connect_ex((host, port))
            if 0 == status:
                return True
            else:
                return False
        except sock.error, why:
            print why

* Wed 11 Sep 2013 02:34:57 PM JST
"""
$Revision: 380 $
$LastChangedRevision: 380 $
$LastChangedDate: 2012-08-07 21:43:00 +0900 (Tue, 07 Aug 2012) $

2012-07-18-161158knock.py

"""

* Wed 11 Sep 2013 02:35:09 PM JST
import socket
import sys
from types import IntType
from contextlib import closing

* Wed 11 Sep 2013 02:37:45 PM JST
import os as _os
import shutil
import tempfile
import inspect

import argparse

from portable import DRIVE_DIR
from pycmd import which

from ref.CMD.doxygen import DOXYGEN


__revision__ = '$Revision$'
__version__ = '0.1.0'

def path_checker(path):
    """Check exists path. If not exists raise error.

    @Arguments:
    - `path`: file or directory
    """
    if not _os.path.exists(path):
        raise IOError('File does not exists: %s' % _os.path.abspath(path))


class _OverAbstract(object):
    """
    """

    def __init__(self, target, dir_):
        """

        Arguments:
        - `target`:
        - `dir_`:
        """
        self._target = target
        self._dir_ = dir_


class Pyreverse(_OverAbstract):
    """
    """

    def pyreverse(self, detail=True):
        """Pyreverse command.

        @Arguments:
        - `detail`:

        @Return:
        """
        # detarmine pyreverse bin_
        if 'nt' == _os.name:
            bin_ = 'pyreverse.bat'
        elif 'posix' == _os.name:
            bin_ = 'pyreverse'

        # check exists pyreverse bin_
        if not which(bin_):
            raise IOError('File does not exists: %s' % bin_)

        # destination directory
        dst_dir = _os.path.join(self._dir, 'UML')
        # if not exists create it.
        if not _os.path.exists(dst_dir):
            _os.mkdir(dst_dir)

        # Do execute, there are two option.
        # simple output or detail output
        name = _os.path.basename(self._dir)
        if detail:
            cmd = '{0} -SAmy -o png -p {1} {2}'.format(bin_, name, self._target)
        else:
            name = 'Simple_' + name
            cmd = '{0} -o png -p {1} {2}'.format(bin_, name, self._target)
        _os.system(cmd)

        # check output
        src_name = 'classes_{0}.png'.format(name)
        src = _os.path.abspath(src_name)
        # if not exists src, raise error
        path_checker(src)

        # finalyze
        dst = _os.path.join(dst_dir, src_name)
        # first then remove it, if exists dst file.
        if _os.path.exists(dst):
            _os.remove(dst)
        if _os.path.exists(src):
            shutil.move(src, dst)
        elif not _os.path.exists(src):
            raise IOError('File does not exists: %s' % src)


class Epydoc(_OverAbstract):
    """
    """

    def epydoc(self):
        """Epydoc command.

        @Arguments:
        - `target`:

        @Return:
        """
        if not _os.path.isabs(self._target):
            raise ValueError('Set absolute path: %s' % self._target)

        # check exists epydoc
        bin_ = 'epydoc'
        if not which(bin_):
            raise IOError('File does not exists: %s' % bin_)

        # destination directory
        dst = _os.path.join(self._dir, 'epydoc_html')

        # do exec
        cmd = '{0} --graph all --html --output {1} {2}'.format(
            bin_, dst, self._target)
        _os.system(cmd)

        # check output
        if not _os.path.exists(dst):
            raise IOError('File does not exists: {0}'.format(dst))


class Doxygen(_OverAbstract):
    """
    """

    def doxygen(self):
        """Doxygen command.

        @Return:
        """
        dox_output = 'doxygen_html'
        # check doxygen exists excutable
        if not which(DOXYGEN.get('bin')):
            raise IOError('File does not exists: %s' % DOXYGEN.get('bin'))

        # check doxygen config and target files
        for item in [DOXYGEN.get('conf'), self._target]:
            path_checker(item)

        # create tmp directory and go to directory if target is file, .
        orig_dir = _os.path.curdir
        if _os.path.isfile(self._target):
            tempdir = tempfile.mkdtemp()
            shutil.copy2(self._target, tempdir)
            _os.chdir(tempdir)
            # Execute doxygen
            _os.system(DOXYGEN.get('bin') + ' ' + DOXYGEN.get('conf'))
            path_checker(dox_output)
            # shutil.copytree(dox_output, _os.path.join(self._dir, dox_output))
        else:
            _os.chdir(_os.path.dirname(self._target))
            # Execute doxygen
            _os.system(DOXYGEN.get('bin') + ' ' + DOXYGEN.get('conf'))
            path_checker(dox_output)

        # move outputed directory to orig path if target is file
        _os.chdir(orig_dir)


class Overview(Pyreverse, Epydoc, Doxygen):
    """
    """

    def __init__(self, target, dir_):
        """

        Arguments:
        - `target`:
        - `dir_`:
        - `detail`:
        """
        self._target = target
        self._dir = dir_
        self._methods = []

    def __iter__(self):
        """SUMMARY

        @Return:
        """
        for m in dir(self):
            if m.startswith('_') or m in ['next']:
                continue
            if inspect.ismethod(getattr(self, m)):
                self._methods.append(m)
        return self

    def next(self):
        """SUMMARY

        @Return:
        """
        try:
            func = getattr(self, self._methods.pop())
        except IndexError:
            raise StopIteration
        return func

    def do_all(self):
        """SUMMARY

        @Return:
        """
        # for m in dir(self):
        #     if m.startswith('_') or m in ['next']:
        #         continue
        #     if inspect.ismethod(getattr(self, m)):
        #         getattr(self, m)()
        # use iterator
        for func in self:
            func()


### PYREVERSE
def my_pyreverse(target, dir_, detail=True):
    """Pyreverse command.

    @Arguments:
    - `target`:
    - `dst`:
    - `detail`:

    @Return:
    """
    # detarmine pyreverse bin_
    if 'nt' == _os.name:
        bin_ = 'pyreverse.bat'
    elif 'posix' == _os.name:
        bin_ = 'pyreverse'

    # check exists pyreverse bin_
    if not which(bin_):
        raise IOError('File does not exists: %s' % bin_)

    # destination directory
    dst_dir = _os.path.join(dir_, 'UML')
    # if not exists create it.
    if not _os.path.exists(dst_dir):
        _os.mkdir(dst_dir)

    # do exec
    # there are two option.
    # simple output or detail output
    name = _os.path.basename(dir_)
    if detail:
        _os.system('{0} -SAmy -o png -p {1} {2}'.format(bin_, name, target))
    else:
        name = 'Simple_' + name
        _os.system('{0} -o png -p {1} {2}'.format(bin_, name, target))

    # check output
    src_name = 'classes_{0}.png'.format(name)
    src = _os.path.abspath(src_name)
    # if not exists src, raise error
    path_checker(src)

    # finalyze
    dst = _os.path.join(dst_dir, src_name)
    # first then remove it, if exists dst file.
    if _os.path.exists(dst):
        _os.remove(dst)
    if _os.path.exists(src):
        shutil.move(src, dst)
    elif not _os.path.exists(src):
        raise IOError('File does not exists: %s' % src)

### epydoc
def my_epydoc(target, dir_):
    """Epydoc command.

    @Arguments:
    - `target`:

    @Return:
    """
    if not _os.path.isabs(target):
        raise ValueError('Set absolute path: %s' % target)

    # check exists epydoc
    bin_ = 'epydoc'
    if not which(bin_):
        raise IOError('File does not exists: %s' % bin_)

    # destination directory
    dst = _os.path.join(dir_, 'epydoc_html')

    # do exec
    _os.system('{0} --graph all --html --output {1} {2}'.format(bin_, dst, target))

    # check output
    if not _os.path.exists(dst):
        raise IOError('File does not exists: %s' % dst)

def my_doxygen(target, dir_):
    """Doxygen command.

    @Return:
    """
    if 'nt' == _os.name:
        dox_bin = 'doxygen.exe'
        doxygen_conf = _os.path.join(DRIVE_DIR, 'Dos/graphviz/doxygen.conf')
    elif 'posix' == _os.name:
        dox_bin = 'doxygen'
        doxygen_conf = _os.path.expanduser('~/.emacs.d/data_e/doxygen.conf')

    dox_output = 'doxygen_html'
    # check doxygen exec file
    if not which(dox_bin):
        raise IOError('File does not exists: %s' % dox_bin)

    # check doxygen config and target files
    for item in [doxygen_conf, target]:
        path_checker(item)

    # set flag if exists target
    isfile = _os.path.isfile(target)

    # create tmp directory and go to directory if target is file, .
    orig_dir = _os.path.curdir
    if isfile:
        tempdir = tempfile.mkdtemp()
        shutil.copy2(target, tempdir)
        _os.chdir(tempdir)
    else:
        _os.chdir(_os.path.dirname(target))

    # Execute doxygen
    _os.system(dox_bin + ' ' + doxygen_conf)

    path_checker(dox_output)

    # move outputed directory to orig path if target is file
    if isfile:
        shutil.copytree(dox_output, _os.path.join(dir_, dox_output))
    _os.chdir(orig_dir)

def _options_maker():
    parser = argparse.ArgumentParser(description="""Overview.""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,
                        help='Version Strings.')
    parser.add_argument('file',
                        action='store',
                        help='File name.')
                        # (yas/expand-link "argparse_add_argument")
    return parser.parse_args()


def _main():
    """Main function."""
    # check Arguments
    args = _options_maker()
    target = _os.path.abspath(_os.path.normcase(args.file))
    # if target does not exists raise Error
    path_checker(target)

    # dst_dir
    # set files directory, if target is a file.
    # set as it, if target is a directory.
    if _os.path.isfile(target):
        dst_dir = _os.path.splitext(target)[0]
    elif _os.path.isdir(target):
        dst_dir = target

    # make destination directory
    if _os.path.isfile(target) and not _os.path.exists(dst_dir):
        _os.mkdir(dst_dir)

    view = Overview(target, dst_dir)
    # pyreverse
    # my_pyreverse(target, dst_dir)
    # my_pyreverse(target, dst_dir, detail=False)
    view.pyreverse()

    # epydoc
    my_epydoc(target, dst_dir)
    view.epydoc()

    # doxygen
    # orig_dir = _os.getcwd()
    # try:
        # my_doxygen(target, dst_dir)
    # finally:
        # _os.chdir(orig_dir)
    view.doxygen()

if __name__ == '__main__':
    _main()

* Wed 11 Sep 2013 02:37:55 PM JST
import os as _os
import shutil
import tempfile
import inspect

import argparse

from portable import DRIVE_DIR
from pycmd import which

from ref.CMD.doxygen import DOXYGEN


* Wed 11 Sep 2013 02:38:51 PM JST
argparse
* Wed 11 Sep 2013 02:41:30 PM JST

* Wed 11 Sep 2013 02:41:30 PM JST

* Wed 11 Sep 2013 02:41:30 PM JST
    parser = _predef_options()

* Wed 11 Sep 2013 02:41:47 PM JST
    parser = _predef_options()

* Wed 11 Sep 2013 02:41:47 PM JST
    parser = _predef_options()
    opts = parser.parse_args()

* Wed 11 Sep 2013 02:41:47 PM JST
    parser = _predef_options()
    opts = parser.parse_args()

* Wed 11 Sep 2013 02:41:47 PM JST
    parser = _predef_options()
    opts = parser.parse_args()
    parser.print_usage()    

* Wed 11 Sep 2013 02:42:22 PM JST

* Wed 11 Sep 2013 02:42:22 PM JST

* Wed 11 Sep 2013 02:42:22 PM JST
import argparse

* Wed 11 Sep 2013 02:43:18 PM JST
import os as _os

# for debug
import cgitb as _cgitb
_cgitb.enable(format='text')


__revision__ = '$Revision$'
__version__ = '0.1.0'


def which(filename):
    """docstring for which"""
    locations = _os.environ.get("PATH").split(_os.pathsep)
    candidates = []
    for location in locations:
        candidate = _os.path.join(location, filename)
        if _os.path.isfile(candidate):
            candidates.append(candidate)
    return candidates


def test():
    "Test function."
    pass


if __name__ == '__main__':
    test()

* Wed 11 Sep 2013 02:43:26 PM JST
import os as _os

# for debug
import cgitb as _cgitb
_cgitb.enable(format='text')


__revision__ = '$Revision$'
__version__ = '0.1.0'

* Wed 11 Sep 2013 02:43:29 PM JST

* Wed 11 Sep 2013 02:43:29 PM JST

* Wed 11 Sep 2013 02:43:29 PM JST
__revision__ = "$Revision$"

* Wed 11 Sep 2013 02:43:29 PM JST
__revision__ = "$Revision$"

* Wed 11 Sep 2013 02:43:29 PM JST
__revision__ = "$Revision$"
__version__ = "0.1.0"

* Wed 11 Sep 2013 02:45:19 PM JST
""" king -- handling for king server

$Revision$

"""

import sys
from getpass import getpass
from time import sleep
from socket import gethostbyname

import argparse
import paramiko
import pexpect

from agent import AgentUtils
from rook import Rook, CHAPTERFORMAT, PRINTFORMAT
from ref.myinfo import king, kagi, kagiMD5
from mytemp.abstract import Verbose
from tunnel import Tunneling, TunnelError
from confirm import yesno

__revision__ = "$Revision$"
__version__ = "0.2.0"

__all__ = ['PRINTFORMAT', 'PasswordError', 'King']


class PasswordError(Exception):
    pass


class DecryptError(Exception):
    pass


class CMDError(Exception):
    pass

class MountError(Exception):
    pass


class _KingPave(AgentUtils, Tunneling):
    """Pave king environment."""

    def isactive(self):
        """Check king server is running."""
        return self.router.isactive_machine(self._ip)

    def pave(self, decrypt=True, prompt=True, force=False):
        """Pave for king server.

        If not active server, try wake up.
        If not seting portforward, then try make tunneling.
        If not decrypt disk, then try get decrypted disk.

        @Return:
        """
        self.wol(force=force)
        # portforwarding
        self._pave_tunnel(force=force)
        if not decrypt:
            return
        # decrypt disk
        if not self.isdecrypt() and prompt and yesno('\rDecrypt disk? [y/n]: '):
            self._pave_disk(force=force)

    def wol(self, force=False):
        """Send Wake On Lan packet to king server."""
        if not self.isactive() or force:
            if self._verbose:
                print(CHAPTERFORMAT.format(' Wake On Lan '))
                print(PRINTFORMAT.format('Wake On Lan', 'Sending Packet...'))
            self.router.wol(self._mac, self._ip)

    def _pave_rook(self, force=False):
        """SUMMARY

        @Arguments:

        - `force`:

        @Return:
        """
        self.router.pave(force=force)

    def _pave_tunnel(self, force=False):
        """Set tunneling to ki server.

        @Arguments:

        - `force`:

        @Return:
        """
        if self.hastunnel() and not force:
            return True

        if self._verbose:
            print(CHAPTERFORMAT.format(' PortForward '))
        try:
            if self.gettunnel():
                if self._verbose:
                    print(PRINTFORMAT.format('PortForwarder', 'Launched!!'))
        except TunnelError:
            print("Can't create tunneling.")
            if yesno("\rRetry create tunneling?: "):
                if not self.gettunnel():
                    print("Can't create tunneling.")
                    raise TunnelError()
            else:
                raise TunnelError()

    def _pave_disk(self, force=False):
        """SUMMARY

        @Arguments:

        - `force`:

        @Return:
        """
        if self.ismount() and not force:
            if self._verbose:
                print(PRINTFORMAT.format('Mount', 'Already Mounted!!'))
            return True

        if self._verbose:
            print(CHAPTERFORMAT.format(' Decrypt Disk '))
            print(PRINTFORMAT.format('Check Disk', 'NOT decrypted.'))

        self.mount_data()
        if not self.ismount():
            if self._verbose:
                print(PRINTFORMAT.format('Mount', 'NOT Mounted!!'))
            return False
        if self._verbose:
            print(PRINTFORMAT.format('Mount', 'OK Mounted!!'))
        return True


class _Decrypt(object):
    """
    """
    _pexpect = None

    def ismount(self):
        """Check data disk is mounting."""
        self.pave(decrypt=False)
        return self._test_cmd('test -d /data/archive')

    def isdecrypt(self):
        """Check decrypt data disk.

        no check mounting.
        """
        self.pave(decrypt=False)
        return self._test_cmd('test -b /dev/mapper/data_crypt')

    def decrypt(self):
        """Decrypt and mount data disk.


        * sudo command has 3 type messages.
        Enter   [1] '[sudo] password for t1: '
        ReEnter [2] 'Sorry, try again.\n[sudo] password for t1: '
        Fail    [3] 'sudo: 3 incorrect password attempts'

        * cryptsetup luksOpen has 2 type messages.
        Enter   [1] 'Enter passphrase for /dev/mapper/VG-data: '
        ReEnter [2] 'No key available with this passphrase.\n
                     Enter passphrase for /dev/mapper/VG-data: '
        """
        if self.isdecrypt():
            if self._verbose:
                print(PRINTFORMAT.format('Cryptseup', 'Aleady Decrypted!!'))
            return 0
        if not self._pexpect:
            self._pexpect = pexpect.spawn('ssh ki', maxread=4000)
            self._pexpect.expect('Last login')
            if self._verbose:
                host = '{0}@{1} ({2}) [king]'.format(self._user, self._host,
                                                     self._ip)
                print(PRINTFORMAT.format('SSH login', host))
        cmd = '/usr/bin/sudo /sbin/cryptsetup luksOpen {0} {1}'.format(
                                self._crypted_disk, self._decrypted_disk_name)
        self._pexpect.sendline(cmd)
        expect_lis = ['\[sudo\] password', '3 incorrect',
                      'Enter passphrase', '[#\$]']
        index = self._pexpect.expect(expect_lis)
        if index == 0:
            self._pexpect.sendline(
                getpass('[sudo] password for {0}: '.format(self._user)))
        err_count = 0
        while 1:
            index = self._pexpect.expect(expect_lis)
            if 0 == index:
                self._pexpect.sendline(
                    getpass('[sudo] password for {0}: '.format(self._user)))
            elif 1 == index:
                raise PasswordError('incorrected sudo password.')
            elif 2 == index:
                if 0 < err_count:
                    print('No key available with this passphrase.')
                err_count += 1
                self._pexpect.sendline(
                    getpass('Enter passphrase for {0}: '.format(
                        self._crypted_disk)))
            elif 3 == index:
                if 3 == err_count and self._pexpect.exitstatus != 0:
                    raise PasswordError('incorrected cryptsetup password.')
                break

    def close_data(self):
        """SUMMARY

        @Return:
        """
        self.pave(decrypt=False)
        pass

    def mount_data(self):
        """SUMMARY

        @Return: exit status
        """
        if self.ismount():
            if self._verbose:
                print(PRINTFORMAT.format('/data', 'Already Mounted !!'))
            return True
        if not self.isdecrypt():
            try:
                self.decrypt()
            except PasswordError:
                if yesno('\rRetry it? [y/n]: '):
                    self.mount_data()
                else:
                    return False
            except DecryptError('Could not decrypt disk.'):
                return 1
        cmd = '/usr/bin/sudo /bin/mount /dev/mapper/data_crypt /data'
        self.cmd(cmd)

    def umount_data(self):
        """SUMMARY

        @Return:
        """
        pass


class _Upload(object):
    """
    """
    _sftp = None

    def upload(self, src, dst, decrypt=False):
        """Upload sfcp

        Arguments:

        - `src`:
        - `dst`:
        """
        self.pave(decrypt=True, prompt=True)
        if not self.sftp:
            self._sftp_connect()
        self.sftp.put(src, dst)

    def _sftp_connect(self):
        """Connect sftp"""
        if not self._ssh:
            self.connect()
        self._sftp = self._ssh.open_sftp()


class _KingScript(_Decrypt, _Upload):
    """
    """
    _ssh = None
    _chan = None

    def cmd(self, cmd):
        """Send command to server.

        Arguments:

        - `cmd`: command line
        """
        if not self._ssh:
            self._connect()
        chan = self._ssh.exec_command(cmd)
        if self._verbose:
            print(PRINTFORMAT.format('Sending command', cmd))
        sleep(1)
        return chan

    def _connect(self, force=False):
        """Do connect server.

        Arguments:

        - `force`: if True, reconnect.
        """
        if force and self._ssh:
            self.close()
            self._ssh = None
        if not self._ssh:
            self._ssh = paramiko.SSHClient()
            self._ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self._ssh.connect(self._host, self._listen_port, self._user)

    def chan_cmd(self):
        """SUMMARY

        @Arguments:

        - `cmd`:

        @Return:
        """
        if not self._ssh:
            self._connect()
        # chan = self._ssh.get_transport().open_session()
        # chan.get_pty()
        self._chan = self._ssh.invoke_shell()
        # chan.exec_command(cmd)
        # chan.send(cmd)
        # return chan

    def _test_cmd(self, cmd):
        """Send command and check exit code.

        Arguments:

        - `cmd`: command line
        """
        stdin, stdout, stderr = self.cmd(cmd)
        return 0 == stdout.channel.recv_exit_status()

    def halt(self):
        """Shutdown king server."""
        from sleep_progress import sleep_progress
        if not self.isactive():
            if self._verbose:
                print(PRINTFORMAT.format('Halting', 'Already Downed.'))
            return True
        if self._verbose:
            print(PRINTFORMAT.format('Command', 'Sending command...'))
        self._test_cmd('/usr/bin/sudo /sbin/halt')
        # wait shutdown
        if self._verbose:
            sleep_progress(10, PRINTFORMAT.format('Waiting', '%-2d seconds'))
        else:
            sleep(10)
        for i in range(10):
            if not self.isactive():
                if self._verbose:
                    print(PRINTFORMAT.format('Halting', 'Halt OK!!'))
                break
        if 9 <= i:
            raise CMDError('Could not shutdown ki server.')
        self.router.port.close()
        if self.router.port.isopen():
            if self._verbose:
                print(PRINTFORMAT.format('Close port', 'OPEN!!'))
        return True


class _KingMain(_KingPave, _KingScript, Verbose):
    """
    """

    Router = Rook

    def __init__(self, host=king.get('host'),
                       ip = king.get('ip'),
                       user = king.get('user'),
                       listen_port = king.get('port'),
                       mac = king.get('mac'),
                       kagi = kagi,
                       kagiMD5 = kagiMD5,
                       crypted_disk = king.get('crypted_disk'),
                       decrypted_disk_name = king.get('decrypted_disk_name'),
                       verbose=False):
        """

        Arguments:
        - `host`:
        - `ip`:
        - `user`:
        - `listen_port`:
        - `mac`:
        - `kagi`:
        - `kagiMD5`:
        - `crypted_disk`:
        - `decrypted_disk_name`:
        - `verbose`:
        """
        super(_KingMain, self).__init__(verbose=verbose)
        self.router = self.Router(verbose=self._verbose)
        self._host = host
        self._ip = ip
        self._user = user
        self._listen_port = listen_port
        self._mac = mac
        self._kagi = kagi
        self._kagiMD5 = kagiMD5
        self._crypted_disk = crypted_disk
        self._decrypted_disk_name = decrypted_disk_name

    def __str__(self):
        """This returns a human-readable string that represents the state of
        the object.

        """
        dic = {'version': '{0} ({1})'.format(__version__, __revision__),
               'router': repr(self.router),
               'host': '{0} ({1})'.format(gethostbyname(self._host), self._host),
               'ip': self._ip,
               'username': self._user,
               'listen_port': self._listen_port,
               'Mac address': self._mac,
               'SSH key': self._kagi,
               'SSH key md5': repr(self._kagiMD5),
               'ssh': repr(self._ssh),
               'ssh channel': repr(self._chan),
               'sftp': repr(self._sftp),}
        wide = len(max(dic.keys(), key=len)) + 1
        formt = '{0:<' + str(wide) + '}: {1}' # will be like this '{0:<10}: {1}'
        s = []
        s.append(repr(self))
        for key, value in dic.iteritems():
            s.append(formt.format(key, value))
        return '\n'.join(s)


class King(Verbose):
    """King server handling object."""

    KingMain = _KingMain

    def __init__(self, host=king.get('host'),
                       ip=king.get('ip'),
                       user=king.get('user'),
                       listen_port=king.get('port'),
                       mac=king.get('mac'),
                       kagi=kagi,
                       kagiMD5=kagiMD5,
                       crypted_disk=king.get('crypted_disk'),
                       decrypted_disk_name=king.get('decrypted_disk_name'),
                       verbose=False):
        """

        Arguments:
        - `host`: [string] global ip or domain name.
        - `ip`: [string] local ip address internal this server.
        - `user`: [string] user name by ssh login.
        - `listen_port`: [int] port of remote host.
        - `mac`: [string] king servers MAC address.
        - `kagi`: [string path] SSH key.
        - `kagiMD5`: [string] SSH key's MD5 by paramiko.
        - `crypted_disk`: [string path] crypted disk full path.
        - `decrypted_disk_name`: [string] after decrypted disk's name.
        - `verbose`: [bool] if True, a lot of print to stdout.
        """
        super(King, self).__init__(verbose=verbose)
        self.script = self.KingMain(host=host, ip=ip, user=user,
                                    listen_port=listen_port, mac=mac,
                                    kagi=kagi, kagiMD5=kagiMD5,
                                    crypted_disk=crypted_disk,
                                    decrypted_disk_name=decrypted_disk_name,
                                    verbose=self._verbose)


    def __str__(self):
        return self.script.__str__()

    def __del__(self):
        self.close()

    # for with statement
    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()

    def isactive(self):
        """Check king server is running."""
        return self.script.isactive()

    def isdecrypt(self):
        return self.script.isdecrypt()

    def ismount(self):
        return self.script.ismount()

    def halt(self):
        """Shutdown king server."""
        self.script.halt()

    def verbose_on(self):
        self._verbose = True
        self.script.verbose_on()
        self.router.verbose_on()

    def verbose_off(self):
        self._verbose = False
        self.script.verbose_off()
        self.router.verbose_off()

    def close(self):
        """Close connections."""
        if self.script.router:
            self.script.router.close()
        if self.script._pexpect:
            self.script._pexpect.close()
        if self.script._ssh:
            self.script._ssh.close()


def _main():
    parser = argparse.ArgumentParser(description="""\
    This script handle King server.""")

    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,
                        help='Show version Strings.')

    parser.add_argument('-s', '--silent',
                        dest='silent',
                        action='store_false',
                        default=True,
                        required=False,
                        # (yas/expand-link "argparse_other_options" t)
                        help='No verbosly')

    # parser.add_argument('-v', '--verbose',
    #                     dest='verbose',
    #                     action='count',
    #                     default=0,
    #                     help='A lot of messages.')

    parser.add_argument('-p', '--pave',
                        dest='pave',
                        action='store_true',
                        default=False,
                        required=False,
                        help='Pave for king server.')

    parser.add_argument('--shutdown', '--halt',
                        dest='halt',
                        action='store_true',
                        default=False,
                        required=False,
                        help='Shutdown king server.')

    parser.add_argument('--no-decrypt',
                        dest='no_decrypt',
                        action='store_false',
                        default=True,
                        required=False,
                        help='No decrypt flag.')

    parser.add_argument('-w', '--wol',
                        dest='wol',
                        action='store_true',
                        default=False,
                        required=False,
                        help='Send Wake On Lan packet.')

    parser.add_argument('-a', '--check-active',
                        dest='isactive',
                        action='store_true',
                        default=False,
                        required=False,
                        help='Check running server.')

    parser.add_argument('-o', '--onlyssh-pave',
                    dest='onlyssh_pave',
                    action='store_true',
                    default=False,
                    required=False,
                    # (yas/expand-link "argparse_other_options" t)
                    help='Pave ssh agent and portforward.')

    # (yas/expand-link "argparse_add_argument" t)

    args = parser.parse_args()
    with King(verbose=args.silent) as ki:
        if args.onlyssh_pave:
            ki.script._pave_rook()
            ki.script._pave_tunnel()
            sys.exit(0)
        if args.halt:
            ki.halt()
        elif args.pave:
            ki.script.pave(decrypt=args.no_decrypt)
        elif args.wol:
            ki.script.wol()
        elif args.isactive:
            if ki.isactive():
                print "ACTIVE"
            else:
                print "DOWN"
        else:
            ki.script.pave(decrypt=args.no_decrypt)


if __name__ == '__main__':
    _main()

* Wed 11 Sep 2013 02:45:34 PM JST
""" king -- handling for king server

$Revision$

"""

* Wed 11 Sep 2013 02:52:35 PM JST
""" rook -- rook(router) handler

$Revision$

"""
from socket import gethostbyname
import sys as _sys
from time import sleep as _sleep

import paramiko

from agent import AgentUtils, add_keys
from ref.myinfo import rook, kagi, kagiMD5
from mytemp.abstract import Verbose
from knock import knock, tcpscan


__revision__ = "$Revision$"
__version__ = "0.2.0"

__all__ = ['Rook']

CHAPTERFORMAT = '\n{0:*^30}'
PRINTFORMAT = '[ {0:<16} ]  {1}'


class SSHKeyError(StandardError):
    pass


class PingMax(Exception):
    pass


class PortError(Exception):
    pass


class _RookPort(Verbose):
    """Handling rooks ssh port by knocking packet."""

    def __init__(self, host, port, opens, closes, verbose=False):
        super(_RookPort, self).__init__(verbose=verbose)
        self.host = host
        self.listen_port = port
        self.open_ports = opens
        self.close_ports = closes

    def open(self):
        """Send knocking packet for open port on rook."""
        # if self._verbose:
            # print(CHAPTERFORMAT.format(' Knocking '))
            # print(PRINTFORMAT.format(
                # 'Open port', self.host + ':' + str(self.listen_port)))
        self._ifverbose(CHAPTERFORMAT.format(' Knocking '),
                        PRINTFORMAT.format('Open port',
                               ''.join([self.host, ':', str(self.listen_port)])))
        knock(self.host, self.open_ports, verbose=self._verbose)

    def close(self):
        """Send knocking packet for close port on rook."""
        # if self._verbose:
            # print(CHAPTERFORMAT.format(' Knocking '))
            # print(PRINTFORMAT.format(
                # 'Close port', self.host +':'+ str(self.listen_port)))
        self._ifverbose(CHAPTERFORMAT.format(' Knocking '),
                        PRINTFORMAT.format('Close port',
                               ''.join([self.host, ':', str(self.listen_port)])))
        knock(self.host, self.close_ports, verbose=self._verbose)

    def isopen(self):
        """Check open or close port on rook."""
        return tcpscan(self.host, self.listen_port)


class _RookPave(AgentUtils):
    """Pave rook ssh environment.
    """
    _isopen_port_flag = False
    _haskeyring_flag = False

    def pave(self, force=False):
        """Pave ssh environment.

        [1] open port rook.
        [2] add ssh key ageant.

        Arguments:

        - `verbose`:
        """
        self._pave_port(force=force)
        self._pave_keyring(force=force)

    def _pave_port(self, force=False):
        """Open rooks port for ssh.

        @Arguments:

        - `force`:

        @Return:
        """
        if not self._isopen_port_flag or force:
            self.port.open()
            if self.port.isopen():
                self._isopen_port_flag = True
                # if self._verbose:
                    # print(PRINTFORMAT.format('Port: ' + str(self._listen_port),
                                             # 'OPENED!!'))
                self._ifverbose(PRINTFORMAT.format(
                    'Port: ' + str(self._listen_port), 'OPENED!!'))
            else:
                raise PortError('Could not open port.')

    def _pave_keyring(self, kagi=None, force=False):
        """Ssh key add to sshkeyring.

        @Arguments:

        - `kagi`: ssh key
        - `force`: force add key

        @Return:
        """
        if not self._haskeyring_flag or force:
            if not kagi:
                kagi = self._kagi
            # try input key password for 3 times.
            for i in range(3):
                if self.haskeyring():
                    self._haskeyring_flag = True
                    # if self._verbose:
                        # print(PRINTFORMAT.format('Check has keys', 'Has keys.'))
                    self._ifverbose(PRINTFORMAT.format('Check has keys',
                                                       'Has keys.'))
                    break
                else:
                    if 0 == i:
                        self._ifverbose(PRINTFORMAT.format('Check has keys',
                                                           'Not has keys!!'))
                    # if self._verbose and 0 == i:
                        # print(PRINTFORMAT.format('Check has keys',
                                                 # 'Not has keys!!'))
                    try:
                        add_keys(kagi)
                    except:
                        raise SSHKeyError


class _RookScript(object):
    """
    """
    _ssh = None
    _wait = 60 # for wake on lan

    def cmd(self, cmd):
        """Send command to rook(router).

        Arguments:

        - `cmd`: command line strings.
        """
        self.pave()
        if not self._ssh:
            self._connect()
        return self._ssh.exec_command(cmd)

    def _connect(self, force=False):
        """SSH connect with rook.

        Arguments:

        - `force`: force reconnection if already handshaked with rook.
        """
        if not self._isopen_port_flag or not self._haskeyring_flag:
            self.pave(force=force)
        if force and self._ssh:
            self.close()
            self._ssh = None
        if not self._ssh:
            self._ssh = paramiko.SSHClient()
            self._ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            if self._verbose:
                host = '{0} ({1}) [rook]'.format(
                    self._host, gethostbyname(self._host))
                print(PRINTFORMAT.format('SSH login', host))
            self._ssh.connect(self._host, self._listen_port, self._user)

    def isactive_machine(self, ip):
        """Check active internal rook network machines.

        Arguments:

        - `ip`: internal ip address

        @Return: bool
        """
        self.pave()
        cmd = 'ping -w 1 -c 1 {0} | grep "bytes from"'.format(ip)
        stdin, stdout, stderr = self.cmd(cmd)
        return 0 == stdout.channel.recv_exit_status()

    def wol(self, mac, ip, pingmax=30):
        """Send Wake on Lan packet to internal network machines.

        Arguments:

        - `mac`: Mac address of target machines.
        """
        self.pave()
        from sleep_progress import sleep_progress
        self.cmd('/usr/sbin/wol -i 192.168.1.255 {0}'.format(mac))
        if self._verbose:
            sleep_progress(
                self._wait, PRINTFORMAT.format('Waiting Wakeup', '%-2d seconds'))
        else:
            _sleep(self._wait)
        # confirm wake up
        for i in range(1, pingmax + 1):
            if self._verbose:
                still_down = 'Still DOWN ping {0}/{1}'.format(i, pingmax)
                _sys.stdout.write('\r' + PRINTFORMAT.format(ip, still_down))
                _sys.stdout.flush()
            if self.isactive_machine(ip):
                if self._verbose:
                    print('\n' + PRINTFORMAT.format(ip, 'UP!!\n'))
                _sleep(10) # wait until launch sshd
                break
        if pingmax <= i:
            print('\n\n') # flush stdout
            raise PingMax("Reached pinging max %d count." % i)


    def tcpdump(self, save_path):
        """Not inpremented

        @Arguments:

        - `save_path`:

        @Return:
        """
        pass


class Rook(_RookPave, _RookScript, Verbose):
    """Handling rook(router).

    - `port`: handling rooks ssh port by knock command.
              'port.open, port.close, port.isopen'
    - ``

    """
    def __init__(self, host=rook.get('host'),
                       user=rook.get('user'),
                       kagi=kagi,
                       kagiMD5=kagiMD5,
                       listen_port=rook.get('port'),
                       opens=rook.get('open_port'),
                       closes=rook.get('close_port'),
                       verbose=False):
        super(Rook, self).__init__(verbose=verbose)
        self._host = host
        self._user = user
        self._kagi = kagi
        self._kagiMD5 = kagiMD5
        self._listen_port = listen_port
        self._open_ports = opens
        self._close_ports = closes
        self._paved = False
        self.port = _RookPort(self._host, self._listen_port, self._open_ports,
                              self._close_ports, verbose=self._verbose)

    def __str__(self):
        """This returns a human-readable string that represents the state of
        the object.

        @Return:
        """
        s = []
        s.append(repr(self))
        s.append('version: {0} ({1})'.format(__version__, __revision__))
        s.append('host: {0}({1})'.format(gethostbyname(self._host), self._host))
        s.append('user: {0}'.format(self._user))
        s.append('SSH key: {0}'.format(self._kagi))
        s.append('SSH key md5: {0}'.format(self._kagiMD5))
        s.append('Listen port: {0}'.format(self._listen_port))
        s.append('Open ports: {0}'.format(self._open_ports))
        s.append('Close ports: {0}'.format(self._close_ports))
        s.append('port: {0}'.format(repr(self.port)))
        s.append('{0:=^10}'.format('Flag'))
        s.append('SSH connection: {0}'.format(self._ssh))
        s.append('Wait time for wake up machine: {0}'.format(self._wait))
        s.append('Port open: {0}'.format(self._isopen_port_flag))
        s.append('Has keyring: {0}'.format(self._haskeyring_flag))

    def close(self):
        """Close connection."""
        if self._ssh:
            self._ssh.close()

    def __del__(self):
        self.close()

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()

    def verbose_on(self):
        """SUMMARY

        @Return:
        """
        self._verbose = True
        self.port.verbose_on()

    def verbose_off(self):
        """SUMMARY

        @Return:
        """
        self._verbose = False
        self.port.verbose_off()

* Wed 11 Sep 2013 02:52:50 PM JST
""" rook -- rook(router) handler

$Revision$

"""

* Wed 11 Sep 2013 02:55:33 PM JST
""" MyTestData -- for test data container.

$Revision$

"""


# for debug
import cgitb as _cgitb
_cgitb.enable(format='text')
from pprint import pprint



__revision__ = '$Revision$'
__version__ = '0.1.0'


class _TextData(object):
    """
    """
    text = txt = tx = t = line = 'Python is a programming language that lets you work more quickly and integrate your systems more effectively.'

    long = """In the old age black was not counted fair,
Or if it were, it bore not beauty's name;
But now is black beauty's successive heir,
And beauty slandered with a **** shame:
For since each hand hath put on Nature's power,
Fairing the foul with Art's false borrowed face,
Sweet beauty hath no name, no holy bower,
But is profaned, if not lives in disgrace.
Therefore my mistress' eyes are raven black,
Her eyes so suited, and they mourners seem
At such who, not born fair, no beauty lack,
Sland'ring creation with a false esteem:
Yet so they mourn becoming of their woe,
That every tongue says beauty should look so.
"""

    long2 = """When, in disgrace with fortune and men's eyes,
I all alone beweep my outcast state,
And trouble deaf heaven with my bootless cries,
And look upon myself, and curse my fate,
Wishing me like to one more rich in hope,
Featured like him, like him with friends possessed,
Desiring this man's art and that man's scope,
With what I most enjoy contented least;
Yet in these thoughts myself almost despising,
Haply I think on thee—and then my state,
Like to the lark at break of day arising
From sullen earth, sings hymns at heaven's gate;
   For thy sweet love rememb'red such wealth brings
   That then I scorn to change my state with kings.
"""

    longlong = long + long2

    def __repr__(self):
        """SUMMARY

        @Return:
        """
        msg = '{0:*^30}'.format('Text Data') + '\n'
        lis = []
        for el in dir(self):
            if not el.startswith('_') or not el.endswith('_'):
                lis.append(el)
        return msg + str(lis).replace("',", '\n')


class _StringData(object):
    """
    """
    hello = h = he = str = s = 'hello'
    world = w = wo = str2 = s2 = 'world'
    null = null_string = nstring = nullstring = n_string = ns = ''
    text = t = txt = _TextData()

    def __repr__(self):
        """SUMMARY

        @Return:
        """
        msg = '{0:*^30}'.format('String Data') + '\n'
        lis = []
        for el in dir(self):
            if not el.startswith('_') or not el.endswith('_'):
                lis.append(el)
        return msg + str(lis).replace("',", '\n')


class _ListData(object):
    """
    """
    str = s = list = tuple = ['hello', 'world', 'hoge', 'foo', 'bar',
                              'yahoo', 'google', 'bing']
    int = i = list_int = range(0, 10)
    basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']

    def __repr__(self):
        """SUMMARY

        @Return:
        """
        msg = '{0:*^30}'.format('List Data') + '\n'
        lis = []
        for el in dir(self):
            if not el.startswith('_') or not el.endswith('_'):
                lis.append(el)
        return msg + str(lis).replace("',", '\n')


class _DicData(object):
    """
    """
    dictionary = dic = d = {'hello':'hello',
                            'world':'world',
                            'hoge':'hoge',
                            'foo':'foo',
                            'bar':'bar',
                            'yahoo':'yahoo',
                            'google':'google',
                            'bing':'bing'}

    def __repr__(self):
        """SUMMARY

        @Return:
        """
        msg = '{0:*^30}'.format('Dictionary Data') + '\n'
        lis = []
        for el in dir(self):
            if not el.startswith('_') or not el.endswith('_'):
                lis.append(el)
        return msg + str(lis).replace("',", '\n')


class _PathData(object):
    """
    """
    notepad = npath = r'C:\Windows\system32\notepad.exe'
    passwd = ppath = '/etc/passwd'

    def __repr__(self):
        """SUMMARY

        @Return:
        """
        msg = '{0:*^30}'.format('Path Data') + '\n'
        lis = []
        for el in dir(self):
            if not el.startswith('_') or not el.endswith('_'):
                lis.append(el)
        return msg + str(lis).replace("',", '\n')


class MyTestData(object):
    """
    """
    text = txt = t = _TextData()
    string = str = s = _StringData()
    list = lis = l = _ListData()
    dictionary = dic = d = _DicData()
    path = p = _PathData()

    def __repr__(self):
        """SUMMARY

        @Return:
        """
        msg = '{0:*^30}'.format('Test Data') + '\n'
        lis = []
        for el in dir(self):
            if not el.startswith('_') or not el.endswith('_'):
                lis.append(el)
        return msg + str(lis).replace("',", '\n')


def test():
    pass


if __name__ == '__main__':
    test()

* Wed 11 Sep 2013 02:55:54 PM JST

* Wed 11 Sep 2013 02:55:54 PM JST

* Wed 11 Sep 2013 02:55:54 PM JST
from pprint import pprint

* Wed 11 Sep 2013 02:56:53 PM JST
MyTestData
* Wed 11 Sep 2013 03:00:22 PM JST
""" DiskUsage -- Disk usage

$Revision$

"""


# for debug
import cgitb as _cgitb
_cgitb.enable(format='text')

import os as _os
import collections

__revision__ = '$Revision$'
__version__ = '0.1.0'


_ntuple_diskusage = collections.namedtuple('usage', 'total used free')

def disk_usage(path):
    st = _os.statvfs(path)
    free = st.f_bavail * st.f_frsize
    total = st.f_blocks * st.f_frsize
    used = (st.f_blocks - st.f_bfree) * st.f_frsize
    return _ntuple_diskusage(total, used, free)

def bytes2human(n):
    symbols = ('K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
    prefix = {}
    for i, s in enumerate(symbols):
        prefix[s] = 1 << (i+1)*10
    for s in reversed(symbols):
        if n >= prefix[s]:
            value = float(n) / prefix[s]
            return '%.1f%s' % (value, s)
    return "%sB" % n


def test():
    pass


if __name__ == '__main__':
    test()

* Wed 11 Sep 2013 03:00:33 PM JST
__revision__ = "$Revision$"
__version__ = "0.1.0"

__all__ = [ '' ]

* Wed 11 Sep 2013 03:01:48 PM JST
"""
$Revision$
$LastChangedRevision$
$LastChangedDate$

knock.py

"""

import sys
from socket import socket, AF_INET, SOCK_STREAM
from contextlib import closing

from portscan import tcpscan
import os as _os

def scan(host, port, timeout=0.5, verbose=False):
    """Send packet.

    Arguments:
    - ``:
    """
    with closing(socket(AF_INET, SOCK_STREAM)) as sock:
        timeout = float(timeout)
        sock.settimeout(timeout)
        print '[Scanning Ports "%s"]' % host
        try:
            status = sock.connect_ex((host, port))
        except:
            print "Cannot connect %s" % host
            sys.exit(1)
    if 0 == status:
        if verbose:
            print host + " port %d: OPEN" % port
        return True
    else:
        if verbose:
            print host + " port %d: CLOSE" % port
        return False

def knock(host, portlist, verbose=False):
    """Send sequential packet.

    Arguments:

    - `host`: target host
    - `portlist`: tuple of port number list
    """
    for port in portlist:
        tcpscan(host, port)
        if verbose:
            _os.write(1, '{0:5}, '.format(port))
    if verbose:
        print('\n')

* Wed 11 Sep 2013 03:04:00 PM JST
# WARNING: (Atami) [2013/02/17]
# Do not move file from this directory.
# if not has python environment, cannot import modules.
"""\

Name: portable_env.py
$Revision$

"""
import os
import sys

import argparse

import winutiles as _win
from portable import DRIVE_DIR
import types


__revision__ = "$Revision$"
__version__ = "0.1.0"

EDIT_FLAG = False

PATH_DIC = {
    'PYTHON'     : ['system\\PortablePython\\App',
                    'system\\PortablePython\\App\\Scripts'],
    'USB'        : ['Dos\\bat', 'Dos\\unixutils'],
    'PUTTY'      : ['Internet\\putty'],
    'DOXYGEN'    : ['Dos\\graphviz\\release\\bin'],
    }

# other user maybe use paths
COMMON = {
    'PYTHONPATH' : ['Lib\\.pylib', 'Office\\emacs\\.emacs.d\\data_e\\pylib'],
    'PYTHONSTARTUP' : ['Office\\emacs\\.emacs.d\\data_e\\pylib\\pyStartup.py'],
    }


class _EnvData(object):
    """
    """
    modified = False
    my_orig = {'PYTHON'     : ['system\\PortablePython\\App',
                               'system\\PortablePython\\App\\Scripts'],
               'USB'        : ['Dos\\bat', 'Dos\\unixutils'],
               'PUTTY'      : ['Internet\\putty'],
               'DOXYGEN'    : ['Dos\\graphviz\\release\\bin'],}
    # other user maybe have
    commons = {
    'PYTHONPATH' : ['Lib\\.pylib', 'Office\\emacs\\.emacs.d\\data_e\\pylib'],
    'PYTHONSTARTUP' : ['Office\\emacs\\.emacs.d\\data_e\\pylib\\pyStartup.py']}


class Install(_EnvData):
    """
    """

    def __init__(self, permission=False):
        """

        Arguments:
        - `permission`:
        """
        self._all_data = None
        self._permission = permission

    def all_data(self, force=False):
        """SUMMARY
        """
        if not self._all_data or force:
            dic = dict(self.my_orig)
            self._all_data = dic.update(self.commons)
        return self._all_data

    def confirm(self):
        """SUMMARY
        """
        if not self._permission:
            self._permission = _confirm_window()
        return self._permission

    def subkey(self, dic):
        """SUMMARY
        """
        assert (type(dic) is types.DictType), 'Must be dictionary.'
        assert (type(dic.values()[0]) is types.ListType), 'Not has list.'
        for name, values in dic.iteritems():
            for value in values:
                # no exists name
                if '' == _win.env.get_env(name):
                    if not self.confirm():
                        sys.exit()
                    _win.env.set_env(name, os.path.join(DRIVE_DIR, value))
                # exists name and already have same value
                elif os.path.join(DRIVE_DIR, value) in _win.env.get_env(name):
                    continue
                # exists name and similer value
                elif value in _win.env.get_env(name):
                    if self.confirm():
                        _win.env.chg_drive(DRIVE_DIR, name, value)
                # no exists value on name
                else:
                    if self.confirm():
                        env = (_win.env.get_env(name) +
                               ';' + os.path.join(DRIVE_DIR, value))
                        _win.env.set_env(name, env)


class UnInstall(_EnvData):
    """
    """
    pass


def install_myenv():
    """SUMMARY
    """
    dic = dict(PATH_DIC)
    print(dic)
    dic.update(COMMON) #
    print(dic)
    subkey_append(dic)
    path_append(PATH_DIC)
    _win.env.update_env()


def subkey_append(dic):
    """SUMMARY
    """
    for name, values in dic.iteritems():
        for value in values:
            # no exists name
            if '' == _win.env.get_env(name):
                if prompt_exit():
                    _win.env.set_env(name, os.path.join(DRIVE_DIR, value))
            # exists name and already have same value
            elif os.path.join(DRIVE_DIR, value) in _win.env.get_env(name):
                continue
            # exists name and similer value
            elif value in _win.env.get_env(name):
                if prompt_exit():
                    _win.env.chg_drive(DRIVE_DIR, name, value)
            # no exists value on name
            else:
                if prompt_exit():
                    env = (_win.env.get_env(name) +
                           ';' + os.path.join(DRIVE_DIR, value))
                    _win.env.set_env(name, env)


def path_append(path_list):
    """Add to 'PATH' subkey."""
    orig = new = _win.env.get_env('PATH')
    new = new.split(';')
    for name in path_list:
        val_name = '%' + name + '%'
        if not tup_in_string(val_name, new):
            new.append(val_name)
    new = filter(None, new) # trim empty '' string
    new_path = ';'.join(new)
    if orig != new_path:
        if prompt_exit():
            _win.env.set_env('PATH', new_path, _win.env.REG_EXPAND_SZ)


def tup_in_string(str_, tup):
    """SUMMARY
    """
    for s in tup:
        if str_ in s:
            return True
    return False

## Uninstall
#
def uninstall_myenv():
    """SUMMARY
    """
    del_path(PATH_DIC)
    del_subkey(PATH_DIC)
    del_value(COMMON)
    _win.env.update_env()


def del_path(dic):
    """SUMMARY
    """
    for name in dic:
        value = '%' + name + '%'
        del_value1('PATH', value)


def del_subkey(dic):
    """SUMMARY
    """
    for item in dic:
        _win.env.del_env(item)


def del_value(dic):
    """SUMMARY
    """
    for name, values in dic.iteritems():
        for value in values:
            del_value1(name, value)


def del_value1(name, value):
    """SUMMARY

    Arguments:
    - `name`:
    - `value`:
    """
    newenv = []
    for item in _win.env.get_env(name).split(';'):
        if not value in item:
            newenv.append(item)
    if [] == newenv:
        _win.env.del_env(name)
    else:
        newenv = filter(None, newenv) # trim empty '' string
        _win.env.set_env(name, ';'.join(newenv))

## GUI prompt
#
def prompt():
    """SUMMARY
    """
    import wx
    app = wx.PySimpleApp()
    dig = wx.MessageDialog(None,
                           u'環境変数を変更しますか？',
                           'Environment Settings',
                           wx.YES_NO|wx.ICON_QUESTION)
    result = dig.ShowModal()
    dig.Destroy()
    return result == wx.ID_YES


def prompt_exit():
    """SUMMARY
    """
    global EDIT_FLAG
    if not EDIT_FLAG:
        EDIT_FLAG = prompt()
    if EDIT_FLAG:
        return True
    sys.exit()


def _confirm_window():
    """SUMMARY
    """
    import wx
    app = wx.PySimpleApp()
    dig = wx.MessageDialog(None,
                           u'環境変数を変更しますか？',
                           'Environment Settings',
                           wx.YES_NO|wx.ICON_QUESTION)
    result = dig.ShowModal()
    dig.Destroy()
    return result == wx.ID_YES


def _main():
    global EDIT_FLAG
    parser = argparse.ArgumentParser(description="""\
    Install or Uninstall my portable environment.""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,
                        help='Version Strings.')

    parser.add_argument('-f', '--force',
                        dest='force',
                        action='store_true',
                        default=False,
                        help='No prompt when edit registry.')

    parser.add_argument('-u', '--uninstall',
                        dest='uninstall',
                        action='store_true',
                        default=False,
                        required=False,
                        help='Uninstall my environment.')

    # (yas/expand-link "argparse_add_argument" t)
    args = parser.parse_args()
    EDIT_FLAG = args.force
    if not args.uninstall:
        install_myenv()
    if args.uninstall:
        uninstall_myenv()

if __name__ == '__main__':
    _main()

* Wed 11 Sep 2013 03:04:21 PM JST
# WARNING: (Atami) [2013/02/17]
# Do not move file from this directory.
# if not has python environment, cannot import modules.

* Wed 11 Sep 2013 03:13:45 PM JST
curdir
* Wed 11 Sep 2013 03:14:03 PM JST

* Wed 11 Sep 2013 03:14:03 PM JST

* Wed 11 Sep 2013 03:14:03 PM JST
    print(os.getcwd())

* Wed 11 Sep 2013 03:15:39 PM JST
will
* Wed 11 Sep 2013 03:17:57 PM JST

* Wed 11 Sep 2013 03:17:57 PM JST

* Wed 11 Sep 2013 03:17:57 PM JST
    print('Serving directory\n"{}"'.format(os.getcwd()))

* Wed 11 Sep 2013 03:18:02 PM JST
print('{0:#^40}'.format(''))
* Wed 11 Sep 2013 03:18:56 PM JST
Serving directory
* Wed 11 Sep 2013 03:19:27 PM JST

* Wed 11 Sep 2013 03:19:27 PM JST

* Wed 11 Sep 2013 03:19:27 PM JST
    print('{0: ^40}'.format(' Do execute this! '))

* Wed 11 Sep 2013 03:19:29 PM JST

* Wed 11 Sep 2013 03:19:29 PM JST

* Wed 11 Sep 2013 03:19:29 PM JST
    print('{0:#^40}'.format(''))

* Wed 11 Sep 2013 03:20:21 PM JST
    print('')
* Thu 12 Sep 2013 03:12:21 PM JST
- 
* Thu 12 Sep 2013 03:13:17 PM JST
- 
* Thu 12 Sep 2013 03:13:17 PM JST
  - 
* Thu 12 Sep 2013 03:14:15 PM JST
apt-get install ethtool]]
* Thu 12 Sep 2013 03:20:46 PM JST
		
* Thu 12 Sep 2013 03:20:51 PM JST
		
* Thu 12 Sep 2013 03:20:53 PM JST
		
* Thu 12 Sep 2013 03:21:52 PM JST
# The primary network interface
allow-hotplug eth1
iface eth1 inet static
        ethernet-wol gb  # for WOL
        address 192.168.1.123
        netmask 255.255.255.0
        network 192.168.1.0
        broadcast 192.168.1.255
        gateway 192.168.1.1
        # dns-* options are implemented by the resolvconf package, if installed
        dns-nameservers 192.168.1.1

* Thu 12 Sep 2013 03:22:13 PM JST

* Thu 12 Sep 2013 03:22:13 PM JST

* Thu 12 Sep 2013 03:22:13 PM JST
		auto eth0     

* Thu 12 Sep 2013 03:22:26 PM JST
		auto eth0     

* Thu 12 Sep 2013 03:22:26 PM JST
		auto eth0     
		iface eth0 inet static

* Thu 12 Sep 2013 03:22:29 PM JST

* Thu 12 Sep 2013 03:22:29 PM JST

* Thu 12 Sep 2013 03:22:29 PM JST
		auto eth0     

* Thu 12 Sep 2013 03:22:31 PM JST
		
* Thu 12 Sep 2013 03:22:48 PM JST
dns-nameservers 192.168.1.1
* Thu 12 Sep 2013 03:23:23 PM JST
# dns-* options are implemented by the resolvconf package, if installed
* Thu 12 Sep 2013 03:28:34 PM JST
QU /data/mydoc/architecture/ki/script# cat init_install.py MM
* Thu 12 Sep 2013 03:29:35 PM JST
[[apt-get_install][apt-get install]]
* Thu 12 Sep 2013 03:31:06 PM JST
change locale]]
* Thu 12 Sep 2013 03:31:13 PM JST
  [[change_locale1][change locale]]
* Thu 12 Sep 2013 03:33:10 PM JST
# dpkg-reconfigure locales
* Thu 12 Sep 2013 03:33:14 PM JST
en_US.UTF-8
* Thu 12 Sep 2013 03:44:38 PM JST
dpkg-reconfigure locales
* Thu 12 Sep 2013 03:44:58 PM JST

* Thu 12 Sep 2013 03:44:58 PM JST
en_US.UTF-8
* Thu 12 Sep 2013 03:44:58 PM JST
en_US.UTF-8

* Thu 12 Sep 2013 03:46:01 PM JST
 [[etc-apt-apt.conf][edit apt.conf]]
* Thu 12 Sep 2013 03:57:30 PM JST
30disable-recommends
* Thu 12 Sep 2013 03:57:43 PM JST
APT
* Thu 12 Sep 2013 03:57:51 PM JST
      
* Thu 12 Sep 2013 03:57:59 PM JST
Install-Recommends "false";
* Thu 12 Sep 2013 03:58:03 PM JST
::   
* Thu 12 Sep 2013 03:58:03 PM JST
	  ::   
* Thu 12 Sep 2013 03:58:04 PM JST
	  ::   
* Thu 12 Sep 2013 03:58:04 PM JST
	  ::   # recommends をインストールさせない。

* Thu 12 Sep 2013 03:58:11 PM JST
::   
* Thu 12 Sep 2013 03:58:11 PM JST
	  ::   
* Thu 12 Sep 2013 03:58:12 PM JST

* Thu 12 Sep 2013 03:58:12 PM JST

* Thu 12 Sep 2013 03:58:12 PM JST


* Thu 12 Sep 2013 03:58:43 PM JST
QU /root/.emacs.d# 333333333333333333333333333333333333333333333333333333333
* Thu 12 Sep 2013 04:00:34 PM JST
# recommends をインストールさせない。
APT
{
Install-Recommends "false";
}

* Thu 12 Sep 2013 04:00:37 PM JST

* Thu 12 Sep 2013 04:00:37 PM JST

* Thu 12 Sep 2013 04:00:37 PM JST
# recommends をインストールさせない。

* Thu 12 Sep 2013 04:03:59 PM JST
deb http://ftp.riken.jp/Linux/debian/debian/ wheezy main contrib non-free
deb-src http://ftp.riken.jp/Linux/debian/debian/ wheezy main contrib non-free

* Thu 12 Sep 2013 04:08:50 PM JST
# deb cdrom:[Debian GNU/Linux 7.1.0 _Wheezy_ - Official amd64 DVD Binary-1 20130615-23:06]/ wheezy contrib main


* Thu 12 Sep 2013 04:08:56 PM JST
deb http://ftp.riken.jp/Linux/debian/debian/ wheezy main contrib non-free
deb-src http://ftp.riken.jp/Linux/debian/debian/ wheezy main contrib non-free

* Thu 12 Sep 2013 04:10:02 PM JST
deb http://ftp.riken.jp/Linux/debian/debian/ wheezy main contrib non-free
deb-src http://ftp.riken.jp/Linux/debian/debian/ wheezy main contrib non-free
deb http://security.debian.org/ wheezy/updates main contrib
deb-src http://security.debian.org/ wheezy/updates main contrib

# deb cdrom:[Debian GNU/Linux 7.1.0 _Wheezy_ - Official amd64 DVD Binary-1 20130615-23:06]/ wheezy contrib main

* Thu 12 Sep 2013 04:28:18 PM JST
apt-listbugs debsums unattended-upgrades anacron p7zip-full ntp ulogd dump subversion cryptsetup sudo w3m w3m-el emacs23 rsync zsh sshfs lsof exim4 hashalot
* Thu 12 Sep 2013 04:30:42 PM JST
cryptsetup
* Thu 12 Sep 2013 04:30:52 PM JST
anacron
* Thu 12 Sep 2013 04:31:00 PM JST
unattended-upgrades
* Thu 12 Sep 2013 04:31:11 PM JST
apt-listbugs
* Thu 12 Sep 2013 04:31:18 PM JST
zsh
* Thu 12 Sep 2013 04:31:40 PM JST
ntp
* Thu 12 Sep 2013 04:31:46 PM JST
lsof
* Thu 12 Sep 2013 04:32:00 PM JST
ulogd
* Thu 12 Sep 2013 04:32:09 PM JST
p7zip-full
* Thu 12 Sep 2013 04:32:20 PM JST
apt-listbugs
* Thu 12 Sep 2013 04:33:16 PM JST
subversion
* Thu 12 Sep 2013 04:34:03 PM JST
m4
* Thu 12 Sep 2013 04:35:16 PM JST
ethtool
* Thu 12 Sep 2013 04:35:48 PM JST

* Thu 12 Sep 2013 04:35:48 PM JST

* Thu 12 Sep 2013 04:35:48 PM JST


* Thu 12 Sep 2013 04:45:44 PM JST
ntpdate
* Thu 12 Sep 2013 04:58:51 PM JST
chkconfig
* Thu 12 Sep 2013 05:06:08 PM JST
localepurge
* Thu 12 Sep 2013 05:21:41 PM JST

* Thu 12 Sep 2013 05:21:42 PM JST
apt-listbugs 
* Thu 12 Sep 2013 05:21:42 PM JST
apt-listbugs debsums unattended-upgrades anacron p7zip-full

* Thu 12 Sep 2013 05:21:42 PM JST
apt-listbugs debsums unattended-upgrades anacron p7zip-full

* Thu 12 Sep 2013 05:21:42 PM JST
apt-listbugs debsums unattended-upgrades anacron p7zip-full
 ntp ulogd dump subversion cryptsetup sudo w3m w3m-el

* Thu 12 Sep 2013 05:21:42 PM JST
apt-listbugs debsums unattended-upgrades anacron p7zip-full
 ntp ulogd dump subversion cryptsetup sudo w3m w3m-el

* Thu 12 Sep 2013 05:21:42 PM JST
apt-listbugs debsums unattended-upgrades anacron p7zip-full
 ntp ulogd dump subversion cryptsetup sudo w3m w3m-el
 emacs23 rsync zsh sshfs lsof exim4 hashalot

* Thu 12 Sep 2013 05:21:55 PM JST
  
* Thu 12 Sep 2013 05:21:56 PM JST
  
* Thu 12 Sep 2013 05:21:57 PM JST
  
* Thu 12 Sep 2013 05:21:59 PM JST
  
* Thu 12 Sep 2013 05:22:00 PM JST
  
* Thu 12 Sep 2013 05:22:03 PM JST
g++
* Thu 12 Sep 2013 05:22:04 PM JST
  g++
* Thu 12 Sep 2013 05:22:06 PM JST
  
* Thu 12 Sep 2013 05:22:07 PM JST
  
* Thu 12 Sep 2013 05:22:09 PM JST
  
* Thu 12 Sep 2013 05:22:10 PM JST
  
* Thu 12 Sep 2013 05:22:12 PM JST
  
* Thu 12 Sep 2013 05:22:13 PM JST
  
* Thu 12 Sep 2013 05:22:14 PM JST
  
* Thu 12 Sep 2013 05:22:18 PM JST
  
* Thu 12 Sep 2013 05:22:20 PM JST
  
* Thu 12 Sep 2013 05:22:22 PM JST
  
* Thu 12 Sep 2013 05:22:23 PM JST
  
* Thu 12 Sep 2013 05:22:25 PM JST
  
* Thu 12 Sep 2013 05:22:26 PM JST
  
* Thu 12 Sep 2013 05:22:27 PM JST
  
* Thu 12 Sep 2013 05:22:32 PM JST
  
* Thu 12 Sep 2013 05:22:33 PM JST
  
* Thu 12 Sep 2013 05:22:34 PM JST
  
* Thu 12 Sep 2013 05:22:36 PM JST
  
* Thu 12 Sep 2013 05:22:37 PM JST
  
* Thu 12 Sep 2013 05:22:38 PM JST
  
* Thu 12 Sep 2013 05:22:39 PM JST
  
* Thu 12 Sep 2013 05:22:40 PM JST
  
* Thu 12 Sep 2013 05:22:41 PM JST
  
* Thu 12 Sep 2013 05:22:42 PM JST
  
* Thu 12 Sep 2013 05:22:43 PM JST
  
* Thu 12 Sep 2013 05:22:45 PM JST
  
* Thu 12 Sep 2013 05:22:46 PM JST
  
* Thu 12 Sep 2013 05:22:47 PM JST
  
* Thu 12 Sep 2013 05:22:49 PM JST
  
* Thu 12 Sep 2013 05:22:50 PM JST
  
* Thu 12 Sep 2013 05:22:51 PM JST
  
* Thu 12 Sep 2013 05:24:55 PM JST
unattended-upgrades apt-listbugs
* Thu 12 Sep 2013 05:25:03 PM JST
apt-listbugs 
* Thu 12 Sep 2013 05:25:25 PM JST
  apt-listbugs 
* Thu 12 Sep 2013 05:27:59 PM JST
patch
* Thu 12 Sep 2013 05:28:16 PM JST
localepurge
* Thu 12 Sep 2013 05:33:42 PM JST
automake 
* Thu 12 Sep 2013 05:33:47 PM JST
  
* Thu 12 Sep 2013 05:33:54 PM JST
automake 
* Thu 12 Sep 2013 05:33:56 PM JST

* Thu 12 Sep 2013 05:33:56 PM JST
  
* Thu 12 Sep 2013 05:33:56 PM JST
  

* Thu 12 Sep 2013 05:33:58 PM JST

* Thu 12 Sep 2013 05:33:58 PM JST

* Thu 12 Sep 2013 05:33:58 PM JST
 rsync

* Thu 12 Sep 2013 05:34:08 PM JST
 zsh
* Thu 12 Sep 2013 05:34:21 PM JST
rsync 
* Thu 12 Sep 2013 05:34:33 PM JST
ntpdate nmap tcpdump 
* Thu 12 Sep 2013 05:34:41 PM JST
traceroute 
* Thu 12 Sep 2013 05:34:55 PM JST
 cryptsetup 
* Thu 12 Sep 2013 05:35:01 PM JST
 sudo
* Thu 12 Sep 2013 05:35:17 PM JST
 ethtool
* Thu 12 Sep 2013 05:35:28 PM JST
finger 
* Thu 12 Sep 2013 05:35:36 PM JST
 loglotate 
* Thu 12 Sep 2013 05:35:51 PM JST
chkconfig 
* Thu 12 Sep 2013 05:36:52 PM JST
p7zip-full 
* Thu 12 Sep 2013 05:37:00 PM JST
 unzip zip
* Thu 12 Sep 2013 05:37:08 PM JST
m4
* Thu 12 Sep 2013 05:37:16 PM JST
 debsums
* Thu 12 Sep 2013 05:37:28 PM JST
 gawk
* Thu 12 Sep 2013 05:37:33 PM JST
 zsh
* Thu 12 Sep 2013 05:37:41 PM JST
lsof
* Thu 12 Sep 2013 05:37:55 PM JST
ntp  ulogd
* Thu 12 Sep 2013 05:38:06 PM JST
 subversion
* Thu 12 Sep 2013 05:38:20 PM JST
 finger
* Thu 12 Sep 2013 05:38:52 PM JST
patch
* Thu 12 Sep 2013 05:38:56 PM JST
  
* Thu 12 Sep 2013 05:39:13 PM JST
unattended-upgrades apt-listbugs localepurge debsums
* Thu 12 Sep 2013 05:40:32 PM JST
 localepurge
* Thu 12 Sep 2013 05:40:51 PM JST
gcc g++ binutils dpkg-dev nasm build-essential make automake m4 patch
* Thu 12 Sep 2013 05:42:32 PM JST
listbugs
* Thu 12 Sep 2013 05:42:32 PM JST
apt-listbugs
* Thu 12 Sep 2013 05:43:19 PM JST
listbugs 
* Thu 12 Sep 2013 05:43:20 PM JST
apt-listbugs 
* Thu 12 Sep 2013 05:43:35 PM JST
loglotate chkconfig cryptsetup sudo ethtool anacron less
* Thu 12 Sep 2013 05:45:28 PM JST
ntp ulogd subversion
* Thu 12 Sep 2013 05:46:26 PM JST
rsync ntpdate nmap tcpdump traceroute
* Thu 12 Sep 2013 05:46:55 PM JST
python-pip gzip p7zip-full unzip zip gawk zsh lsof finger
* Thu 12 Sep 2013 05:48:57 PM JST
 [[change_login_shell1][change login shell]]
* Thu 12 Sep 2013 06:10:08 PM JST
/dev/sdc1  /media/usb auto noauto,rw,user,iocharset=utf8 0 0
* Thu 12 Sep 2013 06:10:47 PM JST
~/.emacs.d/
* Thu 12 Sep 2013 06:13:25 PM JST
	   1:2345:respawn:/sbin/getty 38400 tty1
	   2:23:respawn:/sbin/getty 38400 tty2
	   3:23:respawn:/sbin/getty 38400 tty3
#4:23:respawn:/sbin/getty 38400 tty4
#5:23:respawn:/sbin/getty 38400 tty5
#6:23:respawn:/sbin/getty 38400 tty6

* Thu 12 Sep 2013 06:13:42 PM JST
~/.emacs.d/
* Thu 12 Sep 2013 06:14:03 PM JST
~/.emacs.d/
* Thu 12 Sep 2013 06:16:33 PM JST
(保留)
* Thu 12 Sep 2013 06:16:51 PM JST
etc-login.defs
* Thu 12 Sep 2013 06:19:52 PM JST
~/.emacs.d/
* Thu 12 Sep 2013 06:21:20 PM JST
:/usr/local/games:/usr/games
* Thu 12 Sep 2013 06:23:33 PM JST
# orig /etc/login.defs
* Thu 12 Sep 2013 06:23:42 PM JST
		LOG_OK_LOGINS yes
		SULOG_FILE /var/log/sulog
# remove     /usr/local/games:/usr/games
		ENV_PATH
		UMASK 077
		MD5_CRYPT_ENAB  yes

* Thu 12 Sep 2013 06:23:55 PM JST

* Thu 12 Sep 2013 06:23:55 PM JST
		
* Thu 12 Sep 2013 06:23:55 PM JST
		SULOG_FILE /var/log/sulog

* Thu 12 Sep 2013 06:27:30 PM JST
usermod -G adm t1
* Thu 12 Sep 2013 06:29:16 PM JST
~/.emacs.d/
* Thu 12 Sep 2013 06:30:27 PM JST
# auth       required   pam_wheel.so
* Thu 12 Sep 2013 06:34:11 PM JST
t1 ALL=NOPASSWD: /usr/bin/ssh,/usr/bin/rsync,/sbin/shutdown,/sbin/halt,/sbin/reboot,/bin/mount
* Thu 12 Sep 2013 09:55:59 PM JST
 [[ntp-logrotate][logrotate ntp log]]
* Thu 12 Sep 2013 09:57:28 PM JST
 [[disable_ipv61][disable ipv6]]
* Thu 12 Sep 2013 09:58:04 PM JST
echo net.ipv6.conf.all.disable_ipv6=1 > /etc/sysctl.d/disableipv6.conf
* Thu 12 Sep 2013 09:58:17 PM JST
 
* Thu 12 Sep 2013 10:03:04 PM JST
 [[etc-hosts][edit /etc/hosts]]
* Thu 12 Sep 2013 10:03:31 PM JST
	  192.168.1.1     ro    # default gateway (router)
	  192.168.1.100   m     # haha
	  192.168.1.122   home  # home
	  192.168.1.130   qu    # desktop
	  192.168.1.123   ki    # server

* Thu 12 Sep 2013 10:04:02 PM JST

* Thu 12 Sep 2013 10:04:03 PM JST

* Thu 12 Sep 2013 10:04:03 PM JST
192.168.1.130   m     # haha

* Thu 12 Sep 2013 10:04:07 PM JST

* Thu 12 Sep 2013 10:04:07 PM JST

* Thu 12 Sep 2013 10:04:07 PM JST
192.168.1.123   ki    # server

* Thu 12 Sep 2013 10:04:28 PM JST

* Thu 12 Sep 2013 10:04:28 PM JST

* Thu 12 Sep 2013 10:04:29 PM JST
192.168.1.122   home  # home

* Thu 12 Sep 2013 10:04:36 PM JST

* Thu 12 Sep 2013 10:04:36 PM JST

* Thu 12 Sep 2013 10:04:36 PM JST
192.168.1.130   m     # haha

* Thu 12 Sep 2013 10:07:07 PM JST
 [[remove-file-directory][remove file directory]]
* Thu 12 Sep 2013 10:08:00 PM JST
 [[remove-login-message][remove login message]]
* Thu 12 Sep 2013 10:10:52 PM JST
 [[security-upgrades1][edit /etc/apt/apt.conf.d/50unattended-upgrades]]
* Thu 12 Sep 2013 10:11:37 PM JST
		APT::Periodic::Update-Package-Lists "1";
		APT::Periodic::Download-Upgradeable-Packages "1";
		APT::Periodic::Unattended-Upgrade "1";

* Thu 12 Sep 2013 10:12:33 PM JST
		# nano /etc/apt/apt.conf.d/50unattended-upgrades
		APT::Periodic::Update-Package-Lists "1";
		APT::Periodic::Download-Upgradeable-Packages "1";
		APT::Periodic::Unattended-Upgrade "1";

* Thu 12 Sep 2013 10:12:40 PM JST
nano 
* Thu 12 Sep 2013 10:12:40 PM JST
games
- # 		# nano 
* Thu 12 Sep 2013 10:13:26 PM JST
mkdir /var/log/iptables && touch /var/log/iptables/iptables.log
* Thu 12 Sep 2013 10:13:35 PM JST
 [[iptables-up1][/etc/network/if-up.d/iptables]]
* Thu 12 Sep 2013 10:14:19 PM JST
 [[ulogd1][ulogd]]
* Thu 12 Sep 2013 10:16:12 PM JST
file="/var/log/iptables/iptables.log"
* Thu 12 Sep 2013 10:16:42 PM JST
******* /etc/ulogd.conf
		[LOGEMU]
		file="/var/log/iptables/iptables.log"
		sync=1

* Thu 12 Sep 2013 10:16:48 PM JST
******* 
* Thu 12 Sep 2013 10:16:54 PM JST
  
* Thu 12 Sep 2013 10:16:59 PM JST

* Thu 12 Sep 2013 10:16:59 PM JST

* Thu 12 Sep 2013 10:16:59 PM JST


* Thu 12 Sep 2013 10:21:04 PM JST
 [[sysctl1][sysctl]]
* Thu 12 Sep 2013 10:26:11 PM JST
ethernet-wol gb # for WOL
* Thu 12 Sep 2013 10:26:36 PM JST
# The primary network interface
allow-hotplug eth1
iface eth1 inet static
        ethernet-wol gb  # for WOL
        address 192.168.1.123
        netmask 255.255.255.0
        network 192.168.1.0
        broadcast 192.168.1.255
        gateway 192.168.1.1
        # dns-* options are implemented by the resolvconf package, if installed
        dns-nameservers 192.168.1.1

* Thu 12 Sep 2013 10:27:21 PM JST
sqeeze
* Thu 12 Sep 2013 10:27:35 PM JST
2.6 i686
* Thu 12 Sep 2013 10:28:22 PM JST
219.62.120.21
* Thu 12 Sep 2013 10:32:43 PM JST
  unattended-upgrades debsums
  gcc g++ binutils dpkg-dev nasm build-essential make automake m4 patch
  logrotate chkconfig cryptsetup sudo ethtool anacron less
  ntp ulogd subversion
  rsync ntpdate nmap tcpdump traceroute
  python-pip gzip p7zip-full unzip zip gawk zsh lsof finger
manual:
  localepurge

* Thu 12 Sep 2013 10:33:06 PM JST
added
* Thu 12 Sep 2013 10:35:51 PM JST

* Thu 12 Sep 2013 10:35:51 PM JST

* Thu 12 Sep 2013 10:35:51 PM JST
games:x:5:60:games:/usr/games:/bin/sh

* Thu 12 Sep 2013 10:36:02 PM JST

* Thu 12 Sep 2013 10:36:02 PM JST

* Thu 12 Sep 2013 10:36:02 PM JST
games:x:5:60:games:/usr/games:/bin/sh

* Thu 12 Sep 2013 10:36:13 PM JST

* Thu 12 Sep 2013 10:36:13 PM JST

* Thu 12 Sep 2013 10:36:13 PM JST
games:x:60:

* Thu 12 Sep 2013 10:36:26 PM JST

* Thu 12 Sep 2013 10:36:26 PM JST

* Thu 12 Sep 2013 10:36:26 PM JST
games:x:60:

* Thu 12 Sep 2013 10:36:43 PM JST

* Thu 12 Sep 2013 10:36:43 PM JST

* Thu 12 Sep 2013 10:36:43 PM JST
games:*:15959:0:99999:7:::

* Thu 12 Sep 2013 10:36:53 PM JST

* Thu 12 Sep 2013 10:36:54 PM JST

* Thu 12 Sep 2013 10:36:54 PM JST
games:*:15959:0:99999:7:::

* Thu 12 Sep 2013 10:38:36 PM JST
NTPSERVERS="ntp.nict.jp ntp.jst.mfeed.ad.jp"
* Thu 12 Sep 2013 10:38:46 PM JST
# nict.jp のホームページを見ると頻繁ではないが
# 障害が何度かあるようなので、念のために予備で mfeed.ad.jp も追加。
# mfeed.ad.jp も nict.jp から時間を取得しているよう...

# (独) 情報通信研究機構: ntp.nict.jp
# アクセス制限 1 時間平均 20 回 (1 日合計 480 回) まで
# (cf. 2011 年 7 月 16 日 [[http://www2.nict.go.jp/w/w114/tsp/PubNtp/qa.html#q1-4][ 日本標準時プロジェクト公開 NTP FAQ]])

# インターネットマルチフィード株式会社: ntp.jst.mfeed.ad.jp

* Thu 12 Sep 2013 11:23:34 PM JST
#!/bin/sh


## Valiables
#
SERVER_IP="192.168.1.123"

# /etc/network/if-up.d/iptables-up

PATH=/sbin:/bin:/usr/sbin:/usr/bin

## Enable TCP SYN cookie protection from SYN floods.
#
echo 1 > /proc/sys/net/ipv4/tcp_syncookies

## Disable ICMP redirect acceptance.
#
#echo 0 > /proc/sys/net/ipv4/conf/all/accept_redirects

## Enable bad error message protection
#
#echo 1 > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses

## Log spoofed packets, source routed packets, redirect packets
#
echo 1 > /proc/sys/net/ipv4/conf/all/log_martians

## Disable response to broadcasts.
#
#echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts

### Initialize
##
#
/sbin/iptables -F INPUT
/sbin/iptables -F OUTPUT
/sbin/iptables -F FORWARD
/sbin/iptables -X         # Delete user-define chain
/sbin/iptables -Z         # Zero the packet and byte counters in all chains.

## basic
#
/sbin/iptables -P INPUT DROP
/sbin/iptables -P OUTPUT ACCEPT
/sbin/iptables -P FORWARD DROP

### INPUT
## Allow all INPUT from localhost
#
/sbin/iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -i lo -j ACCEPT -m comment --comment "Allow all INPUT from localhost"

## ssh
#
/sbin/iptables -A INPUT -p tcp --dport 12316 -j ACCEPT -m comment --comment "Allow INPUT ssh port 12316"

## Squid proxy
#
/sbin/iptables -A INPUT -s 192.168.1.0/24 -p tcp --destination-port 8080 -m state --state NEW -j ACCEPT

## Samba
#
/sbin/iptables -A INPUT -p udp -m udp -s 192.168.1.0/24 --dport 137 -j ACCEPT
/sbin/iptables -A INPUT -p udp -m udp -s 192.168.1.0/24 --dport 138 -j ACCEPT
/sbin/iptables -A INPUT -m state --state NEW -m tcp -p tcp -s 192.168.1.0/24 --dport 139 -j ACCEPT
/sbin/iptables -A INPUT -m state --state NEW -m tcp -p tcp -s 192.168.1.0/24 --dport 445 -j ACCEPT

## king service
#
/sbin/iptables -A INPUT -p udp -m udp -s 192.168.1.0/24 --dport 65535 -j ACCEPT


### Allows all established connections
#
/sbin/iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT -m comment --comment "Allows all established connections"

### Logging
#
/sbin/iptables -A INPUT -j ULOG --ulog-prefix "IPTABLES DROP:"


## Block Nmap
#
echo 1 > /proc/sys/net/ipv4/ip_forward

/sbin/iptables -t filter -A INPUT -p TCP -m state --state RELATED,ESTABLISHED -j ACCEPT
/sbin/iptables -t filter -A INPUT -p UDP -m state --state RELATED,ESTABLISHED -j ACCEPT
/sbin/iptables -t filter -A INPUT -p ICMP --icmp-type 8 -s 192.168.1.1/24 -d $SERVER_IP -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
/sbin/iptables -t filter -A INPUT -m state --state INVALID -j DROP

/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ACK,FIN FIN -j LOG --log-prefix "FIN: "
/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ACK,FIN FIN -j DROP

/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ACK,PSH PSH -j LOG --log-prefix "PSH: "
/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ACK,PSH PSH -j DROP

/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ACK,URG URG -j LOG --log-prefix "URG: "
/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ACK,URG URG -j DROP

/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ALL ALL -j LOG --log-prefix "XMAS scan: "
/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ALL ALL -j DROP

/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ALL NONE -j LOG --log-prefix "NULL scan: "
/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ALL NONE -j DROP

/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j LOG --log-prefix "pscan: "
/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP

/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags SYN,FIN SYN,FIN -j LOG --log-prefix "pscan 2: "
/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags FIN,RST FIN,RST -j LOG --log-prefix "pscan 2: "
/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags FIN,RST FIN,RST -j DROP

/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ALL SYN,FIN -j LOG --log-prefix "SYNFIN-SCAN: "
/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ALL SYN,FIN -j DROP

/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ALL URG,PSH,FIN -j LOG --log-prefix "NMAP-XMAS-SCAN: "
/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ALL URG,PSH,FIN -j DROP

/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ALL FIN -j LOG --log-prefix "FIN-SCAN: "
/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ALL FIN -j DROP

/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ALL URG,PSH,SYN,FIN -j LOG --log-prefix "NMAP-ID: "
/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags ALL URG,PSH,SYN,FIN -j DROP

/sbin/iptables -t filter -A INPUT   -p tcp --tcp-flags SYN,RST SYN,RST -j LOG --log-prefix "SYN-RST: "


###### test
##
## SYN-Flooding Protection
#
#iptables -N syn-flood
#iptables -A INPUT -i eth0 -p tcp --syn -j syn-flood
#iptables -A syn-flood -m limit --limit 1/s --limit-burst 4 -j RETURN
#iptables -A syn-flood -j DROP
#
### Make sure that new TCP connections are SYN packets
##
#iptables -A INPUT -i eth0 -p tcp ! --syn -m state --state NEW -j DROP

* Fri 13 Sep 2013 01:20:07 AM JST
/local/lib/python2.7/dist-packages/epc/
* Fri 13 Sep 2013 01:24:44 AM JST
/lib/python2.6/dist-packages/setuptools/tests
* Fri 13 Sep 2013 02:05:45 AM JST

* Fri 13 Sep 2013 02:05:45 AM JST

* Fri 13 Sep 2013 02:05:45 AM JST
    else:

* Fri 13 Sep 2013 02:10:04 AM JST

* Fri 13 Sep 2013 02:10:04 AM JST

* Fri 13 Sep 2013 02:10:04 AM JST
import argparse

* Fri 13 Sep 2013 02:17:42 AM JST
pasuedo
* Fri 13 Sep 2013 02:17:44 AM JST
pasuedo
* Fri 13 Sep 2013 02:18:03 AM JST
pasuedo
* Fri 13 Sep 2013 02:20:39 AM JST
import
* Fri 13 Sep 2013 02:23:41 AM JST
UserWarning1
* Fri 13 Sep 2013 02:24:14 AM JST

* Fri 13 Sep 2013 02:24:14 AM JST

* Fri 13 Sep 2013 02:24:15 AM JST
from unittest import TestCase

* Fri 13 Sep 2013 02:30:54 AM JST

* Fri 13 Sep 2013 02:30:54 AM JST

* Fri 13 Sep 2013 02:30:54 AM JST
        aquos = Aquos('username', '192.168.1.111', port=12345)

* Fri 13 Sep 2013 02:31:36 AM JST
        pasuedo = self.mocker.mock()
        pasuedo.login(ANY)
        self.mocker.result(True)
        self.mocker.replay()

* Fri 13 Sep 2013 02:33:54 AM JST
        pasuedo = self.mocker.mock()
        pasuedo.login(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)
        self.mocker.replay()

* Fri 13 Sep 2013 02:45:17 AM JST
related
* Fri 13 Sep 2013 02:56:17 AM JST
svnadmin: Premature end of content data in dumpstream
* Fri 13 Sep 2013 01:39:33 PM JST
http://www.edmondweblog.com/index.php/2011/01/06/wake-on-lan-wol-su-debian-squeeze/
* Fri 13 Sep 2013 03:14:05 PM JST
# define backup directory name
backup_base_dir = '/data/.backup'
backup_name = 'knight_remote'
backup_path = os.path.join(backup_base_dir, backup_name)

* Fri 13 Sep 2013 03:16:29 PM JST
## check backup dir or decrypt disk
#
def pave_king():
    """SUMMARY

    @Return:
    """
    with king.King(verbose=True) as ki:
        ki.script.pave()
        if not ki.isactive():
            logging.log(10, MSG.get('kidead'))
            sys.exit(MSG.get('kidead'))
        if not ki.ismount():
            logging.log(10, MSG.get('notdecrypted'))
            sys.exit(MSG.get('notdecrypted'))

* Fri 13 Sep 2013 03:16:45 PM JST
import king
* Fri 13 Sep 2013 03:17:03 PM JST
log_base_dir = '/var/log'
log_name = 'backup_ni.log'
log_path = os.path.join(log_base_dir, log_name)
logging.basicConfig(filename=log_path,
                    level=logging.DEBUG,
                    format='%(asctime)s %(message)s')

* Fri 13 Sep 2013 03:18:43 PM JST
                    
* Fri 13 Sep 2013 03:18:45 PM JST
                    
* Fri 13 Sep 2013 03:18:52 PM JST
                    
* Fri 13 Sep 2013 03:19:00 PM JST
                    
* Fri 13 Sep 2013 03:19:32 PM JST
# define message
MSG = {'start': '{0:*^30}'.format('Started Remote Backup'),
       'kidead': 'Failed: king server not active.',
       'notdecrypted': 'Failed: not decrypted disk on king server.',
       'err_runlevel': 'Runlevel Errors: Could not execute this script on this runnlevel.\n{} revel only',
       }

* Fri 13 Sep 2013 03:50:48 PM JST
return 0
* Fri 13 Sep 2013 03:52:27 PM JST

* Fri 13 Sep 2013 03:52:27 PM JST

* Fri 13 Sep 2013 03:52:27 PM JST
                   '/etc/fstab',

* Fri 13 Sep 2013 03:52:27 PM JST
                   '/etc/fstab',

* Fri 13 Sep 2013 03:52:27 PM JST
                   '/etc/fstab',
                   '/etc/crypttab',

* Fri 13 Sep 2013 03:53:35 PM JST

* Fri 13 Sep 2013 03:53:35 PM JST

* Fri 13 Sep 2013 03:53:35 PM JST
DATE_FORMAT_DEFAULT = '%Y%m%d'

* Fri 13 Sep 2013 03:58:08 PM JST
class LinkDestLocalBackup(object):
    """
    """
    _datefmt = '%Y%m%d'
    _full_ext = '.full'
    _incr_ext = '.incr'
    _opt = ['-a']
    _link_dest = '--link-dest='
    _excludes = EXCLUDE_DEFALUT
    _lotate_max = 30
    _log = _logging
    _bkupname = ''
    _bkupmethod = ''
    _bkupfullpath = ''
    _linkname = 'latest'
    _linkrealpath = ''

    def __init__(self, src, bkupdir, lotate=False, logname=None):
        """

        Arguments:
        - `src`:
        - `dest`:
        """
        if logname:
            self._log.basicConfig(filename=_os.path.join('/var/log', logname),
                                    level=_logging.DEBUG,
                                    format='%(asctime)s %(message)s')
        else:
            self._log = None

        self.src = src
        self.bkupdir = bkupdir
        self._lotate = lotate

        # for v in [src, dest]:
            # if not _os.path.exists(v):
                # raise ValueError('{0} does not exists'.format(v))

    def add_exclude(self, ext):
        """SUMMARY

        @Arguments:

        - `ext`:

        @Return:
        """
        self._excludes = add2list(self._excludes, ext)

    def add_opt(self, opt):
        """SUMMARY

        @Arguments:

        - `opt`:

        @Return:
        """
        self._opt = add2list(self._opt, opt)

    def backup(self):
        """SUMMARY

        @Return:
        """
        if self.bkupmethod == self._incr_ext:
            if self._log:
                self._log.log(10, 'Start: Incremental Backup')
            self.lotate()
            self.incrementalbackup()
        else: # full backup
            if self._log:
                self._log.log(10, 'Start: Full Backup')
            self.fullbackup()
        self.makelink()

    def fullbackup(self):
        """SUMMARY

        @Return:
        """
        self._backup()

    def incrementalbackup(self):
        """SUMMARY

        @Return:
        """
        if -1 == ''.join(self._opt).find('--link-dest='):
            self._opt.append('--link-dest=' + self.linkrealpath)
        self._backup()

    def _backup(self):
        """SUMMARY

        @Return:
        """
        cmdline = self.cmdline
        print(cmdline)
        if self._log:
            self._log.log(10, 'Execute: '.format(cmdline))
        try:
            _sbp.check_call(cmdline, shell=True)
        except _sbp.CalledProcessError:
            _sys.exit(1)

    @property
    def cmdline(self):
        """SUMMARY

        @Return:
        """
        return ' '.join([CMD.get('rsync')] + [self.options] +
                        [self.src, self.bkupfullpath])

    @property
    def options(self):
        """SUMMARY

        @Return:
        """
        return ' '.join(self._opt + [self.excludes])

    @property
    def excludes(self):
        """SUMMARY

        @Return:
        """
        return ' '.join(['--exclude=' + x for x in self._excludes])

    @property
    def bkupfullpath(self):
        """SUMMARY

        @Return:
        """
        if not self._bkupfullpath:
            self._bkupfullpath = _os.path.join(self.bkupdir, self.bkupname)
        return self._bkupfullpath

    @property
    def bkupname(self):
        """SUMMARY

        @Return:
        """
        if not self._bkupname:
            self._bkupname = _date.today().strftime(self._datefmt)
            self._bkupname += self.bkupmethod
        return self._bkupname

    @property
    def linkrealpath(self):
        """SUMMARY

        @Return:
        """
        if not self._linkrealpath:
            self._linkrealpath = _os.path.realpath(
                _os.path.join(self.bkupdir, self._linkname))
        return self._linkrealpath

    @property
    def bkupmethod(self):

        """SUMMARY

        @Return:
        """
        if not self._bkupmethod:
            if self._isfullexists():
                self._bkupmethod = self._incr_ext
            else:
                self._bkupmethod = self._full_ext
        return self._bkupmethod


    def _isfullexists(self):
        """SUMMARY

        @Return:
        """
        return self._globbkupdir('*' + self._full_ext) != []

    def _globbkupdir(self, str_):
        """SUMMARY

        @Arguments:

        - `str_`:

        @Return:
        """
        return _glob(_os.path.join(self.bkupdir, str_))

    def lotate(self):
        """SUMMARY

        @Return:
        """
        if not self._lotate:
            return
        globs = self._globbkupdir(self._incr_ext)
        while self._lotate_max <= len(globs):
            oldest = globs.sort().pop(0)
            if self._log:
                self._log.log(10, 'Lotate: Removed {0}'.format(oldest))
            _shutil.rmtree(oldest)

    def makelink(self):
        """SUMMARY

        @Return:
        """
        latestfullpath = _os.path.join(self.bkupdir, self._linkname)
        if _os.path.islink(latestfullpath):
            _os.unlink(latestfullpath)
        cmdline = [CMD.get('ln'), '-s', self._bkupfullpath, latestfullpath]
        print(' '.join(cmdline))
        if self._log:
            self._log.log(10, 'Link: {0}'.format(' '.join(cmdline)))
        _sbp.call(cmdline)
        if _os.path.islink(latestfullpath) and self._log:
            self._log.log(10, 'Link: {0}'.format('OK exists'))

* Fri 13 Sep 2013 03:58:22 PM JST
import os as _os
* Fri 13 Sep 2013 03:58:31 PM JST
import logging as _logging
* Fri 13 Sep 2013 03:58:44 PM JST
from datetime import date as _date
* Fri 13 Sep 2013 03:58:56 PM JST
EXCLUDE_DEFALUT = ['/lost+found',
                   '/sys/*',
                   '/dev/*',
                   '/proc/*',
                   '/run/*',
                   '/tmp/*',
                   '/share/*',
                   '/media/*',
                   '/mnt/*',
                   '/var/run/*',
                   '/var/lock/*',
                   '/lib/udev/devices/console',
                   '/lib/udev/devices/loop0',
                   '/lib/udev/devices/null',
                   '/lib/udev/devices/ppp',
                   '/lib/udev/devices/net/tun',
                   '/lib/modules/*/volatile/.mounted',
                   '/data/*',
                   '/var/cache/apt/archive/*',
                   '/home/*/.mozilla/firefox/*.default/Cache/*',
                   '/home/*/.cache/google-chrome/Default/*',
                   '/root/.mozilla/firefox/*.default/Cache/*',
                   '/root/.cache/google-chrome/Default/*',
                   '/root/.local/share/Trash/files/*',
                   '/root/.local/share/Trash/info/*',
                   ]

* Fri 13 Sep 2013 03:59:07 PM JST
def add2list(list_, additions):
    """SUMMARY



    @Arguments:

    - `list_`:
    - `additions`:

    @Return: unique list
    """
    from types import StringType, ListType
    if type(additions) == StringType:
        list_.append(additions)
    elif type(additions) == ListType:
        list_ += additions
    else:
        raise ValueError('Set only string or list type.'
                         '\nYou setted {0}'.format(type(additions)))
    return list(set(list_))


* Fri 13 Sep 2013 03:59:48 PM JST
link_dest = '--link-dest='
* Fri 13 Sep 2013 04:00:06 PM JST
import subprocess as _sbp
* Fri 13 Sep 2013 04:00:28 PM JST
from ref import CMD
* Fri 13 Sep 2013 04:00:45 PM JST
import shutil as _shutil
* Fri 13 Sep 2013 04:00:50 PM JST
from glob import glob as _glob
* Fri 13 Sep 2013 04:02:19 PM JST
class LinkDestLocalBackup(object):
    """
    """
    _datefmt = '%Y%m%d'
    _full_ext = '.full'
    _incr_ext = '.incr'
    _opt = ['-a']
    _link_dest = '--link-dest='
    _excludes = EXCLUDE_DEFALUT
    _lotate_max = 30
    _log = _logging
    _bkupname = ''
    _bkupmethod = ''
    _bkupfullpath = ''
    _linkname = 'latest'
    _linkrealpath = ''

    def __init__(self, src, bkupdir, lotate=False, logname=None):
        """

        Arguments:
        - `src`:
        - `dest`:
        """
        if logname:
            self._log.basicConfig(filename=_os.path.join('/var/log', logname),
                                    level=_logging.DEBUG,
                                    format='%(asctime)s %(message)s')
        else:
            self._log = None

        self.src = src
        self.bkupdir = bkupdir
        self._lotate = lotate

        # for v in [src, dest]:
            # if not _os.path.exists(v):
                # raise ValueError('{0} does not exists'.format(v))

    def add_exclude(self, ext):
        """SUMMARY

        @Arguments:

        - `ext`:

        @Return:
        """
        self._excludes = add2list(self._excludes, ext)

    def add_opt(self, opt):
        """SUMMARY

        @Arguments:

        - `opt`:

        @Return:
        """
        self._opt = add2list(self._opt, opt)

    def backup(self):
        """SUMMARY

        @Return:
        """
        if self.bkupmethod == self._incr_ext:
            if self._log:
                self._log.log(10, 'Start: Incremental Backup')
            self.lotate()
            self.incrementalbackup()
        else: # full backup
            if self._log:
                self._log.log(10, 'Start: Full Backup')
            self.fullbackup()
        self.makelink()

    def fullbackup(self):
        """SUMMARY

        @Return:
        """
        self._backup()

    def incrementalbackup(self):
        """SUMMARY

        @Return:
        """
        if -1 == ''.join(self._opt).find('--link-dest='):
            self._opt.append('--link-dest=' + self.linkrealpath)
        self._backup()

    def _backup(self):
        """SUMMARY

        @Return:
        """
        cmdline = self.cmdline
        print(cmdline)
        if self._log:
            self._log.log(10, 'Execute: '.format(cmdline))
        try:
            _sbp.check_call(cmdline, shell=True)
        except _sbp.CalledProcessError:
            _sys.exit(1)

    @property
    def cmdline(self):
        """SUMMARY

        @Return:
        """
        return ' '.join([CMD.get('rsync')] + [self.options] +
                        [self.src, self.bkupfullpath])

    @property
    def options(self):
        """SUMMARY

        @Return:
        """
        return ' '.join(self._opt + [self.excludes])

    @property
    def excludes(self):
        """SUMMARY

        @Return:
        """
        return ' '.join(['--exclude=' + x for x in self._excludes])

    @property
    def bkupfullpath(self):
        """SUMMARY

        @Return:
        """
        if not self._bkupfullpath:
            self._bkupfullpath = _os.path.join(self.bkupdir, self.bkupname)
        return self._bkupfullpath

    @property
    def bkupname(self):
        """SUMMARY

        @Return:
        """
        if not self._bkupname:
            self._bkupname = _date.today().strftime(self._datefmt)
            self._bkupname += self.bkupmethod
        return self._bkupname

    @property
    def linkrealpath(self):
        """SUMMARY

        @Return:
        """
        if not self._linkrealpath:
            self._linkrealpath = _os.path.realpath(
                _os.path.join(self.bkupdir, self._linkname))
        return self._linkrealpath

    @property
    def bkupmethod(self):

        """SUMMARY

        @Return:
        """
        if not self._bkupmethod:
            if self._isfullexists():
                self._bkupmethod = self._incr_ext
            else:
                self._bkupmethod = self._full_ext
        return self._bkupmethod


    def _isfullexists(self):
        """SUMMARY

        @Return:
        """
        return self._globbkupdir('*' + self._full_ext) != []

    def _globbkupdir(self, str_):
        """SUMMARY

        @Arguments:

        - `str_`:

        @Return:
        """
        return _glob(_os.path.join(self.bkupdir, str_))

    def lotate(self):
        """SUMMARY

        @Return:
        """
        if not self._lotate:
            return
        globs = self._globbkupdir(self._incr_ext)
        while self._lotate_max <= len(globs):
            oldest = globs.sort().pop(0)
            if self._log:
                self._log.log(10, 'Lotate: Removed {0}'.format(oldest))
            _shutil.rmtree(oldest)

    def makelink(self):
        """SUMMARY

        @Return:
        """
        latestfullpath = _os.path.join(self.bkupdir, self._linkname)
        if _os.path.islink(latestfullpath):
            _os.unlink(latestfullpath)
        cmdline = [CMD.get('ln'), '-s', self._bkupfullpath, latestfullpath]
        print(' '.join(cmdline))
        if self._log:
            self._log.log(10, 'Link: {0}'.format(' '.join(cmdline)))
        _sbp.call(cmdline)
        if _os.path.islink(latestfullpath) and self._log:
            self._log.log(10, 'Link: {0}'.format('OK exists'))

* Fri 13 Sep 2013 04:02:33 PM JST
import sys as _sys
import os as _os
import logging as _logging
from datetime import date as _date
import subprocess as _sbp
import shutil as _shutil
from glob import glob as _glob

from ref import CMD

* Fri 13 Sep 2013 04:02:39 PM JST

* Fri 13 Sep 2013 04:02:39 PM JST

* Fri 13 Sep 2013 04:02:40 PM JST
import sys as _sys

* Fri 13 Sep 2013 04:04:00 PM JST
class LinkDestRemoteBackup(LinkDestLocalBackup):
    """
    """
    _mntpoint = '/mnt/sshfs'

    def __init__(self, src, bkupdir, rname, lotate=False, logname=None):
        """
        """
        self.src = src
        self.rname = rname
        self.bkupdir = bkupdir
        self.lbkupdir = self._mntpoint
        self.rbkupdir = self.rname + ':' + self.bkupdir
        self.linkpath = _os.path.join(self.bkupdir, self._linkname)
        self._lotate = lotate
        if logname:
            self._log = _logging.basicConfig(
                filename=_os.path.join('/var/log', logname),
                level=_logging.DEBUG,
                format='%(asctime)s %(message)s')
        else:
            self._log = None

    def backup(self):
        """SUMMARY

        @Return:
        """
        self._sshfs()
        if self.bkupmethod == self._incr_ext:
            if self._log:
                self._log.log(10, 'Start: Incremental Backup')
            self.lotate()
            self.incrementalbackup()
        else: # full buckup
            if self._log:
                self._log.log(10, 'Start: Full Backup')
            self.fullbackup()
        self.makelink()

    def restore(self):
        """SUMMARY

        @Return:
        """
        self.add_opt(['-z', '-v'])
        cmdline = ' '.join([CMD.get('rsync')] + ['--delete', '--force'] +
                           [self.options] +
                           [self.rname + ':' + self.linkpath + '/'] +
                           ['/'])
        _sbp.check_call(cmdline, shell=True)

    @property
    def linkrealpath(self):
        """SUMMARY

        @Return:
        """
        if not self._linkrealpath:
            self._linkrealpath = _os.path.realpath(
                _os.path.join(self.lbkupdir, self._linkname))
        return self._linkrealpath

    @property
    def cmdline(self):
        """SUMMARY

        @Return:
        """
        return ' '.join([CMD.get('rsync')] + [self.options] +
                        [self.src, self.rname + ':' + self.bkupfullpath])

    def _globbkupdir(self, str_):
        """SUMMARY

        @Arguments:

        - `str_`:

        @Return:
        """
        return _glob(_os.path.join(self.lbkupdir, str_))

    def lotate(self):
        """SUMMARY

        @Return:
        """
        pass

    def makelink(self):
        """SUMMARY

        @Return:
        """
        # delete link
        linklocalfullpath = _os.path.join(self.lbkupdir, self._linkname)
        if _os.path.islink(linklocalfullpath):
            _os.unlink(linklocalfullpath)
        # make link
        cmdline = ['ssh', self.rname, "'" + CMD.get('ln'),
                         '-s', self.bkupfullpath,
                         _os.path.join(self.bkupdir, self._linkname) + "'"]
        if self._log:
            self._log.log(10, 'Link: {0}'.format(' '.join(cmdline)))
        print(' '.join(cmdline))
        _sbp.check_call([' '.join(cmdline)], shell=True)

    def _sshfs(self):
        """SUMMARY

        @Return:
        """
        if _os.path.ismount('/mnt'):
            _sbp.Popen([CMD.get('umount'), '/mnt'])
        if _os.path.ismount(self._mntpoint):
            _sbp.Popen([CMD.get('umount'), self._mntpoint])
        if not _os.path.exists(self._mntpoint):
            _os.mkdir(self._mntpoint)
        _sbp.check_call([CMD.get('sshfs'), self.rbkupdir, self._mntpoint])

    def __exit__(self):
        """SUMMARY

        @Return:
        """
        for command, location in [('umount', self._mntpoint),
                              ('rmdir', self._mntpoint)]:
            try:
                _sbp.Popen([CMD.get(command), location])
            except:
                pass


* Fri 13 Sep 2013 04:04:39 PM JST
import sys as _sys
import os as _os
import logging as _logging
from datetime import date as _date
import subprocess as _sbp
import shutil as _shutil
from glob import glob as _glob

from ref import CMD

* Fri 13 Sep 2013 04:05:23 PM JST

* Fri 13 Sep 2013 04:05:23 PM JST

* Fri 13 Sep 2013 04:05:23 PM JST
from datetime import date as _date

* Fri 13 Sep 2013 04:05:24 PM JST

* Fri 13 Sep 2013 04:05:24 PM JST

* Fri 13 Sep 2013 04:05:24 PM JST
import shutil as _shutil

* Fri 13 Sep 2013 04:06:26 PM JST

* Fri 13 Sep 2013 04:06:26 PM JST

* Fri 13 Sep 2013 04:06:26 PM JST
from ref import CMD

* Fri 13 Sep 2013 04:13:23 PM JST

* Fri 13 Sep 2013 04:13:24 PM JST

* Fri 13 Sep 2013 04:13:24 PM JST
link_dest = '--link-dest='

* Fri 13 Sep 2013 04:13:58 PM JST
def add2list(list_, additions):
    """SUMMARY



    @Arguments:

    - `list_`:
    - `additions`:

    @Return: unique list
    """
    from types import StringType, ListType
    if type(additions) == StringType:
        list_.append(additions)
    elif type(additions) == ListType:
        list_ += additions
    else:
        raise ValueError('Set only string or list type.'
                         '\nYou setted {0}'.format(type(additions)))
    return list(set(list_))


* Fri 13 Sep 2013 04:14:15 PM JST

* Fri 13 Sep 2013 04:14:15 PM JST

* Fri 13 Sep 2013 04:14:15 PM JST
import sys as _sys

* Fri 13 Sep 2013 04:32:27 PM JST
        pasuedo = self.mocker.mock(Aquos)
        pasuedo.login(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)
        self.mocker.replay()

* Fri 13 Sep 2013 04:40:20 PM JST
mocker
* Fri 13 Sep 2013 04:40:37 PM JST
__class__.
* Fri 13 Sep 2013 04:46:46 PM JST

* Fri 13 Sep 2013 04:46:46 PM JST

* Fri 13 Sep 2013 04:46:46 PM JST
        print(dir(self.mocker))

* Fri 13 Sep 2013 04:46:52 PM JST
mock
* Fri 13 Sep 2013 04:51:56 PM JST

* Fri 13 Sep 2013 04:51:56 PM JST

* Fri 13 Sep 2013 04:51:56 PM JST
        self._setcommand()

* Fri 13 Sep 2013 04:52:19 PM JST

* Fri 13 Sep 2013 04:52:19 PM JST

* Fri 13 Sep 2013 04:52:19 PM JST
        self._setcommand()

* Fri 13 Sep 2013 04:52:58 PM JST
Aquos
* Fri 13 Sep 2013 04:55:42 PM JST
import type
* Fri 13 Sep 2013 04:55:50 PM JST
_port
* Fri 13 Sep 2013 05:06:19 PM JST

* Fri 13 Sep 2013 05:06:19 PM JST

* Fri 13 Sep 2013 05:06:19 PM JST
        self.mocker.replay()

* Fri 13 Sep 2013 05:06:20 PM JST

* Fri 13 Sep 2013 05:06:20 PM JST

* Fri 13 Sep 2013 05:06:21 PM JST
        self.mocker.replay()

* Fri 13 Sep 2013 05:06:56 PM JST
self.
* Fri 13 Sep 2013 05:06:56 PM JST
        self.
* Fri 13 Sep 2013 05:07:11 PM JST
_sock
* Fri 13 Sep 2013 05:07:25 PM JST
self.mocker.result(True)
* Fri 13 Sep 2013 05:07:27 PM JST
        self.mocker.result(True)
        self.mocker.count(0, None)

* Fri 13 Sep 2013 05:07:32 PM JST
        self.pasuedo.recv(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)
        

* Fri 13 Sep 2013 05:08:46 PM JST
True
* Fri 13 Sep 2013 05:09:53 PM JST
        self.pasuedo.recv(ANY)
        self.mocker.result('OK')
        self.mocker.count(0, None)

* Fri 13 Sep 2013 05:10:04 PM JST

* Fri 13 Sep 2013 05:10:04 PM JST

* Fri 13 Sep 2013 05:10:04 PM JST
        self.mocker.result('OK')

* Fri 13 Sep 2013 05:10:04 PM JST
        self.mocker.result('OK')

* Fri 13 Sep 2013 05:10:05 PM JST
        self.mocker.result('OK')
        self.mocker.count(0, None)

* Fri 13 Sep 2013 05:11:02 PM JST

* Fri 13 Sep 2013 05:11:02 PM JST

* Fri 13 Sep 2013 05:11:02 PM JST
        self.pasuedo.send(ANY)

* Fri 13 Sep 2013 05:11:19 PM JST
aquos = Aquos('username', '192.168.1.111', port=12345)
* Fri 13 Sep 2013 05:20:18 PM JST
self.
* Fri 13 Sep 2013 05:20:19 PM JST
self.
* Fri 13 Sep 2013 05:21:08 PM JST

* Fri 13 Sep 2013 05:21:08 PM JST

* Fri 13 Sep 2013 05:21:08 PM JST
        pasuedo.mocker

* Fri 13 Sep 2013 05:21:56 PM JST
self.
* Fri 13 Sep 2013 05:21:58 PM JST
self.
* Fri 13 Sep 2013 05:22:05 PM JST
        pasuedo._sock.send(ANY)
        pasuedo._sock.recv(ANY)
        self.mocker.result('OK')
        self.mocker.count(0, None)

* Fri 13 Sep 2013 05:24:35 PM JST
aquos = Aquos('username', '192.168.1.111', port=12345)
* Fri 13 Sep 2013 05:25:17 PM JST
pasuedo
* Fri 13 Sep 2013 05:25:28 PM JST
pasuedo
* Fri 13 Sep 2013 05:25:55 PM JST
aquos
* Fri 13 Sep 2013 05:27:37 PM JST
self.
* Fri 13 Sep 2013 05:27:41 PM JST
self.
* Fri 13 Sep 2013 05:27:47 PM JST
Aquos('username', '192.168.1.111', port=12345)
* Fri 13 Sep 2013 05:27:59 PM JST
self.
* Fri 13 Sep 2013 05:28:01 PM JST
self.
* Fri 13 Sep 2013 05:28:02 PM JST
self.
* Fri 13 Sep 2013 05:28:04 PM JST
self.
* Fri 13 Sep 2013 05:28:07 PM JST
self.
* Fri 13 Sep 2013 05:29:49 PM JST

* Fri 13 Sep 2013 05:29:49 PM JST

* Fri 13 Sep 2013 05:29:49 PM JST
        self.mocker.replay()

* Fri 13 Sep 2013 05:30:36 PM JST
pasuedo
* Fri 13 Sep 2013 05:45:55 PM JST
pasuedo
* Fri 13 Sep 2013 05:48:33 PM JST
patch
* Fri 13 Sep 2013 06:05:03 PM JST
proxy
* Fri 13 Sep 2013 06:05:15 PM JST

* Fri 13 Sep 2013 06:05:15 PM JST

* Fri 13 Sep 2013 06:05:15 PM JST
        aquos.login = pasuedo.login

* Fri 13 Sep 2013 06:05:39 PM JST

* Fri 13 Sep 2013 06:05:39 PM JST

* Fri 13 Sep 2013 06:05:39 PM JST
        aquos = Aquos('username', '192.168.1.111', port=12345)

* Fri 13 Sep 2013 06:05:43 PM JST
aquos
* Fri 13 Sep 2013 06:07:18 PM JST
Aquos('username', '192.168.1.111', port=12345)
* Fri 13 Sep 2013 06:16:44 PM JST

* Fri 13 Sep 2013 06:16:45 PM JST

* Fri 13 Sep 2013 06:16:45 PM JST
        aquos = Aquos('username', '192.168.1.111', port=12345)

* Fri 13 Sep 2013 06:17:11 PM JST
self.mocker.mock(Aquos('username', '192.168.1.111', port=12345))
* Fri 13 Sep 2013 06:18:26 PM JST
Mocker
* Fri 13 Sep 2013 06:19:12 PM JST
self.mock
* Fri 13 Sep 2013 06:19:15 PM JST
self.mocker
* Fri 13 Sep 2013 06:19:20 PM JST
mocker
* Fri 13 Sep 2013 06:19:20 PM JST
self.mocker
* Fri 13 Sep 2013 06:22:04 PM JST
    def mockup(self, p, f, m):
        methodToCall = getattr(p, f)
        methodToCall()
        m.result(1)
* Fri 13 Sep 2013 06:26:33 PM JST

* Fri 13 Sep 2013 06:26:33 PM JST

* Fri 13 Sep 2013 06:26:34 PM JST
        mock = Mocker()

* Fri 13 Sep 2013 06:26:34 PM JST
        mock = Mocker()

* Fri 13 Sep 2013 06:26:34 PM JST
        mock = Mocker()
        pasuedo = mock.patch(aquos)

* Fri 13 Sep 2013 06:26:36 PM JST

* Fri 13 Sep 2013 06:26:36 PM JST

* Fri 13 Sep 2013 06:26:36 PM JST
        pasuedo.login(ANY)

* Fri 13 Sep 2013 06:28:00 PM JST

* Fri 13 Sep 2013 06:28:01 PM JST

* Fri 13 Sep 2013 06:28:01 PM JST
        mock.restore()

* Fri 13 Sep 2013 06:28:01 PM JST
        mock.restore()

* Fri 13 Sep 2013 06:28:01 PM JST
        mock.restore()
        mock.verify()

* Fri 13 Sep 2013 06:34:23 PM JST
self, 
* Fri 13 Sep 2013 10:49:15 PM JST

* Fri 13 Sep 2013 10:49:15 PM JST

* Fri 13 Sep 2013 10:49:16 PM JST
        aquos.login = lambda x:  return True

* Fri 13 Sep 2013 10:49:17 PM JST

* Fri 13 Sep 2013 10:49:17 PM JST

* Fri 13 Sep 2013 10:49:17 PM JST
        aquos.login = lambda x:  return True

* Fri 13 Sep 2013 11:11:26 PM JST
 $@
* Fri 13 Sep 2013 11:11:58 PM JST
 $@
* Fri 13 Sep 2013 11:13:30 PM JST

* Fri 13 Sep 2013 11:13:30 PM JST

* Fri 13 Sep 2013 11:13:30 PM JST
    # m = DataMirror(verbose=opt.silent, debug=True)

* Fri 13 Sep 2013 11:14:09 PM JST
debug
* Fri 13 Sep 2013 11:15:13 PM JST

* Fri 13 Sep 2013 11:15:13 PM JST

* Fri 13 Sep 2013 11:15:13 PM JST
        try:

* Fri 13 Sep 2013 11:17:44 PM JST

* Fri 13 Sep 2013 11:17:44 PM JST

* Fri 13 Sep 2013 11:17:44 PM JST
                     '/data/.backup/*',

* Fri 13 Sep 2013 11:38:49 PM JST
return 
* Fri 13 Sep 2013 11:51:28 PM JST
mocker
* Fri 13 Sep 2013 11:55:07 PM JST
patch
* Fri 13 Sep 2013 11:57:46 PM JST
object
* Sat 14 Sep 2013 12:01:23 AM JST
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import sys
import re
from mocker import MockerTestCase


class Greeting(object):
    r"""
    """

    def hello(self, name):
        r"""SUMMARY

        @Arguments:

        - `name`:

        @Return:
        """
        return "Hi %s!" %  name

    def bye(self):
        r"""SUMMARY

        @Return:
        """
        return "See ya!"



class Greeting_tests(MockerTestCase):
    r"""
    """
    def test_do(self):
        r"""SUMMARY

        @Return:
        """
        greeting = Greeting()
        obj = self.mocker.proxy(greeting)
        obj.hello('jeff')
        self.mocker.result("hello buddy")
        self.mocker.replay()
        print(greeting.hello('jeff'))

* Sat 14 Sep 2013 12:03:49 AM JST
print(
* Sat 14 Sep 2013 12:06:24 AM JST
greeting.hello('jeff')
* Sat 14 Sep 2013 12:13:30 AM JST
PROMPT
* Sat 14 Sep 2013 12:14:23 AM JST

* Sat 14 Sep 2013 12:14:23 AM JST

* Sat 14 Sep 2013 12:14:23 AM JST
from getpass import getpass

* Sat 14 Sep 2013 12:16:06 AM JST
        getpass = self.mocker.replace('getpass.getpass')
        getpass(ANY)
        self.mocker.result('dummy_passwd')
        self.mocker.count(0, None)

* Sat 14 Sep 2013 12:16:24 AM JST

* Sat 14 Sep 2013 12:16:24 AM JST

* Sat 14 Sep 2013 12:16:24 AM JST
        aquos = Aquos('username', '192.168.1.111', port=12345)

* Sat 14 Sep 2013 12:18:23 AM JST
        getpass = self.mocker.replace('getpass.getpass')
        getpass(ANY)
        self.mocker.result('dummy_passwd')
        self.mocker.count(0, None)


* Sat 14 Sep 2013 12:18:47 AM JST
        mocker = self.mocker.proxy(aquos)
        mocker.login(ANY)
        self.mocker.result(True)
        self.mocker.replay()

* Sat 14 Sep 2013 12:18:59 AM JST
mocker
* Sat 14 Sep 2013 12:19:08 AM JST
mocker
* Sat 14 Sep 2013 12:19:17 AM JST
aquos = Aquos('username', '192.168.1.111', port=12345)
* Sat 14 Sep 2013 12:19:23 AM JST

* Sat 14 Sep 2013 12:19:23 AM JST

* Sat 14 Sep 2013 12:19:24 AM JST
        aquos = Aquos('username', '192.168.1.111', port=12345)

* Sat 14 Sep 2013 12:21:26 AM JST

* Sat 14 Sep 2013 12:21:26 AM JST

* Sat 14 Sep 2013 12:21:26 AM JST
        dummysockconnect = self.mocker.replace('socket.socket.')

* Sat 14 Sep 2013 12:21:27 AM JST

* Sat 14 Sep 2013 12:21:27 AM JST

* Sat 14 Sep 2013 12:21:27 AM JST
        # kill sock.connect

* Sat 14 Sep 2013 12:24:34 AM JST
result
* Sat 14 Sep 2013 12:24:36 AM JST
result
* Sat 14 Sep 2013 12:25:00 AM JST
result = 
* Sat 14 Sep 2013 12:26:06 AM JST
result = 
* Sat 14 Sep 2013 12:26:15 AM JST

* Sat 14 Sep 2013 12:26:15 AM JST

* Sat 14 Sep 2013 12:26:15 AM JST
            result

* Sat 14 Sep 2013 12:26:17 AM JST
result
* Sat 14 Sep 2013 12:26:19 AM JST
passwd
* Sat 14 Sep 2013 12:26:23 AM JST
passwd
* Sat 14 Sep 2013 12:28:01 AM JST
recv
* Sat 14 Sep 2013 12:30:24 AM JST
        dummy_aquos._sock.recv(ANY)
        self.mocker.result('Login:')

* Sat 14 Sep 2013 12:30:28 AM JST
Login
* Sat 14 Sep 2013 12:30:41 AM JST
        dummy_aquos._sock.recv(ANY)
        self.mocker.result('Password:')

* Sat 14 Sep 2013 12:30:44 AM JST
Password:
* Sat 14 Sep 2013 12:35:30 AM JST

* Sat 14 Sep 2013 12:35:30 AM JST

* Sat 14 Sep 2013 12:35:30 AM JST
        self.assertTrue(aquos.login())

* Sat 14 Sep 2013 12:37:45 AM JST
socket.socket(_socket.AF_INET, _socket.SOCK_STREAM)
* Sat 14 Sep 2013 12:38:12 AM JST

* Sat 14 Sep 2013 12:38:13 AM JST
aquos
* Sat 14 Sep 2013 12:38:54 AM JST

* Sat 14 Sep 2013 12:38:54 AM JST

* Sat 14 Sep 2013 12:38:55 AM JST
        dummy_aquos._sock.connect(ANY)

* Sat 14 Sep 2013 12:38:55 AM JST
        dummy_aquos._sock.connect(ANY)

* Sat 14 Sep 2013 12:38:55 AM JST
        dummy_aquos._sock.connect(ANY)
        self.mocker.result(None)

* Sat 14 Sep 2013 12:39:28 AM JST
_sock.
* Sat 14 Sep 2013 12:39:33 AM JST
_sock.
* Sat 14 Sep 2013 12:39:34 AM JST
dummy_aquos
* Sat 14 Sep 2013 12:39:43 AM JST
_sock.
* Sat 14 Sep 2013 01:06:48 AM JST

* Sat 14 Sep 2013 01:06:48 AM JST

* Sat 14 Sep 2013 01:06:48 AM JST
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

* Sat 14 Sep 2013 01:24:31 AM JST
socket.
* Sat 14 Sep 2013 01:24:54 AM JST

* Sat 14 Sep 2013 01:24:55 AM JST

* Sat 14 Sep 2013 01:24:55 AM JST
        getpass('hello')

* Sat 14 Sep 2013 01:26:01 AM JST

* Sat 14 Sep 2013 01:26:01 AM JST

* Sat 14 Sep 2013 01:26:01 AM JST
        obj.hello('jeff')

* Sat 14 Sep 2013 01:26:02 AM JST
        obj.hello('jeff')

* Sat 14 Sep 2013 01:26:02 AM JST
        obj.hello('jeff')
        self.mocker.result("hello buddy")

* Sat 14 Sep 2013 01:26:05 AM JST

* Sat 14 Sep 2013 01:26:05 AM JST

* Sat 14 Sep 2013 01:26:05 AM JST
        print(obj.hello('jeff'))

* Sat 14 Sep 2013 01:26:05 AM JST
        print(obj.hello('jeff'))

* Sat 14 Sep 2013 01:26:05 AM JST
        print(obj.hello('jeff'))
        self.assertEqual(greeting.hello('jeff'), 'Hi jeff!')

* Sat 14 Sep 2013 01:26:07 AM JST
        print(obj.hello('jeff'))
        self.assertEqual(greeting.hello('jeff'), 'Hi jeff!')

* Sat 14 Sep 2013 01:26:07 AM JST
        print(obj.hello('jeff'))
        self.assertEqual(greeting.hello('jeff'), 'Hi jeff!')
        greeting.hello('jeff')

* Sat 14 Sep 2013 01:28:28 AM JST
.connect(ANY)
* Sat 14 Sep 2013 01:55:23 AM JST
proxy
* Sat 14 Sep 2013 01:56:10 AM JST
mock
* Sat 14 Sep 2013 01:56:50 AM JST
_sock
* Sat 14 Sep 2013 01:58:12 AM JST
 as socket
* Sat 14 Sep 2013 02:01:45 AM JST
result
* Sat 14 Sep 2013 02:05:23 AM JST
        # receive 'Login:'
        dummy_sock.recv(ANY)
        self.mocker.result('Login:')

* Sat 14 Sep 2013 02:39:36 AM JST
self.mocker.count(0, None)
* Sat 14 Sep 2013 02:39:49 AM JST
        # receive 'Login:'
        dummy_sock.recv(ANY)
        self.mocker.result('Login:')
        # receive 'Password:'
        dummy_sock.recv(ANY)
        self.mocker.result('Password:')
        # receive 'OK'
        dummy_sock.recv(ANY)
        self.mocker.result('OK')

* Sat 14 Sep 2013 02:39:59 AM JST
        
* Sat 14 Sep 2013 02:41:10 AM JST

* Sat 14 Sep 2013 02:41:10 AM JST

* Sat 14 Sep 2013 02:41:10 AM JST
        self.assertTrue(aquos.relogin('hello', 'tests'))

* Sat 14 Sep 2013 02:43:05 AM JST
        aquos = Aquos('username', '192.168.1.111', port=12345)

        # kill getpass
        dummygetpass = self.mocker.replace('getpass.getpass')
        dummygetpass(ANY)
        self.mocker.result('dummy_passwd')
        self.mocker.count(0, None)

        dummy_aquos = self.mocker.proxy(aquos)
        dummy_sock = self.mocker.patch(socket.socket)
        # escape connect
        dummy_sock.connect(ANY)
        self.mocker.result(None)
        self.mocker.count(0, None)
        # escape send
        dummy_sock.send(ANY)
        self.mocker.result(None)
        self.mocker.count(0, None)

        # receive 'Login:'
        dummy_sock.recv(ANY)
        self.mocker.result('Login:')
        # receive 'Password:'
        dummy_sock.recv(ANY)
        self.mocker.result('Password:')
        # receive 'OK'
        dummy_sock.recv(ANY)
        self.mocker.result('OK')

        self.mocker.replay()

* Sat 14 Sep 2013 02:45:41 AM JST
        self.power = _POWR(sock=self._sock)
        self.inputtoggle = _ITGD(sock=self._sock)
        self.inputtv = _ITVD(sock=self._sock)
        self.input = _IAVD(sock=self._sock)
        self.inputdegital = _IDEG(sock=self._sock)
        # self.channelBS = _CBSD(sock=self._sock)
        # self.channelCS = _CCSD(sock=self._sock)
        # self.channelTB = _CTBD(sock=self._sock)
        self.channel = _Channel(sock=self._sock)
        self.input4 = _INP4(sock=self._sock)
        self.avposition = _AVMD(sock=self._sock)
        self.volume = _VOLM(sock=self._sock)
        self.horizon = _HPOS(sock=self._sock)
        self.vertical = _VPOS(sock=self._sock)
        self.clock = _CLCK(sock=self._sock)
        self.clockphese = _PHSE(sock=self._sock)
        self.display = _WIDE(sock=self._sock)
        self.mute = _MUTE(sock=self._sock)
        self.audio = _ACHA(sock=self._sock)
        self.offtimer = _OFTM(sock=self._sock)

* Sat 14 Sep 2013 02:45:50 AM JST

* Sat 14 Sep 2013 02:45:50 AM JST

* Sat 14 Sep 2013 02:45:50 AM JST
# self.channelBS = _CBSD(sock=self._sock)

* Sat 14 Sep 2013 02:45:50 AM JST
# self.channelBS = _CBSD(sock=self._sock)

* Sat 14 Sep 2013 02:45:50 AM JST
# self.channelBS = _CBSD(sock=self._sock)
# self.channelCS = _CCSD(sock=self._sock)

* Sat 14 Sep 2013 02:45:50 AM JST
# self.channelBS = _CBSD(sock=self._sock)
# self.channelCS = _CCSD(sock=self._sock)

* Sat 14 Sep 2013 02:45:50 AM JST
# self.channelBS = _CBSD(sock=self._sock)
# self.channelCS = _CCSD(sock=self._sock)
# self.channelTB = _CTBD(sock=self._sock)

* Sat 14 Sep 2013 02:46:07 AM JST
self.offtimer = 
* Sat 14 Sep 2013 02:46:21 AM JST
offtimer =
* Sat 14 Sep 2013 02:46:23 AM JST
audio =
* Sat 14 Sep 2013 02:46:23 AM JST
mute =
* Sat 14 Sep 2013 02:46:23 AM JST
display =
* Sat 14 Sep 2013 02:46:23 AM JST
clockphese =
* Sat 14 Sep 2013 02:46:23 AM JST
clock =
* Sat 14 Sep 2013 02:46:23 AM JST
vertical =
* Sat 14 Sep 2013 02:46:23 AM JST
horizon =
* Sat 14 Sep 2013 02:46:23 AM JST
volume =
* Sat 14 Sep 2013 02:46:23 AM JST
avposition =
* Sat 14 Sep 2013 02:46:23 AM JST
input4 =
* Sat 14 Sep 2013 02:46:23 AM JST
channel =
* Sat 14 Sep 2013 02:46:23 AM JST
inputdegital =
* Sat 14 Sep 2013 02:46:23 AM JST
input =
* Sat 14 Sep 2013 02:46:23 AM JST
inputtv =
* Sat 14 Sep 2013 02:46:24 AM JST
inputtoggle =
* Sat 14 Sep 2013 02:46:24 AM JST
power =
* Sat 14 Sep 2013 02:46:26 AM JST
self.offtimer =
* Sat 14 Sep 2013 02:46:26 AM JST
self.audio =
* Sat 14 Sep 2013 02:46:26 AM JST
self.mute =
* Sat 14 Sep 2013 02:46:26 AM JST
self.display =
* Sat 14 Sep 2013 02:46:26 AM JST
self.clockphese =
* Sat 14 Sep 2013 02:46:26 AM JST
self.clock =
* Sat 14 Sep 2013 02:46:26 AM JST
self.vertical =
* Sat 14 Sep 2013 02:46:26 AM JST
self.horizon =
* Sat 14 Sep 2013 02:46:26 AM JST
self.volume =
* Sat 14 Sep 2013 02:46:26 AM JST
self.avposition =
* Sat 14 Sep 2013 02:46:26 AM JST
self.input4 =
* Sat 14 Sep 2013 02:46:26 AM JST
self.channel =
* Sat 14 Sep 2013 02:46:27 AM JST
self.inputdegital =
* Sat 14 Sep 2013 02:46:27 AM JST
self.input =
* Sat 14 Sep 2013 02:46:27 AM JST
self.inputtv =
* Sat 14 Sep 2013 02:46:27 AM JST
self.inputtoggle =
* Sat 14 Sep 2013 02:46:27 AM JST
self.power =
* Sat 14 Sep 2013 02:46:31 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:31 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:31 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:31 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:31 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:31 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:31 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:31 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:31 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:31 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:31 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:32 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:32 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:32 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:32 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:32 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:32 AM JST
(sock=self._sock)
* Sat 14 Sep 2013 02:46:47 AM JST
_POWR_ITGD_ITVD_IAVD_IDEG_Channel_INP4_AVMD_VOLM_HPOS_VPOS_CLCK_PHSE_WIDE_MUTE_ACHA_OFTM
* Sat 14 Sep 2013 02:47:15 AM JST
_POWR, _ITGD, _ITVD, _IAVD, _IDEG, _Channel, _INP4, _AVMD, _VOLM, _HPOS, _VPOS, _CLCK, _PHSE, _WIDE, _MUTE, _ACHA, _OFTM
* Sat 14 Sep 2013 02:53:06 AM JST

* Sat 14 Sep 2013 02:53:18 AM JST
power
* Sat 14 Sep 2013 02:53:29 AM JST
        
* Sat 14 Sep 2013 02:53:41 AM JST
inputtoggle
* Sat 14 Sep 2013 02:54:06 AM JST
        self.input = _IAVD(sock=self._sock)
        self.inputdegital = _IDEG(sock=self._sock)
        # self.channelBS = _CBSD(sock=self._sock)
        # self.channelCS = _CCSD(sock=self._sock)
        # self.channelTB = _CTBD(sock=self._sock)
        self.channel = _Channel(sock=self._sock)
        self.input4 = _INP4(sock=self._sock)
        self.avposition = _AVMD(sock=self._sock)
        self.volume = _VOLM(sock=self._sock)
        self.horizon = _HPOS(sock=self._sock)
        self.vertical = _VPOS(sock=self._sock)
        self.clock = _CLCK(sock=self._sock)
        self.clockphese = _PHSE(sock=self._sock)
        self.display = _WIDE(sock=self._sock)
        self.mute = _MUTE(sock=self._sock)
        self.audio = _ACHA(sock=self._sock)
        self.offtimer = _OFTM(sock=self._sock)

* Sat 14 Sep 2013 02:54:23 AM JST

* Sat 14 Sep 2013 02:54:23 AM JST

* Sat 14 Sep 2013 02:54:23 AM JST
# self.channelBS = _CBSD(sock=self._sock)

* Sat 14 Sep 2013 02:54:23 AM JST
# self.channelBS = _CBSD(sock=self._sock)

* Sat 14 Sep 2013 02:54:23 AM JST
# self.channelBS = _CBSD(sock=self._sock)
# self.channelCS = _CCSD(sock=self._sock)

* Sat 14 Sep 2013 02:54:23 AM JST
# self.channelBS = _CBSD(sock=self._sock)
# self.channelCS = _CCSD(sock=self._sock)

* Sat 14 Sep 2013 02:54:23 AM JST
# self.channelBS = _CBSD(sock=self._sock)
# self.channelCS = _CCSD(sock=self._sock)
# self.channelTB = _CTBD(sock=self._sock)

* Sat 14 Sep 2013 02:55:39 AM JST
                                  
* Sat 14 Sep 2013 02:55:53 AM JST
,                                       
* Sat 14 Sep 2013 02:55:55 AM JST
                                    
* Sat 14 Sep 2013 02:56:02 AM JST
                                   
* Sat 14 Sep 2013 02:56:05 AM JST
                                       
* Sat 14 Sep 2013 02:56:07 AM JST
                                   
* Sat 14 Sep 2013 02:56:10 AM JST
                                    
* Sat 14 Sep 2013 02:56:12 AM JST
                                     
* Sat 14 Sep 2013 02:56:16 AM JST
                                  
* Sat 14 Sep 2013 02:56:18 AM JST
                                       
* Sat 14 Sep 2013 02:56:20 AM JST
                                    
* Sat 14 Sep 2013 02:56:23 AM JST
                                 
* Sat 14 Sep 2013 02:56:25 AM JST
                                  
* Sat 14 Sep 2013 02:57:06 AM JST
sock
* Sat 14 Sep 2013 02:57:06 AM JST
sock
* Sat 14 Sep 2013 02:57:06 AM JST
sock
* Sat 14 Sep 2013 02:57:07 AM JST
sock
* Sat 14 Sep 2013 02:57:07 AM JST
sock
* Sat 14 Sep 2013 02:57:07 AM JST
sock
* Sat 14 Sep 2013 02:57:07 AM JST
sock
* Sat 14 Sep 2013 02:57:07 AM JST
sock
* Sat 14 Sep 2013 02:57:07 AM JST
sock
* Sat 14 Sep 2013 02:57:07 AM JST
sock
* Sat 14 Sep 2013 02:57:07 AM JST
sock
* Sat 14 Sep 2013 02:57:07 AM JST
sock
* Sat 14 Sep 2013 02:57:07 AM JST
sock
* Sat 14 Sep 2013 02:57:07 AM JST
sock
* Sat 14 Sep 2013 02:57:09 AM JST
self._sock
* Sat 14 Sep 2013 02:57:09 AM JST
self._sock
* Sat 14 Sep 2013 02:57:09 AM JST
self._sock
* Sat 14 Sep 2013 02:57:09 AM JST
self._sock
* Sat 14 Sep 2013 02:57:09 AM JST
self._sock
* Sat 14 Sep 2013 02:57:09 AM JST
self._sock
* Sat 14 Sep 2013 02:57:09 AM JST
self._sock
* Sat 14 Sep 2013 02:57:09 AM JST
self._sock
* Sat 14 Sep 2013 02:57:09 AM JST
self._sock
* Sat 14 Sep 2013 02:57:09 AM JST
self._sock
* Sat 14 Sep 2013 02:57:09 AM JST
self._sock
* Sat 14 Sep 2013 02:57:09 AM JST
self._sock
* Sat 14 Sep 2013 02:57:09 AM JST
self._sock
* Sat 14 Sep 2013 02:57:09 AM JST
self._sock
* Sat 14 Sep 2013 02:58:00 AM JST
                                                     
* Sat 14 Sep 2013 02:58:04 AM JST
                                              
* Sat 14 Sep 2013 02:58:17 AM JST
self.assertEqual(type(aquos.input), type(_IAVD(sock=aquos._sock)))
self.assertEqual(type(aquos.inputdegital), type(_IDEG(sock=aquos._sock)))
self.assertEqual(type(aquos.channel), type(_Channel(sock=aquos._sock)))
self.assertEqual(type(aquos.input4), type(_INP4(sock=aquos._sock)))
self.assertEqual(type(aquos.avposition), type(_AVMD(sock=aquos._sock)))
self.assertEqual(type(aquos.volume), type(_VOLM(sock=aquos._sock)))
self.assertEqual(type(aquos.horizon), type(_HPOS(sock=aquos._sock)))
self.assertEqual(type(aquos.vertical), type(_VPOS(sock=aquos._sock)))
self.assertEqual(type(aquos.clock), type(_CLCK(sock=aquos._sock)))
self.assertEqual(type(aquos.clockphese), type(_PHSE(sock=aquos._sock)))
self.assertEqual(type(aquos.display), type(_WIDE(sock=aquos._sock)))
self.assertEqual(type(aquos.mute), type(_MUTE(sock=aquos._sock)))
self.assertEqual(type(aquos.audio), type(_ACHA(sock=aquos._sock)))
self.assertEqual(type(aquos.offtimer) =type( _OFTM(sock=aquos._sock))

* Sat 14 Sep 2013 03:00:25 AM JST
                          
* Sat 14 Sep 2013 03:00:27 AM JST
                          
* Sat 14 Sep 2013 03:10:16 AM JST

* Sat 14 Sep 2013 03:10:16 AM JST

* Sat 14 Sep 2013 03:10:17 AM JST
        self._connected = False

* Sat 14 Sep 2013 03:10:23 AM JST

* Sat 14 Sep 2013 03:10:23 AM JST

* Sat 14 Sep 2013 03:10:23 AM JST
            self._connected = True

* Sat 14 Sep 2013 03:10:54 AM JST
        aquos = Aquos('username', '192.168.1.111', port=12345)

        # kill getpass
        dummygetpass = self.mocker.replace('getpass.getpass')
        dummygetpass(ANY)
        self.mocker.result('dummy_passwd')
        self.mocker.count(0, None)

        dummy_aquos = self.mocker.proxy(aquos)
        dummy_sock = self.mocker.patch(socket.socket)
        # escape connect
        dummy_sock.connect(ANY)
        self.mocker.result(None)
        self.mocker.count(0, None)
        # escape send
        dummy_sock.send(ANY)
        self.mocker.result(None)
        self.mocker.count(0, None)

        # receive 'Login:'
        dummy_sock.recv(ANY)
        self.mocker.result('Login:')
        # receive 'Password:'
        dummy_sock.recv(ANY)
        self.mocker.result('Password:')
        # receive 'OK'
        dummy_sock.recv(ANY)
        self.mocker.result('OK')

        self.mocker.replay()

* Sat 14 Sep 2013 03:11:16 AM JST

* Sat 14 Sep 2013 03:11:16 AM JST

* Sat 14 Sep 2013 03:11:16 AM JST
        self.assertFalse(aquos._connected)

* Sat 14 Sep 2013 03:11:27 AM JST
aquos = Aquos('username', '192.168.1.111', port=12345)
* Sat 14 Sep 2013 03:13:33 AM JST

* Sat 14 Sep 2013 03:13:33 AM JST

* Sat 14 Sep 2013 03:13:33 AM JST
        self.mocker.replay()

* Sat 14 Sep 2013 03:15:28 AM JST
        # receive 'Login:'
        dummy_sock.recv(ANY)
        self.mocker.result('Login:')
        # receive 'Password:'
        dummy_sock.recv(ANY)
        self.mocker.result('Password:')
        # receive 'OK'
        dummy_sock.recv(ANY)
        self.mocker.result('OK')

* Sat 14 Sep 2013 03:17:44 AM JST
        aquos = Aquos('username', '192.168.1.111', port=12345)

        # kill getpass
        dummygetpass = self.mocker.replace('getpass.getpass')
        dummygetpass(ANY)
        self.mocker.result('dummy_passwd')
        self.mocker.count(0, None)

        dummy_aquos = self.mocker.proxy(aquos)
        dummy_sock = self.mocker.patch(socket.socket)
        # escape connect
        dummy_sock.connect(ANY)
        self.mocker.result(None)
        self.mocker.count(0, None)
        # escape send
        dummy_sock.send(ANY)
        self.mocker.result(None)
        self.mocker.count(0, None)

        # receive 'Login:'
        dummy_sock.recv(ANY)
        self.mocker.result('Login:')
        # receive 'Password:'
        dummy_sock.recv(ANY)
        self.mocker.result('Password:')
        # receive 'OK'
        dummy_sock.recv(ANY)
        self.mocker.result('OK')

        self.mocker.replay()
        self.assertTrue(aquos.login())

* Sat 14 Sep 2013 03:19:40 AM JST
aquo
* Sat 14 Sep 2013 03:19:45 AM JST
aquos
* Sat 14 Sep 2013 03:21:28 AM JST
aquos.
* Sat 14 Sep 2013 03:21:31 AM JST
aquos.
* Sat 14 Sep 2013 03:21:33 AM JST
aquos.
* Sat 14 Sep 2013 03:21:37 AM JST
aquos.
* Sat 14 Sep 2013 03:21:41 AM JST
aquos.
* Sat 14 Sep 2013 03:21:44 AM JST
aquos.
* Sat 14 Sep 2013 03:21:48 AM JST
aquos.
* Sat 14 Sep 2013 03:21:50 AM JST
aquos.
* Sat 14 Sep 2013 03:21:54 AM JST
aquos.
* Sat 14 Sep 2013 03:21:56 AM JST
aquos.
* Sat 14 Sep 2013 03:21:59 AM JST
aquos.
* Sat 14 Sep 2013 03:22:46 AM JST

* Sat 14 Sep 2013 03:22:46 AM JST

* Sat 14 Sep 2013 03:22:46 AM JST
        self.aquos = Aquos('username', '192.168.1.111', port=12345)

* Sat 14 Sep 2013 03:25:27 AM JST
aquos.
* Sat 14 Sep 2013 03:25:31 AM JST
aquos.
* Sat 14 Sep 2013 03:25:37 AM JST
aquos.
* Sat 14 Sep 2013 03:25:40 AM JST
aquos.
* Sat 14 Sep 2013 03:25:43 AM JST
aquos.
* Sat 14 Sep 2013 03:25:46 AM JST
aquos.
* Sat 14 Sep 2013 03:35:56 AM JST
version
* Sat 14 Sep 2013 03:37:15 AM JST
{0: <15}
* Sat 14 Sep 2013 03:37:23 AM JST
host
* Sat 14 Sep 2013 03:37:37 AM JST
{0: <15}
* Sat 14 Sep 2013 03:38:18 AM JST
{0: <15}
* Sat 14 Sep 2013 03:38:22 AM JST
user
* Sat 14 Sep 2013 03:38:39 AM JST
{0: <15}
* Sat 14 Sep 2013 03:38:44 AM JST
SSH key
* Sat 14 Sep 2013 03:39:01 AM JST
{0: <15}
* Sat 14 Sep 2013 03:39:06 AM JST
SSH key md5
* Sat 14 Sep 2013 03:39:32 AM JST
{0: <15}
* Sat 14 Sep 2013 03:39:54 AM JST
Listen port
* Sat 14 Sep 2013 03:40:08 AM JST
Open ports
* Sat 14 Sep 2013 03:40:19 AM JST
Close ports
* Sat 14 Sep 2013 03:40:32 AM JST
port
* Sat 14 Sep 2013 03:41:08 AM JST
SSH connection
* Sat 14 Sep 2013 03:41:42 AM JST
wake up
* Sat 14 Sep 2013 03:41:51 AM JST
Wait wake up time
* Sat 14 Sep 2013 03:42:05 AM JST
Port open
* Sat 14 Sep 2013 03:42:24 AM JST
Has keyring
* Sat 14 Sep 2013 03:44:04 AM JST

* Sat 14 Sep 2013 03:44:04 AM JST

* Sat 14 Sep 2013 03:44:04 AM JST
        s.append('{0: <17}: {1}'.format('Wait wake up time', self._wait))

* Sat 14 Sep 2013 03:50:51 AM JST
c
* Sat 14 Sep 2013 03:50:51 AM JST
SSH c
* Sat 14 Sep 2013 03:51:13 AM JST
Port 
* Sat 14 Sep 2013 04:08:11 AM JST
MSG = {'allow_runlevel':
       'Runlevel Errors: Could not execute this script on this runnlevel.',
       }
ERR = {'err001': 'Command runlevel failed.',
       }


class CommandError(Exception):
    pass

def getrunlevel():
    """SUMMARY

    @Return: string number
    """
    status, out = commands.getstatusoutput('/sbin/runlevel')
    if not 0 == status:
        raise CommandError(ERR.get('err001'))
    return out.replace('N ', '').replace('\n', '')

def allow_runlevel(num, txt=MSG.get('allow_runlevel')):
    """SUMMARY

    @Arguments:
    - `num`:

    @Return:
    """
    if type(num) == IntType:
        num = [num]
    if not getrunlevel() in map(str, num):
            sys.exit(txt)

def disallow_runlevel(num, txt=MSG.get('allow_runlevel')):
    """SUMMARY

    @Return:
    """
    if type(num) == IntType:
        num = [num]
    if getrunlevel() in map(str, num):
            sys.exit(txt)


* Sat 14 Sep 2013 04:08:20 AM JST
import commands
from types import IntType

* Sat 14 Sep 2013 04:09:41 AM JST
getrunlevel
* Sat 14 Sep 2013 04:10:15 AM JST
allow_runlevel
* Sat 14 Sep 2013 04:10:24 AM JST
disallow_runlevel
* Sat 14 Sep 2013 04:16:02 AM JST
_
* Sat 14 Sep 2013 04:16:03 AM JST
prevent._
* Sat 14 Sep 2013 04:19:21 AM JST
from mocker import MockerTestCase, ANY, Mocker
* Sat 14 Sep 2013 04:19:36 AM JST
Mocker
* Sat 14 Sep 2013 04:19:36 AM JST
ANY, Mocker
* Sat 14 Sep 2013 04:32:21 AM JST
dummy_cmd
* Sat 14 Sep 2013 04:34:50 AM JST
mocker
* Sat 14 Sep 2013 04:37:16 AM JST
import
* Sat 14 Sep 2013 04:39:19 AM JST
        dummy_cmd = self.mocker.replace('commands.getstatusoutput')
        dummy_cmd(ANY)
        self.mocker.result((1, 'nothing'))

* Sat 14 Sep 2013 04:39:23 AM JST
        dummy_cmd = self.mocker.replace('commands.getstatusoutput')
        dummy_cmd(ANY)
        self.mocker.result((1, 'nothing'))
        self.mocker.replay()

* Sat 14 Sep 2013 04:39:27 AM JST
nothing
* Sat 14 Sep 2013 05:11:14 AM JST
nosetest]
--
* Sat 14 Sep 2013 05:29:36 AM JST

* Sat 14 Sep 2013 05:29:36 AM JST

* Sat 14 Sep 2013 05:29:36 AM JST
        @Return:

* Sat 14 Sep 2013 05:29:38 AM JST
        
* Sat 14 Sep 2013 05:29:40 AM JST
SUMMARY
* Sat 14 Sep 2013 05:29:44 AM JST
test_getrunlevel_CommandError
* Sat 14 Sep 2013 05:29:51 AM JST
test_
* Sat 14 Sep 2013 05:29:58 AM JST
SUMMARY
* Sat 14 Sep 2013 05:29:59 AM JST

* Sat 14 Sep 2013 05:29:59 AM JST

* Sat 14 Sep 2013 05:30:00 AM JST
        @Return:

* Sat 14 Sep 2013 05:30:02 AM JST
        
* Sat 14 Sep 2013 05:30:06 AM JST
getrunlevel
* Sat 14 Sep 2013 05:30:30 AM JST
test_getrunlevel_CommandError
* Sat 14 Sep 2013 05:30:40 AM JST
test_getrunlevel
* Sat 14 Sep 2013 05:32:00 AM JST
    
* Sat 14 Sep 2013 05:32:21 AM JST
    
* Sat 14 Sep 2013 05:32:52 AM JST
    
* Sat 14 Sep 2013 05:33:04 AM JST
    
* Sat 14 Sep 2013 05:34:04 AM JST
    
* Sat 14 Sep 2013 05:34:14 AM JST
("\C-c\C-n\C-p\C-a"       
* Sat 14 Sep 2013 05:34:46 AM JST
    
* Sat 14 Sep 2013 05:36:03 AM JST

* Sat 14 Sep 2013 05:36:09 AM JST
	 ;; C-c m conflicts w/ pylint
* Sat 14 Sep 2013 05:36:10 AM JST
	 ;; C-c m conflicts w/ pylint
* Sat 14 Sep 2013 05:37:04 AM JST
    
* Sat 14 Sep 2013 05:37:20 AM JST

* Sat 14 Sep 2013 05:37:20 AM JST

* Sat 14 Sep 2013 05:37:20 AM JST
    ("\C-cx"	      'nosetests-stop)

* Sat 14 Sep 2013 05:37:47 AM JST
    
* Sat 14 Sep 2013 05:42:53 AM JST
(defvar ctl-colon-map nil ;;(make-keymap)
  "Default keymap for C-: commands.")
(define-prefix-command 'ctl-colon-map)

* Sat 14 Sep 2013 05:43:43 AM JST
colon
* Sat 14 Sep 2013 05:46:30 AM JST
  (defvar ctl-c-n-map nil ;;(make-keymap)
    "Default keymap for C-c C-n commands.")
  (define-prefix-command 'ctl-c-n-map)

* Sat 14 Sep 2013 05:47:13 AM JST
    ("\C-cna"	      'nosetests-all)
    ("\C-c\C-na"	  'nosetests-all)
    ("\C-c\C-n\C-a"	  'nosetests-all)
    ("\C-cno"	      'nosetests-one)
    ("\C-c\C-no"	  'nosetests-one)
    ("\C-c\C-n\C-o"	  'nosetests-one)
    ("\C-cnm"	      'nosetests-module)
    ("\C-c\C-nm"	  'nosetests-module)
    ("\C-c\C-n\C-m"	  'nosetests-module)
    ("\C-c\C-npa"       'nosetests-pdb-all)
    ("\C-c\C-n\C-p\C-a" 'nosetests-pdb-all)
    ("\C-c\C-npo"       'nosetests-pdb-one)
    ("\C-c\C-n\C-p\C-o" 'nosetests-pdb-one)
    ("\C-c\C-n\C-pm"    'nosetests-pdb-module)
    ("\C-c\C-n\C-p\C-m" 'nosetests-pdb-module)

* Sat 14 Sep 2013 05:47:46 AM JST
    ("\C-c\C-na"	  'nosetests-all)
    ("\C-c\C-n\C-a"	  'nosetests-all)

* Sat 14 Sep 2013 05:48:10 AM JST
    ("\C-c\C-no"	  'nosetests-one)
    ("\C-c\C-n\C-o"	  'nosetests-one)

* Sat 14 Sep 2013 05:48:23 AM JST
    ("\C-c\C-nm"	  'nosetests-module)
    ("\C-c\C-n\C-m"	  'nosetests-module)
    ("\C-c\C-npa"       'nosetests-pdb-all)
    ("\C-c\C-n\C-p\C-a" 'nosetests-pdb-all)
    ("\C-c\C-npo"       'nosetests-pdb-one)
    ("\C-c\C-n\C-p\C-o" 'nosetests-pdb-one)
    ("\C-c\C-n\C-pm"    'nosetests-pdb-module)
    ("\C-c\C-n\C-p\C-m" 'nosetests-pdb-module)

* Sat 14 Sep 2013 05:55:15 AM JST
tests_
* Sat 14 Sep 2013 11:58:15 AM JST
not 
* Sat 14 Sep 2013 11:58:17 AM JST
txt)
* Sat 14 Sep 2013 11:58:17 AM JST
exit(txt)
* Sat 14 Sep 2013 11:58:18 AM JST
_sys.exit(txt)
* Sat 14 Sep 2013 12:05:26 PM JST

* Sat 14 Sep 2013 12:05:26 PM JST

* Sat 14 Sep 2013 12:05:26 PM JST
            _sys.exit(txt)

* Sat 14 Sep 2013 12:05:45 PM JST
str, 
* Sat 14 Sep 2013 12:05:52 PM JST
str, 
* Sat 14 Sep 2013 12:05:53 PM JST
map(str, 
* Sat 14 Sep 2013 12:28:35 PM JST
TYPES
* Sat 14 Sep 2013 12:28:50 PM JST

* Sat 14 Sep 2013 12:28:51 PM JST

* Sat 14 Sep 2013 12:28:51 PM JST
import types as _types

* Sat 14 Sep 2013 12:29:52 PM JST

* Sat 14 Sep 2013 12:29:52 PM JST

* Sat 14 Sep 2013 12:29:52 PM JST
# binding: "keybinding"

* Sat 14 Sep 2013 12:29:52 PM JST
# binding: "keybinding"

* Sat 14 Sep 2013 12:29:52 PM JST
# binding: "keybinding"
# expand-env: ((some-var some-value))

* Sat 14 Sep 2013 12:30:00 PM JST
# condition: (not (python-in-string/comment))
# --
types.${1:$$(yas/choose-value '("NoneType" "TypeType" "ObjectType" "IntType" "LongType" "FloatType" "BooleanType" "ComplexType" "StringType" "UnicodeType" "StringTypes" "StringTypes" "BufferType" "TupleType" "ListType" "DictType" "FunctionType" "LambdaType" "CodeType" "GeneratorType" "ClassType" "UnboundMethodType" "InstanceType" "MethodType" "BuiltinFunctionType" "BuiltinMethodType" "ModuleType" "FileType" "XRangeType" "TracebackType" "FrameType" "SliceType" "EllipsisType" "DictProxyType" "NotImplementedType" "GetSetDescriptorType" "MemberDescriptorType"))}`(py--insert-imports "types" "import types")`

* Sat 14 Sep 2013 12:30:12 PM JST
StringType
* Sat 14 Sep 2013 12:30:13 PM JST
types.StringType
* Sat 14 Sep 2013 12:30:16 PM JST

* Sat 14 Sep 2013 12:30:16 PM JST

* Sat 14 Sep 2013 12:30:16 PM JST
import types

* Sat 14 Sep 2013 12:31:48 PM JST
if get_curruid() in map(FUNC, ITERABLE)
* Sat 14 Sep 2013 12:31:49 PM JST
:
* Sat 14 Sep 2013 01:01:59 PM JST
allow
* Sat 14 Sep 2013 01:02:24 PM JST
allow_runlevel, disallow_runlevel
* Sat 14 Sep 2013 01:05:51 PM JST
allow
* Sat 14 Sep 2013 01:07:10 PM JST
runlevel 
* Sat 14 Sep 2013 01:07:18 PM JST
only
* Sat 14 Sep 2013 01:08:16 PM JST
allow_runlevel
* Sat 14 Sep 2013 03:18:07 PM JST
allow
* Sat 14 Sep 2013 03:20:12 PM JST
isallow
* Sat 14 Sep 2013 03:20:57 PM JST
allow_users
* Sat 14 Sep 2013 03:20:59 PM JST
allow_users
* Sat 14 Sep 2013 03:27:46 PM JST
"""
* Sat 14 Sep 2013 03:29:17 PM JST
dummy_getuid
* Sat 14 Sep 2013 03:29:21 PM JST
dummy_getuid
* Sat 14 Sep 2013 03:31:30 PM JST
@Return:
* Sat 14 Sep 2013 03:31:30 PM JST
        @Return:
* Sat 14 Sep 2013 03:31:32 PM JST
SUMMARY
* Sat 14 Sep 2013 03:31:39 PM JST
        
* Sat 14 Sep 2013 03:32:30 PM JST
@Return:
* Sat 14 Sep 2013 03:32:30 PM JST
        @Return:
* Sat 14 Sep 2013 03:32:32 PM JST
        
* Sat 14 Sep 2013 03:43:43 PM JST
True
* Sat 14 Sep 2013 03:46:08 PM JST
str(type(name))
* Sat 14 Sep 2013 03:47:24 PM JST
prevent
* Sat 14 Sep 2013 03:49:53 PM JST
SUMMARY
* Sat 14 Sep 2013 03:50:04 PM JST
@Return:
* Sat 14 Sep 2013 03:50:04 PM JST
        @Return:
* Sat 14 Sep 2013 03:50:06 PM JST
        
* Sat 14 Sep 2013 03:50:31 PM JST
self
* Sat 14 Sep 2013 03:50:31 PM JST
self.self
* Sat 14 Sep 2013 03:50:43 PM JST
TypeError
* Sat 14 Sep 2013 03:53:32 PM JST

* Sat 14 Sep 2013 03:53:32 PM JST

* Sat 14 Sep 2013 03:53:32 PM JST
        except KeyError:

* Sat 14 Sep 2013 03:53:32 PM JST
        except KeyError:

* Sat 14 Sep 2013 03:53:32 PM JST
        except KeyError:
            pass

* Sat 14 Sep 2013 03:53:34 PM JST

* Sat 14 Sep 2013 03:53:34 PM JST

* Sat 14 Sep 2013 03:53:34 PM JST
        try:

* Sat 14 Sep 2013 03:54:40 PM JST
TypeError0
* Sat 14 Sep 2013 03:57:43 PM JST
pass
* Sat 14 Sep 2013 04:00:20 PM JST
            msg = 'Not allow this {}.'.format(str(type(name)))
            raise TypeError(msg)

* Sat 14 Sep 2013 04:01:01 PM JST
curruid == name
* Sat 14 Sep 2013 04:01:08 PM JST

* Sat 14 Sep 2013 04:01:08 PM JST

* Sat 14 Sep 2013 04:01:08 PM JST
            if :

* Sat 14 Sep 2013 04:01:36 PM JST
if type(name) in [_types.IntType, _types.StringType]:
* Sat 14 Sep 2013 04:03:02 PM JST

* Sat 14 Sep 2013 04:03:02 PM JST

* Sat 14 Sep 2013 04:03:02 PM JST
            continue

* Sat 14 Sep 2013 04:03:07 PM JST
curruid == _pwd.getpwnam(name).pw_uid
* Sat 14 Sep 2013 04:03:30 PM JST

* Sat 14 Sep 2013 04:03:30 PM JST

* Sat 14 Sep 2013 04:03:30 PM JST
            try:

* Sat 14 Sep 2013 04:03:31 PM JST
            try:

* Sat 14 Sep 2013 04:03:31 PM JST
            try:
                if :

* Sat 14 Sep 2013 04:03:48 PM JST

* Sat 14 Sep 2013 04:03:48 PM JST

* Sat 14 Sep 2013 04:03:48 PM JST
                continue

* Sat 14 Sep 2013 04:03:55 PM JST

* Sat 14 Sep 2013 04:03:55 PM JST

* Sat 14 Sep 2013 04:03:55 PM JST
                continue

* Sat 14 Sep 2013 04:05:48 PM JST
Function
* Sat 14 Sep 2013 04:06:23 PM JST
class Root_isin_cuur_user_Test(mocker.MockerTestCase):
    r"""
    """

    def setUp(self):
        r"""SUMMARY

        @Return:
        """
        dummy_getuid = self.mocker.replace('os.getuid')
        dummy_getuid()
        self.mocker.result(0)
        self.mocker.count(0, None)
        self.mocker.replay()

    def test_get_curruid(self):
        r"""test_get_curruid"""
        self.assertEqual(0, prevent.get_curruid())

    def test_isin_curr_user(self):
        r"""test_isin_curr_user"""
        self.assertTrue(prevent.isin_curr_user('root'))
        self.assertFalse(prevent.isin_curr_user('no_exists_user'))
        self.assertTrue(prevent.isin_curr_user(0))

    def test_Raise_isin_curr_user(self):
        r"""test_Raise_isin_curr_user"""
        with self.assertRaises(TypeError):
            prevent.isin_curr_user(0.0)

* Sat 14 Sep 2013 04:13:31 PM JST
dummy_getpwnamre
* Sat 14 Sep 2013 04:13:59 PM JST
self.mocker.count(0, None)
* Sat 14 Sep 2013 04:38:48 PM JST

* Sat 14 Sep 2013 04:38:48 PM JST

* Sat 14 Sep 2013 04:38:48 PM JST
# for debug

* Sat 14 Sep 2013 04:38:49 PM JST
# for debug

* Sat 14 Sep 2013 04:38:49 PM JST
# for debug
import cgitb as _cgitb

* Sat 14 Sep 2013 04:38:49 PM JST
# for debug
import cgitb as _cgitb

* Sat 14 Sep 2013 04:38:49 PM JST
# for debug
import cgitb as _cgitb
_cgitb.enable(format='text')

* Sat 14 Sep 2013 04:39:53 PM JST
argparse
* Sat 14 Sep 2013 04:40:16 PM JST

* Sat 14 Sep 2013 04:40:16 PM JST

* Sat 14 Sep 2013 04:40:16 PM JST
$0

* Sat 14 Sep 2013 04:40:33 PM JST
normal
* Sat 14 Sep 2013 04:40:35 PM JST
normal
* Sat 14 Sep 2013 04:41:15 PM JST
;;;###autoload
(defun my-junk-auto-insert-elisp ()
  (interactive)
  (insert "junk_elisp_auto-insert")
  (yas/expand))

* Sat 14 Sep 2013 04:41:20 PM JST
elisp_
* Sat 14 Sep 2013 04:41:21 PM JST
junk_elisp_
* Sat 14 Sep 2013 04:42:25 PM JST
;;;###autoload
(defun my-test-auto-insert-python ()
  (interactive)
  (insert "test_auto-insert")
  (yas/expand))

* Sat 14 Sep 2013 04:43:48 PM JST
python
* Sat 14 Sep 2013 04:43:48 PM JST
insert-python
* Sat 14 Sep 2013 04:43:48 PM JST
auto-insert-python
* Sat 14 Sep 2013 05:12:29 PM JST
SUMMARY
* Sat 14 Sep 2013 05:14:05 PM JST
number
* Sat 14 Sep 2013 05:14:31 PM JST
 list
* Sat 14 Sep 2013 05:14:35 PM JST
SUMMARY
* Sat 14 Sep 2013 05:37:07 PM JST
(re-search-forward "[ \t].+?[ \t].+" nil 'noerror)
* Sat 14 Sep 2013 05:37:26 PM JST
(re-search-forward "[ \t].+?[ \t].+" nil 'noerror)
(match-)
* Sat 14 Sep 2013 05:37:51 PM JST
(progn )
* Sat 14 Sep 2013 05:38:02 PM JST
(progn 
(re-search-forward "[ \t].+?[ \t].+" nil 'noerror)
(match-end)
)
* Sat 14 Sep 2013 05:39:23 PM JST
(progn 
(re-search-forward "[ \t].+?[ \t].+" nil 'noerror)
(match-end 0)
)
* Sat 14 Sep 2013 05:40:30 PM JST
(re-search-forward "[ \t].+?[ \t].+" nil 'noerror)
* Sat 14 Sep 2013 05:41:18 PM JST
(re-search-forward "[ \t].+\\?[ \t].+" nil 'noerror)
* Sat 14 Sep 2013 05:41:38 PM JST
(re-search-forward "^[ \t].+\\?[ \t].+" nil 'noerror)
* Sat 14 Sep 2013 05:41:54 PM JST
(re-search-forward "^[ \t].+\\?[ \t]" nil 'noerror)
* Sat 14 Sep 2013 05:42:39 PM JST
(save-recursive)
* Sat 14 Sep 2013 05:42:42 PM JST
(progn
  
(re-search-forward "^[ \t].+\\?[ \t]" nil 'noerror)
(match-end 0)
)
* Sat 14 Sep 2013 05:44:02 PM JST

* Sat 14 Sep 2013 05:44:02 PM JST

* Sat 14 Sep 2013 05:44:03 PM JST
  (match-end 0)

* Sat 14 Sep 2013 05:46:01 PM JST
(svn-mark-forward)
* Sat 14 Sep 2013 05:47:57 PM JST
(svn-set-mark (line-beginning-position) mark)
* Sat 14 Sep 2013 05:48:29 PM JST
(progn
  (save-excursion 
    (goto-char (point-min))
    (while (re-search-forward "^[ \t].+\\?[ \t]" nil 'noerror)
      (svn-set-mark (line-beginning-position) t)
      )
  ))
* Sat 14 Sep 2013 05:49:43 PM JST
(save-excursion 
    (goto-char (point-min))
    (while (re-search-forward "^[ \t].+\\?[ \t]" nil 'noerror)
      (svn-set-mark (line-beginning-position) t)
      )
  )
* Sat 14 Sep 2013 05:49:49 PM JST
"^[ \t].+\\?[ \t]"
* Sat 14 Sep 2013 05:50:58 PM JST
      
* Sat 14 Sep 2013 05:51:01 PM JST
  
* Sat 14 Sep 2013 05:51:39 PM JST
^[ \t].+\\?[ \t]"
* Sat 14 Sep 2013 05:52:09 PM JST
svn-M-mark-a-lot
* Sat 14 Sep 2013 05:52:23 PM JST
(defun svn-M-mark-a-lot ()
  ""
  (interactive)
  (svn--mark-a-lot "^[ \t].+M[ \t]"))

* Sat 14 Sep 2013 05:53:03 PM JST
(defun svn--mark-a-lot (regexp)
  "REGEXP"
  (save-excursion 
    (goto-char (point-min))
    (while (re-search-forward regexp nil 'noerror)
      (svn-set-mark (line-beginning-position) t))
    ))

(defun svn-?-mark-a-lot ()
  ""
  (interactive)
  (svn--mark-a-lot "^[ \t].+\\?[ \t]"))

(defun svn-M-mark-a-lot ()
  ""
  (interactive)
  (svn--mark-a-lot "^[ \t].+M[ \t]"))

(defun svn-A-mark-a-lot ()
  ""
  (interactive)
  (svn--mark-a-lot "^[ \t].+A[ \t]"))

* Sat 14 Sep 2013 05:53:29 PM JST
  
* Sat 14 Sep 2013 05:53:50 PM JST
  
* Sat 14 Sep 2013 05:53:58 PM JST
  
* Sat 14 Sep 2013 05:54:32 PM JST
"U" 'svn-unmark-all
* Sat 14 Sep 2013 05:54:40 PM JST
"k" 'svn-previous-file
* Sat 14 Sep 2013 05:54:48 PM JST
"\C-c?" 'svn-?-mark-a-lot
* Sat 14 Sep 2013 05:54:55 PM JST
"\C-cM" 'svn-M-mark-a-lot
* Sat 14 Sep 2013 05:55:02 PM JST
"\C-cA" 'svn-M-mark-a-lot
* Sat 14 Sep 2013 05:55:30 PM JST
  
* Sat 14 Sep 2013 05:59:00 PM JST
(re-search-forward "^[ \t].+\\?[ \t]" nil 'noerror)
* Sat 14 Sep 2013 05:59:08 PM JST
(re-search-forward "^[ \t].+\\![ \t]" nil 'noerror)
* Sat 14 Sep 2013 06:00:01 PM JST
"^[ \t].+\\![ \t]"
* Sat 14 Sep 2013 06:03:10 PM JST
  
* Sat 14 Sep 2013 06:04:00 PM JST
    
* Sat 14 Sep 2013 06:05:15 PM JST
svn-?-mark-a-lot
* Sat 14 Sep 2013 06:05:26 PM JST
svn-M-mark-a-lot
* Sat 14 Sep 2013 06:05:37 PM JST
svn
* Sat 14 Sep 2013 06:05:39 PM JST
svn-A-mark-a-lot
* Sat 14 Sep 2013 06:05:50 PM JST
svn-!-mark-a-lot
* Sat 14 Sep 2013 06:07:25 PM JST
REGEXP.
* Sat 14 Sep 2013 06:26:16 PM JST
import os as _os
import re as _re
from ref.regexp import REGEXP as _REGEXP

# for debug
import cgitb as _cgitb
_cgitb.enable(format='text')


__revision__ = '$Revision$'
__version__ = '0.2.0'


if _os.name in ['posix', 'java']:
    BOOKMARK_BASE_PATH = '~/.config/google-chrome/Default/Bookmarks'
    BOOKMARK_PATH = _os.path.expanduser(BOOKMARK_BASE_PATH)

elif 'nt' == _os.name:
    BOOKMARK_BASE_PATH = (
'Local Settings/Application Data/Google/Chrome/User Data/Default/Bookmarks')
    BOOKMARK_PATH = _os.path.join(_os.environ['userprofile'], BOOKMARK_BASE_PATH)


def trim_url(url):
    """Triming urls by regexp.

    @Arguments:
    - `urls`: list of urls

    @Return: list of trimed urls
    """
    result = _re.compile(_REGEXP.get('http')).search(url)
    if not result is None:
        return result.group()
    return None


class ExistsNameError(Exception):
    pass


class ChromeBMParse(object):
    """
    """

    def __init__(self, name, bmpath=BOOKMARK_PATH):
        """

        Arguments:
        - `bkmk_path`:
        """
        self._name = name
        self._bmpath = bmpath
        self._file = open(self._bmpath, 'r')
        self._lines = self._file.readlines()
        self.line_num = 0
        self._getline_num()
        self._mvblockend()

    def __iter__(self):
        """SUMMARY

        @Return:
        """
        return self

    def _getline_num(self):
        """Determine line number of name.

        @Arguments:

        - `name`: elements name

        @Return: line number
        """
        self._file.seek(0)
        for num, line in enumerate(self._file):
            if '"name":' in line:
                trimed = line.split('"name":')[1].split('"')[1]
                if self._name == trimed.decode('unicode-escape', 'ignore'):
                    self.line_num = num - 1
        if 0 == self.line_num:
            raise ExistsNameError(
                'Not exists bookmarks folder "{}"'.format(self._name))

    def _mvblockend(self):
        """Move initialize line.

        @Return: Nothing
        """
        while -1 == self._lines[self.line_num].find(']') and self.line_num != 0:
            self.line_num -= 1

    def next(self):
        """Parse urls"""
        operand = -1
        while operand < 0:
            self.line_num -= 1
            if self._lines[self.line_num].find('}') != -1:
                operand -= 1
            if self._lines[self.line_num].find('{') != -1:
                operand += 1
            if operand == -1:
                if self._lines[self.line_num].find('"url":') != -1:
                    result = trim_url(self._lines[self.line_num])
                    if result:
                        return result
        raise StopIteration

    def __del__(self):
        """Close opened file when deconstract."""
        self._file.close()


def get_urls(name):
    """SUMMARY

    @Arguments:
    - `name`:

    @Return:
    """
    g = ChromeBMParse(name)
    urls = []
    for u in g:
        urls.append(u)
    return urls


def test():
    pass


if __name__ == '__main__':
    test()



# For Emacs
# Local Variables:
# coding: utf-8
# End:

* Sat 14 Sep 2013 06:26:21 PM JST
r""" googlechrome -- handling for google chrome.

Changelog:
inpremented iterator `ChromeMBParse`

$Revision$

"""


import os as _os
import re as _re
from ref.regexp import REGEXP as _REGEXP

# for debug
import cgitb as _cgitb
_cgitb.enable(format='text')


__revision__ = '$Revision$'
__version__ = '0.2.0'


if _os.name in ['posix', 'java']:
    BOOKMARK_BASE_PATH = '~/.config/google-chrome/Default/Bookmarks'
    BOOKMARK_PATH = _os.path.expanduser(BOOKMARK_BASE_PATH)

elif 'nt' == _os.name:
    BOOKMARK_BASE_PATH = (
'Local Settings/Application Data/Google/Chrome/User Data/Default/Bookmarks')
    BOOKMARK_PATH = _os.path.join(_os.environ['userprofile'], BOOKMARK_BASE_PATH)


def trim_url(url):
    """Triming urls by regexp.

    @Arguments:
    - `urls`: list of urls

    @Return: list of trimed urls
    """
    result = _re.compile(_REGEXP.get('http')).search(url)
    if not result is None:
        return result.group()
    return None


class ExistsNameError(Exception):
    pass


class ChromeBMParse(object):
    """
    """

    def __init__(self, name, bmpath=BOOKMARK_PATH):
        """

        Arguments:
        - `bkmk_path`:
        """
        self._name = name
        self._bmpath = bmpath
        self._file = open(self._bmpath, 'r')
        self._lines = self._file.readlines()
        self.line_num = 0
        self._getline_num()
        self._mvblockend()

    def __iter__(self):
        """SUMMARY

        @Return:
        """
        return self

    def _getline_num(self):
        """Determine line number of name.

        @Arguments:

        - `name`: elements name

        @Return: line number
        """
        self._file.seek(0)
        for num, line in enumerate(self._file):
            if '"name":' in line:
                trimed = line.split('"name":')[1].split('"')[1]
                if self._name == trimed.decode('unicode-escape', 'ignore'):
                    self.line_num = num - 1
        if 0 == self.line_num:
            raise ExistsNameError(
                'Not exists bookmarks folder "{}"'.format(self._name))

    def _mvblockend(self):
        """Move initialize line.

        @Return: Nothing
        """
        while -1 == self._lines[self.line_num].find(']') and self.line_num != 0:
            self.line_num -= 1

    def next(self):
        """Parse urls"""
        operand = -1
        while operand < 0:
            self.line_num -= 1
            if self._lines[self.line_num].find('}') != -1:
                operand -= 1
            if self._lines[self.line_num].find('{') != -1:
                operand += 1
            if operand == -1:
                if self._lines[self.line_num].find('"url":') != -1:
                    result = trim_url(self._lines[self.line_num])
                    if result:
                        return result
        raise StopIteration

    def __del__(self):
        """Close opened file when deconstract."""
        self._file.close()


def get_urls(name):
    """SUMMARY

    @Arguments:
    - `name`:

    @Return:
    """
    g = ChromeBMParse(name)
    urls = []
    for u in g:
        urls.append(u)
    return urls


def test():
    pass


if __name__ == '__main__':
    test()



# For Emacs
# Local Variables:
# coding: utf-8
# End:

* Sat 14 Sep 2013 06:26:35 PM JST
r
* Sat 14 Sep 2013 06:26:42 PM JST
google
* Sat 14 Sep 2013 06:29:02 PM JST
import
* Sat 14 Sep 2013 06:40:34 PM JST
r"""\
Name: __init__.py


"""


import urlparse as _urlparse
from lxmllib import lxml_soup as _lxml_soup


__revision__ = "$Revision$"
__version__ = "0.1.0"

__all__ = [ '' ]


url = 'http://www.google.com/search?hl=ja&q=%(query)s&num=1'

def google_feeling_lucky(query, verbose=False):
    """SUMMARY

    @Arguments:
    - `query`:

    @Return:
    """
    query = query.encode('utf-8')
    if verbose:
        print(query)
    search_url = (url % vars())
    search_url = search_url.replace(' ', '+').replace('　', '+')
    print(search_url)
    soup = _lxml_soup(search_url, wait=10)
    try:
        link = soup.xpath('//*[@class="r"]/a')[0].attrib['href']
        link = filter_result(link)
    except IndexError:
        link = ''
    return link

def filter_result(link):
    try:

        # Valid results are absolute URLs not pointing to a Google domain
        # like images.google.com or googleusercontent.com
        o = _urlparse.urlparse(link, 'http')
        if o.netloc and 'google' not in o.netloc:
            return link

        # Decode hidden URLs.
        if link.startswith('/url?'):
            link = _urlparse.parse_qs(o.query)['q'][0]

            # Valid results are absolute URLs not pointing to a Google domain
            # like images.google.com or googleusercontent.com
            o = _urlparse.urlparse(link, 'http')
            if o.netloc and 'google' not in o.netloc:
                return link

    # Otherwise, or on error, return None.
    except Exception:
        pass
    return None



# For Emacs
# Local Variables:
# coding: utf-8
# End:

* Sat 14 Sep 2013 06:41:01 PM JST
__init__
* Sat 14 Sep 2013 06:41:06 PM JST

* Sat 14 Sep 2013 06:41:06 PM JST

* Sat 14 Sep 2013 06:41:06 PM JST
__all__ = [ '' ]

* Sat 14 Sep 2013 06:41:28 PM JST
google_feeling_lucky
* Sat 14 Sep 2013 06:43:01 PM JST

* Sat 14 Sep 2013 06:43:01 PM JST

* Sat 14 Sep 2013 06:43:01 PM JST
__all__ = [ '' ]

* Sat 14 Sep 2013 09:52:16 PM JST
xfce4-taskmanager
* Sat 14 Sep 2013 10:02:11 PM JST
def trim_url(url):
    """Triming urls by regexp.

    @Arguments:
    - `urls`: list of urls

    @Return: list of trimed urls
    """
    result = _re.compile(_REGEXP.get('http')).search(url)
    if not result is None:
        return result.group()
    return None


* Sat 14 Sep 2013 10:02:37 PM JST
from ref.regexp import REGEXP as _REGEXP
* Sat 14 Sep 2013 10:02:59 PM JST

* Sat 14 Sep 2013 10:02:59 PM JST

* Sat 14 Sep 2013 10:03:00 PM JST
import re as _re

* Sat 14 Sep 2013 11:00:52 PM JST

* Sat 14 Sep 2013 11:00:52 PM JST

* Sat 14 Sep 2013 11:00:52 PM JST
## FIXME: could not find svn URL in dependency_links for this package:

* Sat 14 Sep 2013 11:00:53 PM JST

* Sat 14 Sep 2013 11:00:53 PM JST

* Sat 14 Sep 2013 11:00:53 PM JST
## FIXME: could not find svn URL in dependency_links for this package:

* Sat 14 Sep 2013 11:01:17 PM JST
==1.1
* Sat 14 Sep 2013 11:01:19 PM JST
==3.2.1
* Sat 14 Sep 2013 11:01:20 PM JST
==1.0
* Sat 14 Sep 2013 11:01:20 PM JST
==1.4.5
* Sat 14 Sep 2013 11:01:20 PM JST
==0.1.6
* Sat 14 Sep 2013 11:01:20 PM JST
==1.2.4
* Sat 14 Sep 2013 11:01:20 PM JST
==0.3.2
* Sat 14 Sep 2013 11:01:20 PM JST
==0.75
* Sat 14 Sep 2013 11:01:20 PM JST
==1.0.0.0-dev
* Sat 14 Sep 2013 11:01:20 PM JST
==0.21.1
* Sat 14 Sep 2013 11:01:20 PM JST
==0.2
* Sat 14 Sep 2013 11:01:20 PM JST
==1.2.3
* Sat 14 Sep 2013 11:01:21 PM JST
==1.0
* Sat 14 Sep 2013 11:01:21 PM JST
==0.4.2
* Sat 14 Sep 2013 11:01:21 PM JST
==1.1.7
* Sat 14 Sep 2013 11:01:21 PM JST
==0.18
* Sat 14 Sep 2013 11:01:21 PM JST
==0.11.1
* Sat 14 Sep 2013 11:01:21 PM JST
==1.5
* Sat 14 Sep 2013 11:01:21 PM JST
==0.23
* Sat 14 Sep 2013 11:01:21 PM JST
==0.6
* Sat 14 Sep 2013 11:01:21 PM JST
==0.12.0
* Sat 14 Sep 2013 11:01:21 PM JST
==0.7.8
* Sat 14 Sep 2013 11:01:21 PM JST
==1.3
* Sat 14 Sep 2013 11:01:21 PM JST
==12.0.0
* Sat 14 Sep 2013 11:01:21 PM JST
==12.0.0
* Sat 14 Sep 2013 11:01:21 PM JST
==12.0.0
* Sat 14 Sep 2013 11:01:22 PM JST
==12.0.0
* Sat 14 Sep 2013 11:01:22 PM JST
==12.0.0
* Sat 14 Sep 2013 11:01:22 PM JST
==12.0.0
* Sat 14 Sep 2013 11:01:22 PM JST
==12.0.0
* Sat 14 Sep 2013 11:01:22 PM JST
==12.0.0
* Sat 14 Sep 2013 11:01:22 PM JST
==12.0.0
* Sat 14 Sep 2013 11:01:22 PM JST
==12.0.0
* Sat 14 Sep 2013 11:01:22 PM JST
==1.1
* Sat 14 Sep 2013 11:01:22 PM JST
==3.7.6.3-r1
* Sat 14 Sep 2013 11:01:23 PM JST
==1.2.1
* Sat 14 Sep 2013 11:01:23 PM JST
==1.2
* Sat 14 Sep 2013 11:01:23 PM JST
==2.0.1
* Sat 14 Sep 2013 11:01:23 PM JST
==0.2.4
* Sat 14 Sep 2013 11:01:23 PM JST
==4.7.2
* Sat 14 Sep 2013 11:01:23 PM JST
==0.5.6
* Sat 14 Sep 2013 11:01:23 PM JST
==3.3.3
* Sat 14 Sep 2013 11:01:23 PM JST
==1.0.6
* Sat 14 Sep 2013 11:01:23 PM JST
==0.6.24dev-r0
* Sat 14 Sep 2013 11:01:23 PM JST
==1.10.0
* Sat 14 Sep 2013 11:01:23 PM JST
==0.8.1
* Sat 14 Sep 2013 11:01:23 PM JST
==0.96
* Sat 14 Sep 2013 11:01:23 PM JST
==0.0.5
* Sat 14 Sep 2013 11:01:23 PM JST
==3.0.1
* Sat 14 Sep 2013 11:01:24 PM JST
==0.4.1
* Sat 14 Sep 2013 11:01:24 PM JST
==1.2
* Sat 14 Sep 2013 11:01:24 PM JST
==0.7.2
* Sat 14 Sep 2013 11:01:24 PM JST
==1.13.0
* Sat 14 Sep 2013 11:01:24 PM JST
==0.2.1
* Sat 14 Sep 2013 11:01:24 PM JST
==0.13.6
* Sat 14 Sep 2013 11:01:24 PM JST
==1.04
* Sat 14 Sep 2013 11:01:24 PM JST
==0.3.1
* Sat 14 Sep 2013 11:01:24 PM JST
==0.7.4
* Sat 14 Sep 2013 11:01:24 PM JST
==0.4.4
* Sat 14 Sep 2013 11:01:24 PM JST
==0.13.1
* Sat 14 Sep 2013 11:01:24 PM JST
==0.7.0
* Sat 14 Sep 2013 11:01:24 PM JST
==0.4.0
* Sat 14 Sep 2013 11:01:25 PM JST
==0.7.8
* Sat 14 Sep 2013 11:01:25 PM JST
==1.0
* Sat 14 Sep 2013 11:01:25 PM JST
==0.12.0
* Sat 14 Sep 2013 11:01:25 PM JST
==1.0.3
* Sat 14 Sep 2013 11:01:25 PM JST
==0.3.2
* Sat 14 Sep 2013 11:01:25 PM JST
==0.24.2
* Sat 14 Sep 2013 11:01:25 PM JST
==0.59.0
* Sat 14 Sep 2013 11:01:25 PM JST
==2.3.2
* Sat 14 Sep 2013 11:01:25 PM JST
==1.1.1rc2
* Sat 14 Sep 2013 11:01:25 PM JST
==0.8
* Sat 14 Sep 2013 11:01:25 PM JST
==1.1.1
* Sat 14 Sep 2013 11:01:25 PM JST
==0.7.7
* Sat 14 Sep 2013 11:01:25 PM JST
==1.3.0
* Sat 14 Sep 2013 11:01:25 PM JST
==1.6.2
* Sat 14 Sep 2013 11:01:25 PM JST
==1.0.1
* Sat 14 Sep 2013 11:01:26 PM JST
==0.1.2
* Sat 14 Sep 2013 11:01:26 PM JST
==1.7.7.1
* Sat 14 Sep 2013 11:01:26 PM JST
==0.10.8
* Sat 14 Sep 2013 11:01:26 PM JST
==2.4
* Sat 14 Sep 2013 11:01:26 PM JST
==1.0.1
* Sat 14 Sep 2013 11:01:26 PM JST
==2.4.5
* Sat 14 Sep 2013 11:01:26 PM JST
==0.13
* Sat 14 Sep 2013 11:01:26 PM JST
==1.13
* Sat 14 Sep 2013 11:01:26 PM JST
==0.1.3
* Sat 14 Sep 2013 11:01:26 PM JST
==2.6
* Sat 14 Sep 2013 11:01:26 PM JST
==0.5.29
* Sat 14 Sep 2013 11:01:26 PM JST
==7.19.0
* Sat 14 Sep 2013 11:01:26 PM JST
==2.3.6
* Sat 14 Sep 2013 11:01:26 PM JST
==0.5.0
* Sat 14 Sep 2013 11:01:27 PM JST
==1.1.0
* Sat 14 Sep 2013 11:01:27 PM JST
==1.9.1release
* Sat 14 Sep 2013 11:01:27 PM JST
==0.27.0
* Sat 14 Sep 2013 11:01:27 PM JST
==1.0.2
* Sat 14 Sep 2013 11:01:27 PM JST
==1.5.6
* Sat 14 Sep 2013 11:01:27 PM JST
==0.4.0
* Sat 14 Sep 2013 11:01:27 PM JST
==1.6.14
* Sat 14 Sep 2013 11:01:27 PM JST
==0.3.2
* Sat 14 Sep 2013 11:01:27 PM JST
==2.5
* Sat 14 Sep 2013 11:01:28 PM JST
==4.2.2
* Sat 14 Sep 2013 11:01:28 PM JST
==0.3.2
* Sat 14 Sep 2013 11:01:28 PM JST
==0.1.3
* Sat 14 Sep 2013 11:01:28 PM JST
==2.6.3
* Sat 14 Sep 2013 11:01:28 PM JST
==0.8.8.2
* Sat 14 Sep 2013 11:01:28 PM JST
==1.5
* Sat 14 Sep 2013 11:01:28 PM JST
==0.1.21
* Sat 14 Sep 2013 11:01:28 PM JST
==1.11
* Sat 14 Sep 2013 11:01:28 PM JST
==0.1.10
* Sat 14 Sep 2013 11:01:28 PM JST
==0.14
* Sat 14 Sep 2013 11:01:28 PM JST
==0.2.1
* Sat 14 Sep 2013 11:01:28 PM JST
==2012c
* Sat 14 Sep 2013 11:01:28 PM JST
==1.0.0a3
* Sat 14 Sep 2013 11:01:28 PM JST
==0.19
* Sat 14 Sep 2013 11:01:28 PM JST
==0.4.1
* Sat 14 Sep 2013 11:01:29 PM JST
==6.4.4
* Sat 14 Sep 2013 11:01:29 PM JST
==0.12.1
* Sat 14 Sep 2013 11:01:29 PM JST
==1.0
* Sat 14 Sep 2013 11:01:29 PM JST
==0.9.2
* Sat 14 Sep 2013 11:01:29 PM JST
==0.6c2
* Sat 14 Sep 2013 11:01:29 PM JST
==2.2.0
* Sat 14 Sep 2013 11:01:29 PM JST
==0.0.3
* Sat 14 Sep 2013 11:01:29 PM JST
==0.8.1
* Sat 14 Sep 2013 11:01:29 PM JST
==2.5.2
* Sat 14 Sep 2013 11:01:29 PM JST
==1.1.0
* Sat 14 Sep 2013 11:01:29 PM JST
==0.8
* Sat 14 Sep 2013 11:01:29 PM JST
==1.7.1
* Sat 14 Sep 2013 11:01:29 PM JST
==0.2
* Sat 14 Sep 2013 11:01:29 PM JST
==0.1
* Sat 14 Sep 2013 11:01:30 PM JST
==0.9.4
* Sat 14 Sep 2013 11:01:30 PM JST
==1.0.1
* Sat 14 Sep 2013 11:01:30 PM JST
==1.0
* Sat 14 Sep 2013 11:01:30 PM JST
==1.9.1
* Sat 14 Sep 2013 11:01:30 PM JST
==0.2.4
* Sat 14 Sep 2013 11:01:30 PM JST
==3.7.1
* Sat 14 Sep 2013 11:01:30 PM JST
==1.3.0
* Sat 14 Sep 2013 11:01:30 PM JST
==1.3.10
* Sat 14 Sep 2013 11:01:30 PM JST
==0.1.2
* Sat 14 Sep 2013 11:01:30 PM JST
==0.6.5
* Sat 14 Sep 2013 11:01:30 PM JST
==2.8.12.1
* Sat 14 Sep 2013 11:01:30 PM JST
==2.8.12.1
* Sat 14 Sep 2013 11:01:30 PM JST
==1.6
* Sat 14 Sep 2013 11:01:30 PM JST
==0.56
* Sat 14 Sep 2013 11:01:31 PM JST
==3.6.1
* Sat 14 Sep 2013 11:04:31 PM JST
junk.
* Sat 14 Sep 2013 11:04:32 PM JST
230430.junk.
* Sat 14 Sep 2013 11:04:33 PM JST
14-230430.junk.
* Sat 14 Sep 2013 11:04:33 PM JST
09-14-230430.junk.
* Sat 14 Sep 2013 11:04:33 PM JST
2013-09-14-230430.junk.
* Sat 14 Sep 2013 11:06:41 PM JST
packages
* Sat 14 Sep 2013 11:07:18 PM JST
'/root/pip_ni_trimed.txt'
* Sat 14 Sep 2013 11:15:49 PM JST
extend
* Sat 14 Sep 2013 11:16:25 PM JST
subst
* Sat 14 Sep 2013 11:21:02 PM JST
paramiko
* Sat 14 Sep 2013 11:23:28 PM JST
sbp()
* Sat 14 Sep 2013 11:24:49 PM JST
print 
* Sat 14 Sep 2013 11:28:52 PM JST

* Sat 14 Sep 2013 11:28:52 PM JST

* Sat 14 Sep 2013 11:28:52 PM JST
                newlines = [name + '\n']

* Sat 14 Sep 2013 11:32:43 PM JST
newlines
* Sat 14 Sep 2013 11:34:23 PM JST
open(outputf, 'w')
* Sat 14 Sep 2013 11:34:34 PM JST

* Sat 14 Sep 2013 11:34:34 PM JST

* Sat 14 Sep 2013 11:34:34 PM JST
    newf = open(outputf, 'w')

* Sat 14 Sep 2013 11:34:35 PM JST

* Sat 14 Sep 2013 11:34:35 PM JST

* Sat 14 Sep 2013 11:34:35 PM JST
    newf.close()

* Sat 14 Sep 2013 11:35:02 PM JST
root/
* Sat 14 Sep 2013 11:40:35 PM JST
line.replace('\n', '')
* Sat 14 Sep 2013 11:40:54 PM JST
line.replace('\n', '')
* Sat 14 Sep 2013 11:41:13 PM JST
name.replace('\n', '')
* Sat 14 Sep 2013 11:45:39 PM JST
'INSTALLED:' in line
* Sat 14 Sep 2013 11:47:32 PM JST
if 'INSTALLED:' in line:
* Sat 14 Sep 2013 11:50:12 PM JST

* Sat 14 Sep 2013 11:50:12 PM JST

* Sat 14 Sep 2013 11:50:12 PM JST
            if name.endswith('\n'):

* Sat 14 Sep 2013 11:50:13 PM JST
            if name.endswith('\n'):

* Sat 14 Sep 2013 11:50:13 PM JST
            if name.endswith('\n'):
                name.replace('\n', '')

* Sat 14 Sep 2013 11:54:22 PM JST
'\n'.join(newlines)
* Sat 14 Sep 2013 11:56:33 PM JST
newlines
* Sat 14 Sep 2013 11:58:29 PM JST
BBQSQLp
* Sun 15 Sep 2013 12:03:32 AM JST

* Sun 15 Sep 2013 12:03:32 AM JST

* Sun 15 Sep 2013 12:03:32 AM JST
            print(p)

* Sun 15 Sep 2013 12:06:49 AM JST

* Sun 15 Sep 2013 12:06:49 AM JST

* Sun 15 Sep 2013 12:06:49 AM JST
            print(p.communicate())

* Sun 15 Sep 2013 12:06:50 AM JST
            print(p.communicate())

* Sun 15 Sep 2013 12:06:50 AM JST
            print(p.communicate())
            newlines = [name]

* Sun 15 Sep 2013 12:08:31 AM JST
.replace('\n', '')
* Sun 15 Sep 2013 12:08:38 AM JST
                          
* Sun 15 Sep 2013 12:08:52 AM JST

* Sun 15 Sep 2013 12:08:52 AM JST

* Sun 15 Sep 2013 12:08:52 AM JST
            print(p.stderr.readlines())

* Sun 15 Sep 2013 12:08:57 AM JST
pipchecklatest
* Sun 15 Sep 2013 12:09:23 AM JST

* Sun 15 Sep 2013 12:09:23 AM JST

* Sun 15 Sep 2013 12:09:23 AM JST
            print(repr(name))

* Sun 15 Sep 2013 12:09:42 AM JST

* Sun 15 Sep 2013 12:09:42 AM JST

* Sun 15 Sep 2013 12:09:42 AM JST
            # print(p.stdout.readlines())

* Sun 15 Sep 2013 12:09:46 AM JST
            # print(p.stdout.readlines())

* Sun 15 Sep 2013 12:09:46 AM JST
            # print(p.stdout.readlines())
            print('DEBUG-2-pipchecklatest.py')

* Sun 15 Sep 2013 12:11:33 AM JST
                          
* Sun 15 Sep 2013 12:11:45 AM JST

* Sun 15 Sep 2013 12:11:45 AM JST

* Sun 15 Sep 2013 12:11:45 AM JST
                print(line)

* Sun 15 Sep 2013 12:11:46 AM JST
                print(line)

* Sun 15 Sep 2013 12:11:46 AM JST
                print(line)
                print('DEBUG-1-pipchecklatest.py')

* Sun 15 Sep 2013 12:12:53 AM JST

* Sun 15 Sep 2013 12:12:53 AM JST

* Sun 15 Sep 2013 12:12:53 AM JST
            print('\n'.join(newlines))

* Sun 15 Sep 2013 12:40:00 AM JST
'LATEST:' in line
* Sun 15 Sep 2013 12:40:06 AM JST

* Sun 15 Sep 2013 12:40:06 AM JST

* Sun 15 Sep 2013 12:40:06 AM JST
                if :

* Sun 15 Sep 2013 12:40:06 AM JST
                if :

* Sun 15 Sep 2013 12:40:06 AM JST
                if :
                    print(line)

* Sun 15 Sep 2013 12:40:07 AM JST
                if :
                    print(line)

* Sun 15 Sep 2013 12:40:07 AM JST
                if :
                    print(line)
                    newlines.append(line)

* Sun 15 Sep 2013 12:43:03 AM JST

* Sun 15 Sep 2013 12:43:03 AM JST

* Sun 15 Sep 2013 12:43:03 AM JST
                else:

* Sun 15 Sep 2013 12:43:35 AM JST
'\n'.join(newlines)
* Sun 15 Sep 2013 12:44:15 AM JST
'\n'.join(newlines)
* Sun 15 Sep 2013 12:54:47 AM JST
ELS
* Sun 15 Sep 2013 12:54:49 AM JST
if
* Sun 15 Sep 2013 12:57:29 AM JST
        
* Sun 15 Sep 2013 12:57:42 AM JST
(unless (y-or-n-p "File already exists. Overwrite? y,n: ")
* Sun 15 Sep 2013 12:58:26 AM JST
(when (and (file-exists-p new)
               (unless (y-or-n-p "File already exists. Overwrite? y,n: "))
      (error "exiting.")
        ))
* Sun 15 Sep 2013 12:59:24 AM JST

* Sun 15 Sep 2013 12:59:24 AM JST

* Sun 15 Sep 2013 12:59:24 AM JST
           (error "exiting.")

* Sun 15 Sep 2013 12:59:29 AM JST
           
* Sun 15 Sep 2013 01:02:52 AM JST
unless 
* Sun 15 Sep 2013 01:03:08 AM JST

* Sun 15 Sep 2013 01:03:08 AM JST

* Sun 15 Sep 2013 01:03:08 AM JST
      (error "exiting.")

* Sun 15 Sep 2013 01:03:16 AM JST
               
* Sun 15 Sep 2013 01:03:38 AM JST
      
* Sun 15 Sep 2013 01:08:09 AM JST

* Sun 15 Sep 2013 01:08:09 AM JST

* Sun 15 Sep 2013 01:08:09 AM JST
    (setq fileexists 'nil)

* Sun 15 Sep 2013 01:08:16 AM JST
fileexists
* Sun 15 Sep 2013 01:09:06 AM JST
      
* Sun 15 Sep 2013 01:09:10 AM JST
exists
* Sun 15 Sep 2013 01:12:05 AM JST
    
* Sun 15 Sep 2013 01:12:07 AM JST
  
* Sun 15 Sep 2013 01:15:49 AM JST
;;;; save scrap code
;;
(defun scrap-code ()
  "Scraping my code to scrap directory."
  (interactive)
  (let* ((overwrite nil)
         (origname (buffer-file-name))
         (file-name (file-name-nondirectory origname))
         (file-name-noextension (file-name-sans-extension file-name))
         (extension (file-name-extension file-name))
         (major-name (if (eq major-mode 'emacs-lisp-mode) "elisp"
                       (downcase (replace-regexp-in-string
                                  "-mode" "" (symbol-name major-mode)))))
         (parent-dir my-code-dir)
         (dir (expand-file-name "scrap"
                                (expand-file-name major-name parent-dir)))
         (default-name (expand-file-name
                        (concat file-name-noextension ".scrap." extension) dir))
         (new (read-string
               "Save scrap file: " default-name nil default-name)))
    (unless (file-exists-p dir)
      (make-directory dir))
    (when (and (file-exists-p new)
               (y-or-n-p "File already exists. Overwrite?"))
      (setq overwrite t))
    (copy-file origname new overwrite)
    (if (file-exists-p new)
        (message "Saved %s file." new)
      (error "has error scrap-code"))))


* Sun 15 Sep 2013 01:20:04 AM JST
scrap
* Sun 15 Sep 2013 01:20:06 AM JST
scrap-code
* Sun 15 Sep 2013 01:20:46 AM JST
code
* Sun 15 Sep 2013 01:20:46 AM JST
my code
* Sun 15 Sep 2013 01:20:59 AM JST
Scraping current buffer to scrap directory.
* Sun 15 Sep 2013 01:26:01 AM JST
auto-async-byte-compile
* Sun 15 Sep 2013 01:28:56 AM JST
buffer
* Sun 15 Sep 2013 01:30:05 AM JST
()
* Sun 15 Sep 2013 01:31:48 AM JST
save-window-excursion
* Sun 15 Sep 2013 01:32:04 AM JST
(save-window-excursion )
* Sun 15 Sep 2013 01:33:41 AM JST
(switch-to-buffer *Messages*)
* Sun 15 Sep 2013 01:34:11 AM JST
(save-window-excursion (switch-to-buffer "*Messages*"))
* Sun 15 Sep 2013 01:37:13 AM JST
after-save-hook
* Sun 15 Sep 2013 01:38:14 AM JST

* Sun 15 Sep 2013 01:38:14 AM JST

* Sun 15 Sep 2013 01:38:14 AM JST
  (save-window-excursion 

* Sun 15 Sep 2013 01:43:05 AM JST
(let (buffname (current-buffer))
    
    ad-do-it
    (princ buffname)
    (switch-to-buffer buffname)
    )
* Sun 15 Sep 2013 01:43:09 AM JST

* Sun 15 Sep 2013 01:43:09 AM JST

* Sun 15 Sep 2013 01:43:10 AM JST
  ad-do-it

* Sun 15 Sep 2013 01:48:04 AM JST

* Sun 15 Sep 2013 01:48:04 AM JST

* Sun 15 Sep 2013 01:48:04 AM JST
    (princ buffname)

* Sun 15 Sep 2013 01:48:22 AM JST
sleep 
* Sun 15 Sep 2013 01:50:29 AM JST
(defadvice auto-async-byte-compile
  (around save-current-buffer-auto-async-byte-compile activate)
  (let ((buffname (current-buffer)))
    ad-do-it
    (sleep-for 1)
    (switch-to-buffer buffname)
    )
  )
;; (progn (ad-disable-advice 'auto-async-byte-compile 'around 'save-current-buffer-auto-async-byte-compile) (ad-update 'auto-async-byte-compile))
)

* Sun 15 Sep 2013 01:51:04 AM JST
return buffer after auto-async-byte-compile
* Sun 15 Sep 2013 01:52:25 AM JST

* Sun 15 Sep 2013 01:52:25 AM JST

* Sun 15 Sep 2013 01:52:25 AM JST
  "Return buffer after auto-async-byte-compile."

* Sun 15 Sep 2013 01:52:58 AM JST
  
* Sun 15 Sep 2013 02:53:45 AM JST
/usr/local/lib/python2.7/dist-packages/
* Sun 15 Sep 2013 03:05:05 AM JST
(auto-install-from-url https://github.com/kiwanami/emacs-deferred/raw/master/deferred.el")
* Sun 15 Sep 2013 03:11:12 AM JST
sys.
* Sun 15 Sep 2013 03:24:30 AM JST
sys.
* Sun 15 Sep 2013 03:24:52 AM JST
sys.
* Sun 15 Sep 2013 03:27:46 AM JST
_os.path
* Sun 15 Sep 2013 03:33:23 AM JST
os.path.
* Sun 15 Sep 2013 03:33:31 AM JST
os.path
* Sun 15 Sep 2013 03:35:54 AM JST
path
* Sun 15 Sep 2013 03:35:54 AM JST
os.path
* Sun 15 Sep 2013 03:37:41 AM JST

* Sun 15 Sep 2013 03:38:46 AM JST

* Sun 15 Sep 2013 03:51:52 AM JST
os.path
* Sun 15 Sep 2013 03:54:05 AM JST
~/
* Sun 15 Sep 2013 03:54:51 AM JST
riscos.
* Sun 15 Sep 2013 03:56:03 AM JST
ref.C
* Sun 15 Sep 2013 03:57:37 AM JST
~/
* Sun 15 Sep 2013 04:00:08 AM JST
os.path.exit
* Sun 15 Sep 2013 04:01:49 AM JST
path
* Sun 15 Sep 2013 04:03:05 AM JST
path
* Sun 15 Sep 2013 04:03:18 AM JST
os.
* Sun 15 Sep 2013 04:03:36 AM JST
os.
* Sun 15 Sep 2013 04:07:16 AM JST
ex
* Sun 15 Sep 2013 04:07:17 AM JST
path.ex
* Sun 15 Sep 2013 04:07:50 AM JST
os.
* Sun 15 Sep 2013 04:08:00 AM JST

* Sun 15 Sep 2013 04:08:00 AM JST

* Sun 15 Sep 2013 04:08:00 AM JST
import os

* Sun 15 Sep 2013 04:08:00 AM JST
import os

* Sun 15 Sep 2013 04:08:00 AM JST
import os
os.

* Sun 15 Sep 2013 04:10:13 AM JST
~/
* Sun 15 Sep 2013 04:12:28 AM JST
path.
* Sun 15 Sep 2013 04:12:36 AM JST

* Sun 15 Sep 2013 04:12:37 AM JST

* Sun 15 Sep 2013 04:12:37 AM JST
__revision__ = '$Revision$'

* Sun 15 Sep 2013 04:12:37 AM JST
__revision__ = '$Revision$'

* Sun 15 Sep 2013 04:12:37 AM JST
__revision__ = '$Revision$'
__version__ = '0.1.0'

* Sun 15 Sep 2013 04:12:40 AM JST
path.
* Sun 15 Sep 2013 04:12:56 AM JST
name
* Sun 15 Sep 2013 04:12:56 AM JST
os.name
* Sun 15 Sep 2013 04:13:38 AM JST
path.
* Sun 15 Sep 2013 04:13:39 AM JST
os.path.
* Sun 15 Sep 2013 04:13:43 AM JST
os.path.
* Sun 15 Sep 2013 04:14:26 AM JST

* Sun 15 Sep 2013 04:14:27 AM JST

* Sun 15 Sep 2013 04:14:27 AM JST


* Sun 15 Sep 2013 04:15:42 AM JST

* Sun 15 Sep 2013 04:15:42 AM JST

* Sun 15 Sep 2013 04:15:42 AM JST


* Sun 15 Sep 2013 04:15:56 AM JST

* Sun 15 Sep 2013 04:15:56 AM JST

* Sun 15 Sep 2013 04:15:56 AM JST


* Sun 15 Sep 2013 04:16:30 AM JST

* Sun 15 Sep 2013 04:16:30 AM JST

* Sun 15 Sep 2013 04:16:30 AM JST


* Sun 15 Sep 2013 04:18:08 AM JST

* Sun 15 Sep 2013 04:18:08 AM JST

* Sun 15 Sep 2013 04:18:08 AM JST


* Sun 15 Sep 2013 04:18:39 AM JST

* Sun 15 Sep 2013 04:18:39 AM JST

* Sun 15 Sep 2013 04:18:39 AM JST
# 末尾の`'は"Local Variables"用。改頁前には"\n"を入れること。fileの読込を早くする。

* Sun 15 Sep 2013 04:22:07 AM JST
_sys.
* Sun 15 Sep 2013 04:24:01 AM JST
~/
* Sun 15 Sep 2013 04:26:04 AM JST

* Sun 15 Sep 2013 04:26:04 AM JST

* Sun 15 Sep 2013 04:26:04 AM JST
  (add-to-list 'ac-sources 'ac-source-jedi-direct 'append)

* Sun 15 Sep 2013 04:29:37 AM JST
ac-source-jedi-direct
* Sun 15 Sep 2013 04:34:40 AM JST
'
* Sun 15 Sep 2013 04:36:33 AM JST
  
* Sun 15 Sep 2013 04:39:25 AM JST
;;;; python-mode
(autoload 'python-mode "python-mode" "Python editing mode." t)
(eval-after-load 'python-mode        '(python-mode-predefine))


* Sun 15 Sep 2013 04:41:17 AM JST
conma
* Sun 15 Sep 2013 04:42:06 AM JST
inferior-python-mode-hook-predefine
* Sun 15 Sep 2013 04:42:53 AM JST
mode
* Sun 15 Sep 2013 04:52:23 AM JST
KEYWORD.
* Sun 15 Sep 2013 04:54:01 AM JST
(unless auto-complete-mode
    (auto-complete-mode))
* Sun 15 Sep 2013 04:54:16 AM JST

* Sun 15 Sep 2013 04:54:16 AM JST

* Sun 15 Sep 2013 04:54:16 AM JST
  (auto-complete-mode 1)

* Sun 15 Sep 2013 04:56:43 AM JST
  (auto-complete-mode 1)

* Sun 15 Sep 2013 04:57:42 AM JST
(message "Loading python..")
* Sun 15 Sep 2013 05:03:04 AM JST

* Sun 15 Sep 2013 05:03:04 AM JST

* Sun 15 Sep 2013 05:03:04 AM JST
  ;; (message "Loading python-mode-hook-predefine..")

* Sun 15 Sep 2013 05:03:05 AM JST

* Sun 15 Sep 2013 05:03:05 AM JST

* Sun 15 Sep 2013 05:03:05 AM JST
  (message "DEBUG-1-python_mode_start.el")

* Sun 15 Sep 2013 05:03:07 AM JST

* Sun 15 Sep 2013 05:03:07 AM JST

* Sun 15 Sep 2013 05:03:07 AM JST
  (message "DEBUG-2-python_mode_start.el")

* Sun 15 Sep 2013 05:04:16 AM JST

* Sun 15 Sep 2013 05:04:16 AM JST

* Sun 15 Sep 2013 05:04:16 AM JST
  (smart-operator-mode-on)

* Sun 15 Sep 2013 05:05:33 AM JST

* Sun 15 Sep 2013 05:05:33 AM JST

* Sun 15 Sep 2013 05:05:33 AM JST
;; (add-hook 'python-mode-hook 'python-coding-style)

* Sun 15 Sep 2013 05:05:35 AM JST

* Sun 15 Sep 2013 05:05:35 AM JST

* Sun 15 Sep 2013 05:05:35 AM JST
;; (add-hook 'python-mode-hook 'jedi:setup)

* Sun 15 Sep 2013 05:05:35 AM JST
;; (add-hook 'python-mode-hook 'jedi:setup)

* Sun 15 Sep 2013 05:05:35 AM JST
;; (add-hook 'python-mode-hook 'jedi:setup)
;; (add-hook 'python-mode-hook 'jedi:ac-setup)

* Sun 15 Sep 2013 05:10:37 AM JST
https://launchpad.net/python-mode
* Sun 15 Sep 2013 05:14:59 AM JST
os.path.
* Sun 15 Sep 2013 05:22:29 AM JST
pa
* Sun 15 Sep 2013 05:22:29 AM JST
os.pa
* Sun 15 Sep 2013 05:23:16 AM JST
path.
* Sun 15 Sep 2013 05:23:52 AM JST
os.
* Sun 15 Sep 2013 05:24:21 AM JST
os.path.os.path.os.path.os
* Sun 15 Sep 2013 05:29:54 AM JST
path
* Sun 15 Sep 2013 05:29:55 AM JST
os.path
* Sun 15 Sep 2013 05:30:37 AM JST

* Sun 15 Sep 2013 05:30:37 AM JST

* Sun 15 Sep 2013 05:30:37 AM JST
(autoload 'ipython "python-mode" nil 'interactive)

* Sun 15 Sep 2013 05:31:18 AM JST
;;;; python-mode
;; (autoload 'python-mode "python-mode" "Python editing mode." t)
;; (eval-after-load 'python-mode        '(python-mode-predefine))


* Sun 15 Sep 2013 05:31:56 AM JST

* Sun 15 Sep 2013 05:31:56 AM JST

* Sun 15 Sep 2013 05:31:56 AM JST
  ;; (require 'python-mode "python-mode" 'noerror)

* Sun 15 Sep 2013 05:41:05 AM JST
similar 
* Sun 15 Sep 2013 05:50:57 AM JST

* Sun 15 Sep 2013 05:50:57 AM JST

* Sun 15 Sep 2013 05:50:57 AM JST
;; (defvar scratch-log-file (concat my-code-dir "/elisp/interpreter/scratch_log.org"))

* Sun 15 Sep 2013 05:51:05 AM JST
Symbol's value as variable is void: scratch-log-file
Enable global auto-complete.
Loading popup..
Loading auto-complete..
Loading auto-highlight-symbol..
Loading edit-server..
An edit-server process is already running
Loading midnight..
Loading tabbar..
Loading mcomplete..
After require mode on

* Sun 15 Sep 2013 05:52:16 AM JST

* Sun 15 Sep 2013 05:52:16 AM JST

* Sun 15 Sep 2013 05:52:16 AM JST
  ;; (let ((hs-show-hook hs-show-hook))

* Sun 15 Sep 2013 05:52:16 AM JST
  ;; (let ((hs-show-hook hs-show-hook))

* Sun 15 Sep 2013 05:52:17 AM JST
  ;; (let ((hs-show-hook hs-show-hook))
  ;;   (remove-hook 'hs-show-hook 'minimap-sync-overlays)

* Sun 15 Sep 2013 05:52:17 AM JST
  ;; (let ((hs-show-hook hs-show-hook))
  ;;   (remove-hook 'hs-show-hook 'minimap-sync-overlays)

* Sun 15 Sep 2013 05:52:17 AM JST
  ;; (let ((hs-show-hook hs-show-hook))
  ;;   (remove-hook 'hs-show-hook 'minimap-sync-overlays)
  ;;   (funcall initial-major-mode))

* Sun 15 Sep 2013 05:52:57 AM JST
`minimap-sync-overlays'
* Sun 15 Sep 2013 05:53:04 AM JST
`my-make-scratch'
* Sun 15 Sep 2013 05:55:07 AM JST

* Sun 15 Sep 2013 05:55:07 AM JST

* Sun 15 Sep 2013 05:55:07 AM JST
  ;; rotate `ac-sources'

* Sun 15 Sep 2013 05:55:37 AM JST
 on
* Sun 15 Sep 2013 05:57:55 AM JST
 on
* Sun 15 Sep 2013 05:58:20 AM JST
** TODO [#C] auto install script by python

    [[file:~/.emacs.d/allinone.org::*Stack:][Stack:]]

* Sun 15 Sep 2013 06:03:03 AM JST
** TODO [#C] __python__.el arhcitecture

1) 背景(問題点)
   make new my python.el

2) 対応方法
   create architecture

3) 優先順位の根拠
   need a lot of time

4) 備考
   if-statement-p
   while-statement-p
   class statement-p


5) 結果
6) time/ref
    / cf. [[file:~/.emacs.d/allinone.org::*Emacs:][Emacs:]]

* Sun 15 Sep 2013 06:04:05 AM JST
** TODO [#C] auto install script by python

    [[file:~/.emacs.d/allinone.org::*Stack:][Stack:]]

* Sun 15 Sep 2013 06:04:28 AM JST
** TODO [#B] make apropos.py

1) 背景(問題点)
   apropos command is nothing in python
   we have only "pydoc -k"
   not support color

2) 対応方法
   pydoc -k
   elisp apropos

3) 優先順位の根拠
   useable

4) 備考

5) 結果
6) time/ref
    / cf. [[file:~/.emacs.d/allinone.org::*Search%20Document][Search Document]]

* Sun 15 Sep 2013 06:58:29 AM JST
empty-line-p
* Sun 15 Sep 2013 06:59:04 AM JST
py-in-statement-p
* Sun 15 Sep 2013 06:59:53 AM JST
py-beginning-of-def-p
* Sun 15 Sep 2013 07:00:02 AM JST
py-beginning-of-class-p
* Sun 15 Sep 2013 07:00:09 AM JST
py-beginning-of-def-or-class-p
* Sun 15 Sep 2013 07:00:25 AM JST
py-end-of-line-p
py-end-of-buffer-p
py-end-of-paragraph-p
py-end-of-statement-p
py-end-of-expression-p
py-end-of-partial-expression-p
py-end-of-block-p
py-end-of-clause-p
py-end-of-block-or-clause-p
py-end-of-def-p
py-end-of-class-p

* Sun 15 Sep 2013 07:00:35 AM JST
py-statement-opens-block-p
py-statement-opens-base
py-statement-opens-clause-p
py-statement-opens-block-or-clause-p
py-statement-opens-class-p
py-statement-opens-def-p
py-statement-opens-def-or-class-p
py-statement-closes-block-p

* Sun 15 Sep 2013 07:01:05 AM JST
py-beginning-of-block-bol-p
* Sun 15 Sep 2013 07:01:15 AM JST
py-beginning-of-def-bol-p
* Sun 15 Sep 2013 07:01:27 AM JST
py-beginning-of-class-bol-p
* Sun 15 Sep 2013 07:04:53 AM JST
(defun imenu-example--create-lisp-index ()
  ;; Example of a candidate for `imenu-create-index-function'.
  ;; It will generate a nested index of definitions.
  (declare (obsolete nil "23.2"))
  (let ((index-alist '())
	(index-var-alist '())
	(index-type-alist '())
	(index-unknown-alist '()))
    (goto-char (point-max))
    ;; Search for the function
    (while (beginning-of-defun)
	  (save-match-data
	    (and (looking-at "(def")
		 (save-excursion
	       (down-list 1)
		   (cond
		((looking-at "def\\(var\\|const\\)")
		     (forward-sexp 2)
		     (push (imenu-example--name-and-position)
			   index-var-alist))
		((looking-at "def\\(un\\|subst\\|macro\\|advice\\)")
		     (forward-sexp 2)
		     (push (imenu-example--name-and-position)
			   index-alist))
		((looking-at "def\\(type\\|struct\\|class\\|ine-condition\\)")
		     (forward-sexp 2)
 		 (if (= (char-after (1- (point))) ?\))
			 (progn
 		       (forward-sexp -1)
			   (down-list 1)
 		       (forward-sexp 1)))
		     (push (imenu-example--name-and-position)
			   index-type-alist))
		    (t
		     (forward-sexp 2)
		     (push (imenu-example--name-and-position)
		       index-unknown-alist)))))))
    (and index-var-alist
	 (push (cons "Variables" index-var-alist)
	       index-alist))
    (and index-type-alist
 	 (push (cons "Types" index-type-alist)
  	       index-alist))
    (and index-unknown-alist
	 (push (cons "Syntax-unknown" index-unknown-alist)
	       index-alist))
    index-alist))
* Sun 15 Sep 2013 07:17:21 AM JST

* Sun 15 Sep 2013 07:17:21 AM JST

* Sun 15 Sep 2013 07:17:21 AM JST
ad-do-it

* Sun 15 Sep 2013 07:18:03 AM JST
(let ((index-alist '())
          (index-var-alist '())
          (index-type-alist '())
          (index-unknown-alist '()))
      (goto-char (point-max))
      ;; Search for the function
      (while (beginning-of-defun)
        (save-match-data
          (and (looking-at "(def")
               (save-excursion
                 (down-list 1)
                 (cond
                  ((looking-at "def\\(var\\|const\\)")
                   (forward-sexp 2)
                   (push (imenu-example--name-and-position)
                         index-var-alist))
                  ((looking-at "def\\(un\\|subst\\|macro\\|advice\\)")
                   (forward-sexp 2)
                   (push (imenu-example--name-and-position)
                         index-alist))
                  ((looking-at "def\\(type\\|struct\\|class\\|ine-condition\\)")
                   (forward-sexp 2)
                   (if (= (char-after (1- (point))) ?\))
                       (progn
                         (forward-sexp -1)
                         (down-list 1)
                         (forward-sexp 1)))
                   (push (imenu-example--name-and-position)
                         index-type-alist))
                  (t
                   (forward-sexp 2)
                   (push (imenu-example--name-and-position)
                         index-unknown-alist)))))))
      (and index-var-alist
           (push (cons "V" index-var-alist)
                 index-alist))
      (and index-type-alist
           (push (cons "T" index-type-alist)
                 index-alist))
      (and index-unknown-alist
           (push (cons "Syntax-unknown" index-unknown-alist)
                 index-alist))
      index-alist)
* Sun 15 Sep 2013 07:19:38 AM JST

* Sun 15 Sep 2013 07:19:38 AM JST

* Sun 15 Sep 2013 07:19:38 AM JST
(eval-after-load 'imenu '(imenu-mode-predefine))

* Sun 15 Sep 2013 07:22:37 AM JST
(concat "^" name "$")
* Sun 15 Sep 2013 07:25:02 AM JST
(defun e2wm:def-plugin-imenu-update-which-func ()
  (e2wm:with-advice
   (let* ((main-buf (e2wm:history-get-main-buffer))
          (win (selected-window))
          (imenu-buf (get-buffer " *WM:Imenu*"))
          (imenu-win (and imenu-buf (get-buffer-window imenu-buf))))
     (cond
      ((null imenu-buf)
       (e2wm:def-plugin-imenu-stop-timer))
      ((eql win (get-buffer-window main-buf))
       (let ((name (e2wm:def-plugin-imenu-which-func)))
         (when (and name (window-live-p imenu-win))
           (with-current-buffer imenu-buf
             (goto-char (point-min))
             (let ((ps (re-search-forward (concat "^" name "$"))))
               (when ps
                 (beginning-of-line)
                 (set-window-point imenu-win (point))
                 (hl-line-highlight)))))))
      (t
       ;;can not update
       )))))
* Sun 15 Sep 2013 07:25:51 AM JST
Error in timer: (search-failed "*Rescan*$")
* Sun 15 Sep 2013 07:26:55 AM JST
(concat "^" name "$")
* Sun 15 Sep 2013 07:29:28 AM JST
(defun e2wm:def-plugin-imenu-update-which-func ()
  (e2wm:with-advice
   (let* ((main-buf (e2wm:history-get-main-buffer))
          (win (selected-window))
          (imenu-buf (get-buffer " *WM:Imenu*"))
          (imenu-win (and imenu-buf (get-buffer-window imenu-buf))))
     (cond
      ((null imenu-buf)
       (e2wm:def-plugin-imenu-stop-timer))
      ((eql win (get-buffer-window main-buf))
       (let ((name (e2wm:def-plugin-imenu-which-func)))
         (when (and name (window-live-p imenu-win))
           (with-current-buffer imenu-buf
             (goto-char (point-min))
             (let ((ps (re-search-forward (concat "^" name))))
               (when ps
                 (beginning-of-line)
                 (set-window-point imenu-win (point))
                 (hl-line-highlight)))))))
      (t
       ;;can not update
       )))))
* Sun 15 Sep 2013 07:29:37 AM JST
fix-e2wm-predefine
* Sun 15 Sep 2013 07:40:12 AM JST
(rx-form form)
* Sun 15 Sep 2013 07:40:16 AM JST
form
* Sun 15 Sep 2013 07:40:29 AM JST
(rx-form "*Rescan*")
* Sun 15 Sep 2013 08:00:02 AM JST
(rx-form "*Rescan*")
* Sun 15 Sep 2013 08:00:56 AM JST
compress
* Sun 15 Sep 2013 08:08:48 AM JST

* Sun 15 Sep 2013 08:08:48 AM JST
   py:
* Sun 15 Sep 2013 08:08:48 AM JST
   py:empty-line-p

* Sun 15 Sep 2013 08:11:32 AM JST

* Sun 15 Sep 2013 08:11:33 AM JST
block
* Sun 15 Sep 2013 08:11:44 AM JST
   
* Sun 15 Sep 2013 08:11:46 AM JST
block
* Sun 15 Sep 2013 08:11:51 AM JST

* Sun 15 Sep 2013 08:11:51 AM JST
   py:in-while-lin
* Sun 15 Sep 2013 08:11:51 AM JST
   py:in-while-line-p

* Sun 15 Sep 2013 08:11:55 AM JST

* Sun 15 Sep 2013 08:11:55 AM JST

* Sun 15 Sep 2013 08:11:55 AM JST
   

* Sun 15 Sep 2013 02:06:34 PM JST
/emacs24/share/emacs/24.3.50/lisp/progmodes/python.el.gz
* Sun 15 Sep 2013 02:15:29 PM JST
args
* Sun 15 Sep 2013 02:15:43 PM JST

* Sun 15 Sep 2013 02:15:45 PM JST
func-
* Sun 15 Sep 2013 02:24:14 PM JST
python-nav-beginning-of-defun-regexp
* Sun 15 Sep 2013 03:02:23 PM JST
python-rx-constituents
* Sun 15 Sep 2013 03:31:20 PM JST
py-docstring-p
* Sun 15 Sep 2013 03:41:18 PM JST
(syntax-ppss)
* Sun 15 Sep 2013 03:51:16 PM JST
   
* Sun 15 Sep 2013 03:51:17 PM JST
paragraph
* Sun 15 Sep 2013 03:51:21 PM JST
   
* Sun 15 Sep 2013 03:51:22 PM JST
block
* Sun 15 Sep 2013 03:51:31 PM JST
   
* Sun 15 Sep 2013 03:51:32 PM JST
def
* Sun 15 Sep 2013 03:51:36 PM JST
   
* Sun 15 Sep 2013 03:51:42 PM JST
   
* Sun 15 Sep 2013 03:51:43 PM JST
def
* Sun 15 Sep 2013 03:51:43 PM JST
of-def
* Sun 15 Sep 2013 03:51:44 PM JST
class-of-def
* Sun 15 Sep 2013 03:53:42 PM JST

* Sun 15 Sep 2013 03:53:43 PM JST
down
* Sun 15 Sep 2013 03:53:57 PM JST
   
* Sun 15 Sep 2013 03:53:58 PM JST
up
* Sun 15 Sep 2013 03:54:04 PM JST

* Sun 15 Sep 2013 03:54:04 PM JST
up
* Sun 15 Sep 2013 04:03:37 PM JST
sys.exit(
* Sun 15 Sep 2013 10:48:54 PM JST
hello']
* Sun 15 Sep 2013 10:49:07 PM JST
world']
* Sun 15 Sep 2013 10:49:20 PM JST
foo
* Sun 15 Sep 2013 10:53:44 PM JST

* Sun 15 Sep 2013 10:53:45 PM JST

* Sun 15 Sep 2013 10:53:45 PM JST
        self.

* Mon 16 Sep 2013 12:41:50 AM JST
# 'module', 'class', 'function'
* Mon 16 Sep 2013 12:42:06 AM JST
'function',
* Mon 16 Sep 2013 01:01:41 AM JST
self._keyword
* Mon 16 Sep 2013 01:06:35 AM JST
self._keyword.get(key)
* Mon 16 Sep 2013 01:12:51 AM JST
class AproposDataHolder(object):
    r"""
    """

    def __init__(self, **keyword):
        r"""

        Arguments:
        - `keyword`:
        """
        self._keyword = keyword
        self.name = keyword.get('name', '')
        self.usepath = keyword.get('usepath', '')
        self.filepath = keyword.get('path', '')
        # 'module', 'class', 'method', 'function'
        self.type = keyword.get('type', '')
        self.summary = keyword.get('summary', '')
        self.detail = keyword.get('detail', '')
        self.source = keyword.get('source', '')

    def __repr__(self):
        r"""SUMMARY

        @Return:
        """
        concat = []
        for key in self._keyword:
            value = self._keyword.get(key)
            if 30 <= len(value):
                value = value[:30]
            concat.append('{0}={1}'.format(key, value))
        return ', '.join(concat)

* Mon 16 Sep 2013 01:14:40 AM JST

* Mon 16 Sep 2013 01:14:40 AM JST

* Mon 16 Sep 2013 01:14:40 AM JST
import sys as _sys

* Mon 16 Sep 2013 02:15:43 AM JST
import pydoc
* Mon 16 Sep 2013 02:17:33 AM JST
if modname:
* Mon 16 Sep 2013 02:20:40 AM JST
modname,
* Mon 16 Sep 2013 02:27:35 AM JST
__import__(modname).__doc__
* Mon 16 Sep 2013 02:27:39 AM JST
        
* Mon 16 Sep 2013 02:27:48 AM JST
__import__(modname).__doc__
* Mon 16 Sep 2013 02:29:19 AM JST
                          
* Mon 16 Sep 2013 02:31:42 AM JST
            
* Mon 16 Sep 2013 02:47:59 AM JST
collections.defaultdict()
* Mon 16 Sep 2013 02:55:16 AM JST
yahoo
* Mon 16 Sep 2013 03:00:30 AM JST
d = collections.defaultdict(lambda:collections.defaultdict(float))
* Mon 16 Sep 2013 03:04:04 AM JST
import collections
d = collections.defaultdict(lambda:collections.defaultdict(float))

のようにすれば

d['poko']['hoge'] += 1.0


* Mon 16 Sep 2013 03:04:11 AM JST

* Mon 16 Sep 2013 03:04:11 AM JST

* Mon 16 Sep 2013 03:04:11 AM JST
のようにすれば

* Mon 16 Sep 2013 03:04:11 AM JST
のようにすれば

* Mon 16 Sep 2013 03:04:12 AM JST
のようにすれば


* Mon 16 Sep 2013 03:04:12 AM JST

* Mon 16 Sep 2013 03:04:13 AM JST

* Mon 16 Sep 2013 03:04:13 AM JST


* Mon 16 Sep 2013 03:39:36 AM JST

* Mon 16 Sep 2013 03:39:36 AM JST

* Mon 16 Sep 2013 03:39:36 AM JST
    holder = []

* Mon 16 Sep 2013 03:39:39 AM JST
holder.append(
* Mon 16 Sep 2013 03:43:38 AM JST
source
* Mon 16 Sep 2013 03:44:27 AM JST
True
* Mon 16 Sep 2013 03:46:57 AM JST
_re.search(key, modname)
* Mon 16 Sep 2013 03:47:01 AM JST

* Mon 16 Sep 2013 03:47:01 AM JST

* Mon 16 Sep 2013 03:47:01 AM JST
            match = 

* Mon 16 Sep 2013 03:47:02 AM JST
            match = 

* Mon 16 Sep 2013 03:47:02 AM JST
            match = 
        if match:

* Mon 16 Sep 2013 11:33:32 AM JST
detail
* Mon 16 Sep 2013 11:33:35 AM JST
detail
* Mon 16 Sep 2013 11:36:03 AM JST
detail
* Mon 16 Sep 2013 11:39:27 AM JST
                              
* Mon 16 Sep 2013 11:40:48 AM JST
                              
* Mon 16 Sep 2013 11:46:27 AM JST
getdo
* Mon 16 Sep 2013 11:46:28 AM JST
inspect.getdo
* Mon 16 Sep 2013 11:47:14 AM JST
__import__(modname)
* Mon 16 Sep 2013 11:50:31 AM JST
(inspect.getdoc(obj) or '').split('\n')[0]
* Mon 16 Sep 2013 11:53:24 AM JST
summry and _re.search(key, (inspect.getdoc(obj) or '').split('\n')[0])
* Mon 16 Sep 2013 11:54:03 AM JST

* Mon 16 Sep 2013 11:54:03 AM JST

* Mon 16 Sep 2013 11:54:03 AM JST
        if :

* Mon 16 Sep 2013 11:56:05 AM JST
_inspect
* Mon 16 Sep 2013 11:56:05 AM JST
as _inspect
* Mon 16 Sep 2013 11:56:25 AM JST
_inspect.
* Mon 16 Sep 2013 11:56:28 AM JST
_inspect.
* Mon 16 Sep 2013 11:56:33 AM JST
_inspect.
* Mon 16 Sep 2013 11:56:38 AM JST
_inspect.
* Mon 16 Sep 2013 12:00:28 PM JST

* Mon 16 Sep 2013 12:00:28 PM JST

* Mon 16 Sep 2013 12:00:28 PM JST
    key = ''

* Mon 16 Sep 2013 12:00:36 PM JST
search
* Mon 16 Sep 2013 12:00:43 PM JST
search
* Mon 16 Sep 2013 12:00:48 PM JST
search
* Mon 16 Sep 2013 12:02:13 PM JST
                
* Mon 16 Sep 2013 12:02:36 PM JST

* Mon 16 Sep 2013 12:02:36 PM JST

* Mon 16 Sep 2013 12:02:36 PM JST
            continue

* Mon 16 Sep 2013 12:13:40 PM JST
inspect
* Mon 16 Sep 2013 12:14:01 PM JST
e
* Mon 16 Sep 2013 12:15:06 PM JST
        
* Mon 16 Sep 2013 12:15:07 PM JST
error'
* Mon 16 Sep 2013 12:15:07 PM JST
type error'
* Mon 16 Sep 2013 12:15:10 PM JST
pass
* Mon 16 Sep 2013 12:21:18 PM JST

* Mon 16 Sep 2013 12:21:18 PM JST

* Mon 16 Sep 2013 12:21:18 PM JST
        print('DEBUG-1-__init__.py')

* Mon 16 Sep 2013 12:47:09 PM JST
'aaa' + str(
* Mon 16 Sep 2013 12:47:28 PM JST
exists
* Mon 16 Sep 2013 12:59:41 PM JST
_sys.builtin_module_names
* Mon 16 Sep 2013 01:21:30 PM JST
builtin function
* Mon 16 Sep 2013 01:34:05 PM JST
return
* Mon 16 Sep 2013 01:34:32 PM JST
dir(__builtins__)
* Mon 16 Sep 2013 01:35:37 PM JST
            
* Mon 16 Sep 2013 01:43:15 PM JST
dir(
* Mon 16 Sep 2013 01:48:59 PM JST
print str()
* Mon 16 Sep 2013 01:49:14 PM JST
builtin
* Mon 16 Sep 2013 01:49:30 PM JST
not 
* Mon 16 Sep 2013 01:55:17 PM JST
    
* Mon 16 Sep 2013 02:01:17 PM JST
range
* Mon 16 Sep 2013 02:01:21 PM JST
calla
* Mon 16 Sep 2013 02:31:17 PM JST
docstring
* Mon 16 Sep 2013 02:31:23 PM JST
docstring
* Mon 16 Sep 2013 02:32:12 PM JST
                           
* Mon 16 Sep 2013 02:32:23 PM JST
full
* Mon 16 Sep 2013 02:32:46 PM JST
                           
* Mon 16 Sep 2013 02:32:48 PM JST
                           
* Mon 16 Sep 2013 02:33:06 PM JST

* Mon 16 Sep 2013 02:33:06 PM JST

* Mon 16 Sep 2013 02:33:06 PM JST


* Mon 16 Sep 2013 02:41:20 PM JST
        
* Mon 16 Sep 2013 02:41:50 PM JST
getdocsummary(builtin)
* Mon 16 Sep 2013 02:44:02 PM JST
or 
* Mon 16 Sep 2013 02:45:07 PM JST
search
* Mon 16 Sep 2013 02:51:51 PM JST
defaultdict(<type 'str'>, {'doc': 'interactive prompt objects for printing the license text, a list of\ncontributors and the copyright notice.', 'name': 'copyright', 'summary': 'interactive prompt objects for printing the license text, a list of'})
defaultdict(<type 'str'>, {'doc': 'interactive prompt objects for printing the license text, a list of\ncontributors and the copyright notice.', 'name': 'credits', 'summary': 'interactive prompt objects for printing the license text, a list of'})
defaultdict(<type 'str'>, {'doc': 'interactive prompt objects for printing the license text, a list of\ncontributors and the copyright notice.', 'name': 'license', 'summary': 'interactive prompt objects for printing the license text, a list of'})
defaultdict(<type 'str'>, {'doc': "print(value, ..., sep=' ', end='\\n', file=sys.stdout)\n\nPrints the values to a stream, or to sys.stdout by default.\nOptional keyword arguments:\nfile: a file-like object (stream); defaults to the current sys.stdout.\nsep:  string inserted between values, default a space.\nend:  string appended after the last value, default a newline.", 'name': 'print', 'summary': "print(value, ..., sep=' ', end='\\n', file=sys.stdout)"})

* Mon 16 Sep 2013 02:52:27 PM JST
                 
* Mon 16 Sep 2013 02:52:48 PM JST
                  
* Mon 16 Sep 2013 02:53:00 PM JST
'doc': 'interactive prompt objects for printing the license text, a list of\ncontributors and the copyright notice.',

* Mon 16 Sep 2013 02:53:06 PM JST
'doc': 'interactive prompt objects for printing the license text, a list of\ncontributors and the copyright notice.',

* Mon 16 Sep 2013 02:53:23 PM JST
                           
* Mon 16 Sep 2013 02:54:09 PM JST
defaultdict(<type 'str'>, {'doc': 'interactive prompt objects for printing the license text, a list of\ncontributors and the copyright notice.', 'type': '', 'name': 'copyright', 'summary': 'interactive prompt objects for printing the license text, a list of'})
defaultdict(<type 'str'>, {'doc': 'interactive prompt objects for printing the license text, a list of\ncontributors and the copyright notice.', 'type': '', 'name': 'credits', 'summary': 'interactive prompt objects for printing the license text, a list of'})
defaultdict(<type 'str'>, {'doc': 'interactive prompt objects for printing the license text, a list of\ncontributors and the copyright notice.', 'type': '', 'name': 'license', 'summary': 'interactive prompt objects for printing the license text, a list of'})
defaultdict(<type 'str'>, {'doc': "print(value, ..., sep=' ', end='\\n', file=sys.stdout)\n\nPrints the values to a stream, or to sys.stdout by default.\nOptional keyword arguments:\nfile: a file-like object (stream); defaults to the current sys.stdout.\nsep:  string inserted between values, default a space.\nend:  string appended after the last value, default a newline.", 'type': '', 'name': 'print', 'summary': "print(value, ..., sep=' ', end='\\n', file=sys.stdout)"})
* Mon 16 Sep 2013 02:54:30 PM JST
                  
* Mon 16 Sep 2013 02:54:46 PM JST
                  
* Mon 16 Sep 2013 02:55:09 PM JST
                  
* Mon 16 Sep 2013 02:55:23 PM JST

* Mon 16 Sep 2013 02:55:23 PM JST

* Mon 16 Sep 2013 02:55:23 PM JST
'doc': 'interactive prompt objects for printing the license text, a list of\ncontributors and the copyright notice.',

* Mon 16 Sep 2013 03:10:26 PM JST
                               
* Mon 16 Sep 2013 03:10:30 PM JST
                               
* Mon 16 Sep 2013 03:10:52 PM JST
def builtin_search(key, name=True, summry=True, fulldoc=False):
    r"""SUMMARY

    @Arguments:
    - `key`:
    - `name`:
    - `summry`:
    - `detail`:
    - `source`:

    @Return:
    """
    for modname in _sys.builtin_module_names:
        if modname == '__main__':
            continue
        obj = __import__(modname)
        # name match or summary match, docstring match
        if ((name and _re.search(key, modname)) or
            (summry and _re.search(key, getdocsummary(obj))) or
            (fulldoc and _re.search(key, _getdoc(obj)))):
            yield _defaultdict(str, name=modname, type=type(obj),
                               file='', definition='',
                               summary=getdocsummary(obj),
                               doc=_getdoc(obj))


* Mon 16 Sep 2013 03:11:09 PM JST
parse_builtin_search
* Mon 16 Sep 2013 03:18:57 PM JST

* Mon 16 Sep 2013 03:18:57 PM JST

* Mon 16 Sep 2013 03:18:57 PM JST
    if isclass(obj):

* Mon 16 Sep 2013 03:18:58 PM JST
    if isclass(obj):

* Mon 16 Sep 2013 03:18:58 PM JST
    if isclass(obj):
        pass

* Mon 16 Sep 2013 03:19:45 PM JST
getargspec as _getargspec
* Mon 16 Sep 2013 03:19:55 PM JST
isclass as _isclass, 
* Mon 16 Sep 2013 03:19:59 PM JST
                     
* Mon 16 Sep 2013 03:27:02 PM JST
os.path.exists()
* Mon 16 Sep 2013 05:30:57 PM JST
for bname, def __
* Mon 16 Sep 2013 05:31:12 PM JST
def __str__(self, other):

* Mon 16 Sep 2013 06:17:26 PM JST
def getbuiltins():
    r"""SUMMARY

    @Return:
    """
    for name, builtin in _getmembers(__builtins__):
        yield name, builtin

* Mon 16 Sep 2013 06:18:25 PM JST
for modname in _sys.builtin_module_names:
* Mon 16 Sep 2013 06:19:06 PM JST
    for modname in _sys.builtin_module_names:
        if modname == '__main__':
            continue
        obj = __import__(modname)

* Mon 16 Sep 2013 06:19:19 PM JST
obj = 
* Mon 16 Sep 2013 06:32:53 PM JST
pkgutil.walk_packages(onerror=lambda x: None)
* Mon 16 Sep 2013 10:17:47 PM JST

* Mon 16 Sep 2013 10:17:47 PM JST

* Mon 16 Sep 2013 10:17:47 PM JST
    smmry = 

* Mon 16 Sep 2013 10:19:56 PM JST
            
* Mon 16 Sep 2013 10:20:46 PM JST
                           
* Mon 16 Sep 2013 11:22:06 PM JST
sys.builtin_module_names
* Tue 17 Sep 2013 12:31:13 AM JST
def iterbuiltinsinfo(sammary=True, doc=True):
    r"""SUMMARY

    @Return:
    """
    for bname, builtin in getbuiltins():
        if sammary:
            smmry = getdocsummary(builtin)
        else:
            smmry = ''
        if doc:
            dc = _getdoc(builtin)
        else:
            doc = ''
        yield _defaultdict(str, name=bname, type=type(builtin),
                           summary=smmry, doc=dc)


* Tue 17 Sep 2013 12:31:44 AM JST
def iterbuiltinsinfo(sammary=True, doc=True):
    r"""SUMMARY

    @Return:
    """
    for bname, builtin in getbuiltins():
        if sammary:
            smmry = getdocsummary(builtin)
        else:
            smmry = ''
        if doc:
            dc = _getdoc(builtin)
        else:
            doc = ''
        yield _defaultdict(str, name=bname, type=type(builtin),
                           summary=smmry, doc=dc)



* Tue 17 Sep 2013 12:38:33 AM JST
type(
* Tue 17 Sep 2013 12:45:27 AM JST
_isfunctio
* Tue 17 Sep 2013 12:45:34 AM JST
_isfunction
* Tue 17 Sep 2013 12:52:48 AM JST
parent=''
* Tue 17 Sep 2013 12:56:50 AM JST

* Tue 17 Sep 2013 12:56:50 AM JST

* Tue 17 Sep 2013 12:56:50 AM JST
        if _ismodule() or _isclass(obj):

* Tue 17 Sep 2013 12:57:50 AM JST
obj
* Tue 17 Sep 2013 12:57:57 AM JST
obj=obj
* Tue 17 Sep 2013 01:04:57 AM JST
type
* Tue 17 Sep 2013 01:13:53 AM JST
                       
* Tue 17 Sep 2013 01:15:12 AM JST
        
* Tue 17 Sep 2013 01:22:50 AM JST
or hash_ in hashes
* Tue 17 Sep 2013 01:23:17 AM JST

* Tue 17 Sep 2013 01:23:17 AM JST

* Tue 17 Sep 2013 01:23:17 AM JST
            hashes.append(hash_)

* Tue 17 Sep 2013 01:31:11 AM JST
                               
* Tue 17 Sep 2013 01:41:57 AM JST
'.'.join(parent, modname)
* Tue 17 Sep 2013 01:42:26 AM JST
getdef(subobj, '.'.join(parent, modname))
* Tue 17 Sep 2013 01:42:51 AM JST

* Tue 17 Sep 2013 01:42:51 AM JST

* Tue 17 Sep 2013 01:42:51 AM JST
            if _ismethod(subobj) or _isfunction(subobj):

* Tue 17 Sep 2013 01:42:51 AM JST
            if _ismethod(subobj) or _isfunction(subobj):

* Tue 17 Sep 2013 01:42:51 AM JST
            if _ismethod(subobj) or _isfunction(subobj):
                defn = 

* Tue 17 Sep 2013 01:54:25 AM JST
            
* Tue 17 Sep 2013 01:54:55 AM JST
str(_inspect.getargspec(obj)).replace('ArgSpec', name, count=1)
* Tue 17 Sep 2013 02:01:35 AM JST
def getdef(obj, name):
    r"""SUMMARY

    @Arguments:
    - `obj`:
    - `name`:

    @Return:
    """
    if not callable(obj):
        return ''
    try:
        return str(_inspect.getargspec(obj)).replace('ArgSpec', name, count=1)
    except TypeError:
        return name + '()'


* Tue 17 Sep 2013 02:07:27 AM JST

* Tue 17 Sep 2013 02:07:27 AM JST

* Tue 17 Sep 2013 02:07:28 AM JST
        parent = 

* Tue 17 Sep 2013 02:08:06 AM JST
parsemodules(os, parent='')
* Tue 17 Sep 2013 02:11:27 AM JST
interface
* Tue 17 Sep 2013 02:18:47 AM JST

* Tue 17 Sep 2013 02:18:47 AM JST

* Tue 17 Sep 2013 02:18:48 AM JST
return (_inspect.getdoc(obj) or '').splitlines()[0]

* Tue 17 Sep 2013 02:18:54 AM JST
e
* Tue 17 Sep 2013 02:18:54 AM JST
Exception, e
* Tue 17 Sep 2013 02:19:02 AM JST
e
* Tue 17 Sep 2013 02:19:02 AM JST
pass e
* Tue 17 Sep 2013 02:19:54 AM JST

* Tue 17 Sep 2013 02:19:54 AM JST

* Tue 17 Sep 2013 02:19:54 AM JST
    try:

* Tue 17 Sep 2013 02:19:56 AM JST

* Tue 17 Sep 2013 02:19:56 AM JST

* Tue 17 Sep 2013 02:19:56 AM JST
    except IndexError:

* Tue 17 Sep 2013 02:19:56 AM JST
    except IndexError:

* Tue 17 Sep 2013 02:19:57 AM JST
    except IndexError:
        return ''

* Tue 17 Sep 2013 02:29:24 AM JST
        if hash_ in hashes:
            continue
        hashes.append(hash_)

* Tue 17 Sep 2013 02:40:46 AM JST
inspect.getargspec(obj)).replace('ArgSpec', name, count=1)
* Tue 17 Sep 2013 03:13:05 AM JST
parsemodules(subobj, parent='.'.join([parent, modname]))
* Tue 17 Sep 2013 03:16:16 AM JST

* Tue 17 Sep 2013 03:16:16 AM JST

* Tue 17 Sep 2013 03:16:16 AM JST
            print('DEBUG-1-__init__.py')

* Tue 17 Sep 2013 03:16:17 AM JST
            print('DEBUG-1-__init__.py')

* Tue 17 Sep 2013 03:16:17 AM JST
            print('DEBUG-1-__init__.py')
            print(modname)

* Tue 17 Sep 2013 01:20:21 PM JST
isin_curr_runlevel
* Tue 17 Sep 2013 01:51:00 PM JST
parsemodules
* Tue 17 Sep 2013 01:51:14 PM JST
get
* Tue 17 Sep 2013 01:51:34 PM JST
SUMMARY
* Tue 17 Sep 2013 01:58:53 PM JST
parsemodules
* Tue 17 Sep 2013 01:59:29 PM JST
yield 
* Tue 17 Sep 2013 01:59:42 PM JST
VAR
* Tue 17 Sep 2013 01:59:47 PM JST
walkmodinfo(obj=obj, parent=modname)
* Tue 17 Sep 2013 02:07:37 PM JST
    
* Tue 17 Sep 2013 02:16:48 PM JST
        
* Tue 17 Sep 2013 02:17:12 PM JST
                
* Tue 17 Sep 2013 02:23:00 PM JST

* Tue 17 Sep 2013 02:23:00 PM JST

* Tue 17 Sep 2013 02:23:00 PM JST
            if type(d[el]) != _types.StringTypes:

* Tue 17 Sep 2013 02:23:00 PM JST
            if type(d[el]) != _types.StringTypes:

* Tue 17 Sep 2013 02:23:00 PM JST
            if type(d[el]) != _types.StringTypes:
                print(d)

* Tue 17 Sep 2013 02:23:00 PM JST
            if type(d[el]) != _types.StringTypes:
                print(d)

* Tue 17 Sep 2013 02:23:00 PM JST
            if type(d[el]) != _types.StringTypes:
                print(d)
                print(el)

* Tue 17 Sep 2013 02:27:05 PM JST
continue
* Tue 17 Sep 2013 02:27:35 PM JST
d)
* Tue 17 Sep 2013 02:27:35 PM JST
print(d)
* Tue 17 Sep 2013 02:27:55 PM JST
elements = ['name', 'file', 'type', 'definition', 'object', 'summary']
* Tue 17 Sep 2013 03:28:35 PM JST
def walkmodinfo(obj, parent=''):
    r"""Generator for module info.

    @Arguments:
    - `parent`:

    @Return: collections.defaultdict include
    name, file, type, definition, object, summary, doc
    """
    if not parent and hasattr(obj, '__name__'):
        parent = obj.__name__
    try:
        file_ = _inspect.getfile(obj)
    except TypeError:
        file_ = ''

    yield _defaultdict(str,
                       name=parent,
                       file=file_,
                       type=type(obj),
                       definition=parent,
                       object=obj,
                       summary=(getdocsummary(obj) or ''),
                       doc=(_inspect.getdoc(obj) or ''))

    for modname, subobj in _inspect.getmembers(obj):
        if modname.startswith('_'):
            continue
        try:
            hash_ = hash(subobj)
            if hash_ in hashes:
                continue
            hashes.append(hash_)
        except TypeError:
            # unhashable type
            continue
        if _inspect.ismodule(subobj) or _inspect.isclass(subobj):
            for dic_ in parsemodules(subobj, parent='.'.join([parent, modname])):
                yield dic_
        else:
            try:
                file_2 = _inspect.getabsfile(subobj)
            except:
                file_2 = ''
            yield _defaultdict(str,
                               name=modname,
                               file=file_2,
                               type=type(subobj),
                               definition=getdef(subobj, '.'.join([parent, modname])),
                               object=subobj,
                               summary=(getdocsummary(subobj) or ''),
                               doc=(_inspect.getdoc(subobj) or ''))

* Tue 17 Sep 2013 03:31:43 PM JST
and 
* Tue 17 Sep 2013 03:31:43 PM JST
_unique and 
* Tue 17 Sep 2013 03:31:44 PM JST
self._unique and 
* Tue 17 Sep 2013 03:34:52 PM JST
parsemodules
* Tue 17 Sep 2013 03:35:30 PM JST
parsemodules
* Tue 17 Sep 2013 03:36:01 PM JST

* Tue 17 Sep 2013 03:36:01 PM JST

* Tue 17 Sep 2013 03:36:02 PM JST
        # recursively call

* Tue 17 Sep 2013 04:32:37 PM JST
    for modname, obj in getbuiltinmodules():
        for d in walkmodinfo(obj=obj, parent=modname):
            yield d

* Tue 17 Sep 2013 04:32:44 PM JST

* Tue 17 Sep 2013 04:32:44 PM JST

* Tue 17 Sep 2013 04:32:44 PM JST
        for VAR in COLLECTION:

* Tue 17 Sep 2013 04:32:57 PM JST
yield
* Tue 17 Sep 2013 04:38:23 PM JST
return
* Tue 17 Sep 2013 04:40:07 PM JST
        for modname, obj in getbuiltinmodules():
            for d in walkmodinfo(obj=obj, parent=modname):
                return d

* Tue 17 Sep 2013 04:41:03 PM JST
        for modname, obj in getbuiltinmodules():
            for d in self.walkmodinfo(obj=obj, parent=modname):
                return d
        raise StopIteration

* Tue 17 Sep 2013 04:41:12 PM JST

* Tue 17 Sep 2013 04:41:12 PM JST

* Tue 17 Sep 2013 04:41:12 PM JST
        raise StopIteration

* Tue 17 Sep 2013 04:46:46 PM JST
    def hashclear(self):
        r"""SUMMARY

        @Return:
        """
        self._hashes = []

    def walkmodinfo(self, obj, parent=''):
        r"""Generator for module info.

        @Arguments:
        - `parent`:

        @Return: collections.defaultdict include
        name, file, type, definition, object, summary, doc
        """
        if not parent and hasattr(obj, '__name__'):
            parent = obj.__name__
        try:
            file_ = _inspect.getfile(obj)
        except TypeError:
            file_ = ''

        yield _defaultdict(str,
                           name=parent,
                           file=file_,
                           type=type(obj),
                           definition=parent,
                           object=obj,
                           summary=(getdocsummary(obj) or ''),
                           doc=(_inspect.getdoc(obj) or ''))

        for modname, subobj in _inspect.getmembers(obj):
            if modname.startswith('_'):
                continue
            # check hash for unique
            if self._unique:
                try:
                    hash_ = hash(subobj)
                    if hash_ in self._hashes:
                        continue
                    self._hashes.append(hash_)
                except TypeError:
                    # unhashable type
                    continue
            if _inspect.ismodule(subobj) or _inspect.isclass(subobj):
                # recursively call
                for dic_ in self.walkmodinfo(subobj,
                                         parent='.'.join([parent, modname])):
                    yield dic_
            else:
                try:
                    file_2 = _inspect.getabsfile(subobj)
                except TypeError:
                    file_2 = ''
                yield _defaultdict(str,
                                   name=modname,
                                   file=file_2,
                                   type=type(subobj),
                                   definition=getdef(subobj, '.'.join([parent, modname])),
                                   object=subobj,
                                   summary=(getdocsummary(subobj) or ''),
                                   doc=(_inspect.getdoc(subobj) or ''))

* Tue 17 Sep 2013 04:48:24 PM JST
                                         
* Tue 17 Sep 2013 04:54:13 PM JST

* Tue 17 Sep 2013 04:54:13 PM JST

* Tue 17 Sep 2013 04:54:13 PM JST
        self._obj = obj

* Tue 17 Sep 2013 04:54:15 PM JST
obj, 
* Tue 17 Sep 2013 04:59:27 PM JST
not
* Tue 17 Sep 2013 05:10:11 PM JST
'.'.join([parent, modname])
* Tue 17 Sep 2013 05:10:18 PM JST
                                      
* Tue 17 Sep 2013 05:11:11 PM JST

* Tue 17 Sep 2013 05:11:11 PM JST

* Tue 17 Sep 2013 05:11:11 PM JST
            # sub members

* Tue 17 Sep 2013 05:37:30 PM JST
        for modname, obj in getbuiltinmodules():
            for d in self.walkmodinfo(obj=obj, parent=modname):
                return d

* Tue 17 Sep 2013 05:38:17 PM JST
d
* Tue 17 Sep 2013 05:38:18 PM JST
return d
* Tue 17 Sep 2013 05:59:07 PM JST
python_path="/usr/bin/python"

* Tue 17 Sep 2013 05:59:45 PM JST
[ -x $python_path ] || exit 0
* Tue 17 Sep 2013 06:04:23 PM JST

* Tue 17 Sep 2013 06:04:23 PM JST

* Tue 17 Sep 2013 06:04:23 PM JST
        self._walker =

* Tue 17 Sep 2013 06:06:34 PM JST
PackageInfo
* Tue 17 Sep 2013 06:06:40 PM JST
Package
* Tue 17 Sep 2013 06:08:39 PM JST
    for modname, obj in getbuiltinmodules():
        for d in self.walkmodinfo(obj=obj, parent=modname):
            yield

* Tue 17 Sep 2013 06:10:11 PM JST

* Tue 17 Sep 2013 06:10:11 PM JST

* Tue 17 Sep 2013 06:10:11 PM JST
        WalkModInfo.__init__(hashes=hashes, unique=unique)

* Tue 17 Sep 2013 10:53:03 PM JST
        for modname, obj in getbuiltinmodules():
            for d in self.walk(obj=obj, parent=modname):
                yield d

* Tue 17 Sep 2013 10:53:26 PM JST

* Tue 17 Sep 2013 10:53:26 PM JST

* Tue 17 Sep 2013 10:53:26 PM JST
        modname, obj = self._builtinmodules.next()

* Tue 17 Sep 2013 10:53:28 PM JST

* Tue 17 Sep 2013 10:53:28 PM JST

* Tue 17 Sep 2013 10:53:28 PM JST
        self._builtinmodules = getbuiltinmodules()

* Tue 17 Sep 2013 10:59:55 PM JST
mypsutil
* Tue 17 Sep 2013 11:00:32 PM JST
import 
* Tue 17 Sep 2013 11:02:59 PM JST
import cgitb
cgitb.enable(format='text')


* Tue 17 Sep 2013 11:03:04 PM JST

* Tue 17 Sep 2013 11:03:04 PM JST

* Tue 17 Sep 2013 11:03:04 PM JST
# for debug

* Tue 17 Sep 2013 11:10:52 PM JST
        if not os.path.exists('/data/archive'):
            raise StandardError('/data/archive not exists')
        with King(verbose=self._verbose) as ki:
            if not ki.ismount():
                raise ki.MountError('Data is not mounted.')

* Tue 17 Sep 2013 11:11:33 PM JST

* Tue 17 Sep 2013 11:11:33 PM JST

* Tue 17 Sep 2013 11:11:33 PM JST
from

* Tue 17 Sep 2013 11:13:32 PM JST
    with king.King(verbose=True) as ki:
        ki.script.pave()

* Tue 17 Sep 2013 11:13:38 PM JST
    with king.King(verbose=True) as ki:
        ki.script.pave()
        if not ki.isactive():
            logging.log(10, MSG.get('kidead'))
            sys.exit(MSG.get('kidead'))

* Tue 17 Sep 2013 11:14:11 PM JST

* Tue 17 Sep 2013 11:14:11 PM JST

* Tue 17 Sep 2013 11:14:11 PM JST
            logging.log(10, MSG.get('kidead'))

* Tue 17 Sep 2013 11:14:14 PM JST
get(
* Tue 17 Sep 2013 11:14:15 PM JST
MSG.get(
* Tue 17 Sep 2013 11:23:48 PM JST
os.path.splitext(os.path.realpath('/data/.backup/latest'))
* Tue 17 Sep 2013 11:24:06 PM JST
os.path.realpath('/data/.backup/latest')
* Tue 17 Sep 2013 11:24:46 PM JST
os.path.splitext(os.path.realpath('/data/.backup/king_remote/latest'))
* Tue 17 Sep 2013 11:25:22 PM JST
'/data/.backup/king_remote/latest'
* Tue 17 Sep 2013 11:26:12 PM JST
os.path.realpath(latest_path)
* Tue 17 Sep 2013 11:26:34 PM JST
os.path.realpath('/data/.backup/king_remote/latest')
* Tue 17 Sep 2013 11:30:15 PM JST
20130917
* Tue 17 Sep 2013 11:35:47 PM JST

* Tue 17 Sep 2013 11:35:47 PM JST

* Tue 17 Sep 2013 11:35:47 PM JST
BlindElephant==1.0

* Tue 17 Sep 2013 11:37:15 PM JST

* Tue 17 Sep 2013 11:37:15 PM JST

* Tue 17 Sep 2013 11:37:15 PM JST
GeoIP-Python==1.2.4

* Tue 17 Sep 2013 11:37:38 PM JST

* Tue 17 Sep 2013 11:37:38 PM JST

* Tue 17 Sep 2013 11:37:38 PM JST
GnuPGInterface==0.3.2

* Tue 17 Sep 2013 11:38:13 PM JST

* Tue 17 Sep 2013 11:38:13 PM JST

* Tue 17 Sep 2013 11:38:13 PM JST
Impacket==1.0.0.0-dev

* Tue 17 Sep 2013 11:38:47 PM JST

* Tue 17 Sep 2013 11:38:47 PM JST

* Tue 17 Sep 2013 11:38:47 PM JST
Magic-file-extensions==0.2

* Tue 17 Sep 2013 11:39:14 PM JST

* Tue 17 Sep 2013 11:39:14 PM JST

* Tue 17 Sep 2013 11:39:14 PM JST
MySQL-python==1.2.3

* Tue 17 Sep 2013 11:39:39 PM JST

* Tue 17 Sep 2013 11:39:39 PM JST

* Tue 17 Sep 2013 11:39:39 PM JST
NfSpy==1.0

* Tue 17 Sep 2013 11:40:05 PM JST

* Tue 17 Sep 2013 11:40:05 PM JST

* Tue 17 Sep 2013 11:40:05 PM JST
PAM==0.4.2

* Tue 17 Sep 2013 11:40:05 PM JST
PAM==0.4.2

* Tue 17 Sep 2013 11:40:05 PM JST
PAM==0.4.2
PIL==1.1.7

* Tue 17 Sep 2013 11:40:05 PM JST
PAM==0.4.2
PIL==1.1.7

* Tue 17 Sep 2013 11:40:05 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18

* Tue 17 Sep 2013 11:40:07 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18

* Tue 17 Sep 2013 11:40:07 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1

* Tue 17 Sep 2013 11:40:07 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1

* Tue 17 Sep 2013 11:40:08 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5

* Tue 17 Sep 2013 11:40:08 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5

* Tue 17 Sep 2013 11:40:08 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23

* Tue 17 Sep 2013 11:40:09 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23

* Tue 17 Sep 2013 11:40:09 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6

* Tue 17 Sep 2013 11:40:10 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6

* Tue 17 Sep 2013 11:40:10 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0

* Tue 17 Sep 2013 11:40:11 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0

* Tue 17 Sep 2013 11:40:11 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8

* Tue 17 Sep 2013 11:40:11 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8

* Tue 17 Sep 2013 11:40:11 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3

* Tue 17 Sep 2013 11:40:13 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3

* Tue 17 Sep 2013 11:40:13 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0

* Tue 17 Sep 2013 11:40:13 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0

* Tue 17 Sep 2013 11:40:13 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0

* Tue 17 Sep 2013 11:40:13 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0

* Tue 17 Sep 2013 11:40:13 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0
Twisted-Core==12.0.0

* Tue 17 Sep 2013 11:40:13 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0
Twisted-Core==12.0.0

* Tue 17 Sep 2013 11:40:13 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0
Twisted-Core==12.0.0
Twisted-Lore==12.0.0

* Tue 17 Sep 2013 11:40:13 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0
Twisted-Core==12.0.0
Twisted-Lore==12.0.0

* Tue 17 Sep 2013 11:40:13 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0
Twisted-Core==12.0.0
Twisted-Lore==12.0.0
Twisted-Mail==12.0.0

* Tue 17 Sep 2013 11:40:14 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0
Twisted-Core==12.0.0
Twisted-Lore==12.0.0
Twisted-Mail==12.0.0

* Tue 17 Sep 2013 11:40:14 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0
Twisted-Core==12.0.0
Twisted-Lore==12.0.0
Twisted-Mail==12.0.0
Twisted-Names==12.0.0

* Tue 17 Sep 2013 11:40:14 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0
Twisted-Core==12.0.0
Twisted-Lore==12.0.0
Twisted-Mail==12.0.0
Twisted-Names==12.0.0

* Tue 17 Sep 2013 11:40:14 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0
Twisted-Core==12.0.0
Twisted-Lore==12.0.0
Twisted-Mail==12.0.0
Twisted-Names==12.0.0
Twisted-News==12.0.0

* Tue 17 Sep 2013 11:40:14 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0
Twisted-Core==12.0.0
Twisted-Lore==12.0.0
Twisted-Mail==12.0.0
Twisted-Names==12.0.0
Twisted-News==12.0.0

* Tue 17 Sep 2013 11:40:14 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0
Twisted-Core==12.0.0
Twisted-Lore==12.0.0
Twisted-Mail==12.0.0
Twisted-Names==12.0.0
Twisted-News==12.0.0
Twisted-Runner==12.0.0

* Tue 17 Sep 2013 11:40:14 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0
Twisted-Core==12.0.0
Twisted-Lore==12.0.0
Twisted-Mail==12.0.0
Twisted-Names==12.0.0
Twisted-News==12.0.0
Twisted-Runner==12.0.0

* Tue 17 Sep 2013 11:40:14 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0
Twisted-Core==12.0.0
Twisted-Lore==12.0.0
Twisted-Mail==12.0.0
Twisted-Names==12.0.0
Twisted-News==12.0.0
Twisted-Runner==12.0.0
Twisted-Web==12.0.0

* Tue 17 Sep 2013 11:40:15 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0
Twisted-Core==12.0.0
Twisted-Lore==12.0.0
Twisted-Mail==12.0.0
Twisted-Names==12.0.0
Twisted-News==12.0.0
Twisted-Runner==12.0.0
Twisted-Web==12.0.0

* Tue 17 Sep 2013 11:40:15 PM JST
PAM==0.4.2
PIL==1.1.7
PyBluez==0.18
PyX==0.11.1
Pygments==1.5
Pymacs==0.23
PythonScriptTranslator==0.6
SOAPpy==0.12.0
SQLAlchemy==0.7.8
SimpleCV==1.3
Twisted==12.0.0
Twisted-Conch==12.0.0
Twisted-Core==12.0.0
Twisted-Lore==12.0.0
Twisted-Mail==12.0.0
Twisted-Names==12.0.0
Twisted-News==12.0.0
Twisted-Runner==12.0.0
Twisted-Web==12.0.0
Twisted-Words==12.0.0

* Tue 17 Sep 2013 11:40:17 PM JST

* Tue 17 Sep 2013 11:40:17 PM JST

* Tue 17 Sep 2013 11:40:17 PM JST
## FIXME: could not find svn URL in dependency_links for this package:

* Tue 17 Sep 2013 11:40:19 PM JST
## FIXME: could not find svn URL in dependency_links for this package:

* Tue 17 Sep 2013 11:40:19 PM JST
## FIXME: could not find svn URL in dependency_links for this package:
apsw==3.7.6.3-r1

* Tue 17 Sep 2013 11:40:22 PM JST

* Tue 17 Sep 2013 11:40:22 PM JST

* Tue 17 Sep 2013 11:40:22 PM JST
astroid==1.0.0

* Tue 17 Sep 2013 11:40:22 PM JST
astroid==1.0.0

* Tue 17 Sep 2013 11:40:22 PM JST
astroid==1.0.0
binwalk==1.2

* Tue 17 Sep 2013 11:40:31 PM JST

* Tue 17 Sep 2013 11:40:32 PM JST

* Tue 17 Sep 2013 11:40:32 PM JST
chardet==2.0.1

* Tue 17 Sep 2013 11:40:39 PM JST

* Tue 17 Sep 2013 11:40:39 PM JST

* Tue 17 Sep 2013 11:40:39 PM JST
ctypeslib==0.5.6

* Tue 17 Sep 2013 11:40:45 PM JST

* Tue 17 Sep 2013 11:40:45 PM JST

* Tue 17 Sep 2013 11:40:45 PM JST
## FIXME: could not find svn URL in dependency_links for this package:

* Tue 17 Sep 2013 11:40:45 PM JST
## FIXME: could not find svn URL in dependency_links for this package:

* Tue 17 Sep 2013 11:40:45 PM JST
## FIXME: could not find svn URL in dependency_links for this package:
distribute==0.6.24dev-r0

* Tue 17 Sep 2013 11:40:46 PM JST

* Tue 17 Sep 2013 11:40:46 PM JST

* Tue 17 Sep 2013 11:40:46 PM JST
defer==1.0.6

* Tue 17 Sep 2013 11:40:58 PM JST

* Tue 17 Sep 2013 11:40:58 PM JST

* Tue 17 Sep 2013 11:40:58 PM JST
easygui==0.96

* Tue 17 Sep 2013 11:41:09 PM JST
easygui==0.96

* Tue 17 Sep 2013 11:41:09 PM JST
easygui==0.96
epc==0.0.5

* Tue 17 Sep 2013 11:41:15 PM JST

* Tue 17 Sep 2013 11:41:15 PM JST

* Tue 17 Sep 2013 11:41:15 PM JST
evdev==0.4.1

* Tue 17 Sep 2013 11:41:18 PM JST
evdev==0.4.1

* Tue 17 Sep 2013 11:41:18 PM JST
evdev==0.4.1
flickrapi==1.2

* Tue 17 Sep 2013 11:41:19 PM JST
evdev==0.4.1
flickrapi==1.2

* Tue 17 Sep 2013 11:41:19 PM JST
evdev==0.4.1
flickrapi==1.2
fpconst==0.7.2

* Tue 17 Sep 2013 11:41:21 PM JST
evdev==0.4.1
flickrapi==1.2
fpconst==0.7.2

* Tue 17 Sep 2013 11:41:21 PM JST
evdev==0.4.1
flickrapi==1.2
fpconst==0.7.2
funkload==1.13.0

* Tue 17 Sep 2013 11:41:21 PM JST
evdev==0.4.1
flickrapi==1.2
fpconst==0.7.2
funkload==1.13.0

* Tue 17 Sep 2013 11:41:21 PM JST
evdev==0.4.1
flickrapi==1.2
fpconst==0.7.2
funkload==1.13.0
fuse-python==0.2.1

* Tue 17 Sep 2013 11:41:24 PM JST
evdev==0.4.1
flickrapi==1.2
fpconst==0.7.2
funkload==1.13.0
fuse-python==0.2.1

* Tue 17 Sep 2013 11:41:24 PM JST
evdev==0.4.1
flickrapi==1.2
fpconst==0.7.2
funkload==1.13.0
fuse-python==0.2.1
gevent==0.13.6

* Tue 17 Sep 2013 11:41:27 PM JST
evdev==0.4.1
flickrapi==1.2
fpconst==0.7.2
funkload==1.13.0
fuse-python==0.2.1
gevent==0.13.6

* Tue 17 Sep 2013 11:41:27 PM JST
evdev==0.4.1
flickrapi==1.2
fpconst==0.7.2
funkload==1.13.0
fuse-python==0.2.1
gevent==0.13.6
google==1.04

* Tue 17 Sep 2013 11:41:29 PM JST
evdev==0.4.1
flickrapi==1.2
fpconst==0.7.2
funkload==1.13.0
fuse-python==0.2.1
gevent==0.13.6
google==1.04

* Tue 17 Sep 2013 11:41:29 PM JST
evdev==0.4.1
flickrapi==1.2
fpconst==0.7.2
funkload==1.13.0
fuse-python==0.2.1
gevent==0.13.6
google==1.04
greenlet==0.3.1

* Tue 17 Sep 2013 11:41:30 PM JST
evdev==0.4.1
flickrapi==1.2
fpconst==0.7.2
funkload==1.13.0
fuse-python==0.2.1
gevent==0.13.6
google==1.04
greenlet==0.3.1

* Tue 17 Sep 2013 11:41:30 PM JST
evdev==0.4.1
flickrapi==1.2
fpconst==0.7.2
funkload==1.13.0
fuse-python==0.2.1
gevent==0.13.6
google==1.04
greenlet==0.3.1
httplib2==0.7.4

* Tue 17 Sep 2013 11:41:32 PM JST
evdev==0.4.1
flickrapi==1.2
fpconst==0.7.2
funkload==1.13.0
fuse-python==0.2.1
gevent==0.13.6
google==1.04
greenlet==0.3.1
httplib2==0.7.4

* Tue 17 Sep 2013 11:41:33 PM JST
evdev==0.4.1
flickrapi==1.2
fpconst==0.7.2
funkload==1.13.0
fuse-python==0.2.1
gevent==0.13.6
google==1.04
greenlet==0.3.1
httplib2==0.7.4
iotop==0.4.4

* Tue 17 Sep 2013 11:41:34 PM JST

* Tue 17 Sep 2013 11:41:34 PM JST

* Tue 17 Sep 2013 11:41:34 PM JST
jedi==0.7.0

* Tue 17 Sep 2013 11:41:34 PM JST
jedi==0.7.0

* Tue 17 Sep 2013 11:41:34 PM JST
jedi==0.7.0
jediepcserver==0.0.0

* Tue 17 Sep 2013 11:41:36 PM JST
jedi==0.7.0
jediepcserver==0.0.0

* Tue 17 Sep 2013 11:41:36 PM JST
jedi==0.7.0
jediepcserver==0.0.0
jsonpickle==0.4.0

* Tue 17 Sep 2013 11:41:39 PM JST
jedi==0.7.0
jediepcserver==0.0.0
jsonpickle==0.4.0

* Tue 17 Sep 2013 11:41:39 PM JST
jedi==0.7.0
jediepcserver==0.0.0
jsonpickle==0.4.0
keepnote==0.7.8

* Tue 17 Sep 2013 11:41:43 PM JST
jedi==0.7.0
jediepcserver==0.0.0
jsonpickle==0.4.0
keepnote==0.7.8

* Tue 17 Sep 2013 11:41:43 PM JST
jedi==0.7.0
jediepcserver==0.0.0
jsonpickle==0.4.0
keepnote==0.7.8
killerbee==1.0

* Tue 17 Sep 2013 11:41:43 PM JST
jedi==0.7.0
jediepcserver==0.0.0
jsonpickle==0.4.0
keepnote==0.7.8
killerbee==1.0

* Tue 17 Sep 2013 11:41:43 PM JST
jedi==0.7.0
jediepcserver==0.0.0
jsonpickle==0.4.0
keepnote==0.7.8
killerbee==1.0
lazr.restfulclient==0.12.0

* Tue 17 Sep 2013 11:41:44 PM JST
jedi==0.7.0
jediepcserver==0.0.0
jsonpickle==0.4.0
keepnote==0.7.8
killerbee==1.0
lazr.restfulclient==0.12.0

* Tue 17 Sep 2013 11:41:44 PM JST
jedi==0.7.0
jediepcserver==0.0.0
jsonpickle==0.4.0
keepnote==0.7.8
killerbee==1.0
lazr.restfulclient==0.12.0
lazr.uri==1.0.3

* Tue 17 Sep 2013 11:41:47 PM JST
jedi==0.7.0
jediepcserver==0.0.0
jsonpickle==0.4.0
keepnote==0.7.8
killerbee==1.0
lazr.restfulclient==0.12.0
lazr.uri==1.0.3

* Tue 17 Sep 2013 11:41:47 PM JST
jedi==0.7.0
jediepcserver==0.0.0
jsonpickle==0.4.0
keepnote==0.7.8
killerbee==1.0
lazr.restfulclient==0.12.0
lazr.uri==1.0.3
lightblue==0.3.2

* Tue 17 Sep 2013 11:41:49 PM JST
jedi==0.7.0
jediepcserver==0.0.0
jsonpickle==0.4.0
keepnote==0.7.8
killerbee==1.0
lazr.restfulclient==0.12.0
lazr.uri==1.0.3
lightblue==0.3.2

* Tue 17 Sep 2013 11:41:49 PM JST
jedi==0.7.0
jediepcserver==0.0.0
jsonpickle==0.4.0
keepnote==0.7.8
killerbee==1.0
lazr.restfulclient==0.12.0
lazr.uri==1.0.3
lightblue==0.3.2
logilab-astng==0.24.2

* Tue 17 Sep 2013 11:41:50 PM JST
jedi==0.7.0
jediepcserver==0.0.0
jsonpickle==0.4.0
keepnote==0.7.8
killerbee==1.0
lazr.restfulclient==0.12.0
lazr.uri==1.0.3
lightblue==0.3.2
logilab-astng==0.24.2

* Tue 17 Sep 2013 11:41:50 PM JST
jedi==0.7.0
jediepcserver==0.0.0
jsonpickle==0.4.0
keepnote==0.7.8
killerbee==1.0
lazr.restfulclient==0.12.0
lazr.uri==1.0.3
lightblue==0.3.2
logilab-astng==0.24.2
logilab-common==0.60.0

* Tue 17 Sep 2013 11:41:57 PM JST

* Tue 17 Sep 2013 11:41:57 PM JST

* Tue 17 Sep 2013 11:41:57 PM JST
matplotlib==1.1.1rc2

* Tue 17 Sep 2013 11:42:00 PM JST
matplotlib==1.1.1rc2

* Tue 17 Sep 2013 11:42:00 PM JST
matplotlib==1.1.1rc2
mitmproxy==0.8

* Tue 17 Sep 2013 11:42:04 PM JST

* Tue 17 Sep 2013 11:42:04 PM JST

* Tue 17 Sep 2013 11:42:04 PM JST
netaddr==0.7.7

* Tue 17 Sep 2013 11:42:06 PM JST

* Tue 17 Sep 2013 11:42:06 PM JST

* Tue 17 Sep 2013 11:42:06 PM JST
numpy==1.6.2

* Tue 17 Sep 2013 11:42:06 PM JST
numpy==1.6.2

* Tue 17 Sep 2013 11:42:06 PM JST
numpy==1.6.2
oauth==1.0.1

* Tue 17 Sep 2013 11:42:07 PM JST
numpy==1.6.2
oauth==1.0.1

* Tue 17 Sep 2013 11:42:07 PM JST
numpy==1.6.2
oauth==1.0.1
oauthlib==0.1.2

* Tue 17 Sep 2013 11:42:11 PM JST

* Tue 17 Sep 2013 11:42:12 PM JST

* Tue 17 Sep 2013 11:42:12 PM JST
pcapy==0.10.8

* Tue 17 Sep 2013 11:42:14 PM JST

* Tue 17 Sep 2013 11:42:14 PM JST

* Tue 17 Sep 2013 11:42:14 PM JST
psycopg2==2.4.5

* Tue 17 Sep 2013 11:42:14 PM JST
psycopg2==2.4.5

* Tue 17 Sep 2013 11:42:15 PM JST
psycopg2==2.4.5
pyOpenSSL==0.13

* Tue 17 Sep 2013 11:42:20 PM JST

* Tue 17 Sep 2013 11:42:20 PM JST

* Tue 17 Sep 2013 11:42:20 PM JST
pyasn1==0.1.3

* Tue 17 Sep 2013 11:42:20 PM JST
pyasn1==0.1.3

* Tue 17 Sep 2013 11:42:20 PM JST
pyasn1==0.1.3
pycrypto==2.6

* Tue 17 Sep 2013 11:42:21 PM JST
pyasn1==0.1.3
pycrypto==2.6

* Tue 17 Sep 2013 11:42:21 PM JST
pyasn1==0.1.3
pycrypto==2.6
pycryptopp==0.5.29

* Tue 17 Sep 2013 11:42:22 PM JST
pyasn1==0.1.3
pycrypto==2.6
pycryptopp==0.5.29

* Tue 17 Sep 2013 11:42:22 PM JST
pyasn1==0.1.3
pycrypto==2.6
pycryptopp==0.5.29
pycurl==7.19.0

* Tue 17 Sep 2013 11:42:23 PM JST
pyasn1==0.1.3
pycrypto==2.6
pycryptopp==0.5.29
pycurl==7.19.0

* Tue 17 Sep 2013 11:42:23 PM JST
pyasn1==0.1.3
pycrypto==2.6
pycryptopp==0.5.29
pycurl==7.19.0
pydns==2.3.6

* Tue 17 Sep 2013 11:42:25 PM JST
pyasn1==0.1.3
pycrypto==2.6
pycryptopp==0.5.29
pycurl==7.19.0
pydns==2.3.6

* Tue 17 Sep 2013 11:42:25 PM JST
pyasn1==0.1.3
pycrypto==2.6
pycryptopp==0.5.29
pycurl==7.19.0
pydns==2.3.6
pyflakes==0.5.0

* Tue 17 Sep 2013 11:42:31 PM JST

* Tue 17 Sep 2013 11:42:31 PM JST

* Tue 17 Sep 2013 11:42:31 PM JST
pygame==1.9.1release

* Tue 17 Sep 2013 11:42:41 PM JST

* Tue 17 Sep 2013 11:42:41 PM JST

* Tue 17 Sep 2013 11:42:41 PM JST
pymssql==1.0.2

* Tue 17 Sep 2013 11:42:43 PM JST
pymssql==1.0.2

* Tue 17 Sep 2013 11:42:43 PM JST
pymssql==1.0.2
pyparsing==1.5.6

* Tue 17 Sep 2013 11:42:49 PM JST

* Tue 17 Sep 2013 11:42:49 PM JST

* Tue 17 Sep 2013 11:42:49 PM JST
pyscard==1.6.14

* Tue 17 Sep 2013 11:42:49 PM JST
pyscard==1.6.14

* Tue 17 Sep 2013 11:42:49 PM JST
pyscard==1.6.14
pyscreenshot==0.3.2

* Tue 17 Sep 2013 11:42:49 PM JST
pyscard==1.6.14
pyscreenshot==0.3.2

* Tue 17 Sep 2013 11:42:49 PM JST
pyscard==1.6.14
pyscreenshot==0.3.2
pyserial==2.5

* Tue 17 Sep 2013 11:42:50 PM JST
pyscard==1.6.14
pyscreenshot==0.3.2
pyserial==2.5

* Tue 17 Sep 2013 11:42:50 PM JST
pyscard==1.6.14
pyscreenshot==0.3.2
pyserial==2.5
pysnmp==4.2.2

* Tue 17 Sep 2013 11:42:50 PM JST
pyscard==1.6.14
pyscreenshot==0.3.2
pyserial==2.5
pysnmp==4.2.2

* Tue 17 Sep 2013 11:42:50 PM JST
pyscard==1.6.14
pyscreenshot==0.3.2
pyserial==2.5
pysnmp==4.2.2
pysnmp-apps==0.3.2

* Tue 17 Sep 2013 11:42:50 PM JST
pyscard==1.6.14
pyscreenshot==0.3.2
pyserial==2.5
pysnmp==4.2.2
pysnmp-apps==0.3.2

* Tue 17 Sep 2013 11:42:50 PM JST
pyscard==1.6.14
pyscreenshot==0.3.2
pyserial==2.5
pysnmp==4.2.2
pysnmp-apps==0.3.2
pysnmp-mibs==0.1.3

* Tue 17 Sep 2013 11:42:51 PM JST
pyscard==1.6.14
pyscreenshot==0.3.2
pyserial==2.5
pysnmp==4.2.2
pysnmp-apps==0.3.2
pysnmp-mibs==0.1.3

* Tue 17 Sep 2013 11:42:51 PM JST
pyscard==1.6.14
pyscreenshot==0.3.2
pyserial==2.5
pysnmp==4.2.2
pysnmp-apps==0.3.2
pysnmp-mibs==0.1.3
pysqlite==2.6.3

* Tue 17 Sep 2013 11:43:00 PM JST

* Tue 17 Sep 2013 11:43:00 PM JST

* Tue 17 Sep 2013 11:43:00 PM JST
python-xlib==0.14

* Tue 17 Sep 2013 11:43:02 PM JST
python-xlib==0.14

* Tue 17 Sep 2013 11:43:03 PM JST
python-xlib==0.14
pytidylib==0.2.1

* Tue 17 Sep 2013 11:43:03 PM JST
python-xlib==0.14
pytidylib==0.2.1

* Tue 17 Sep 2013 11:43:04 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c

* Tue 17 Sep 2013 11:43:04 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c

* Tue 17 Sep 2013 11:43:05 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3

* Tue 17 Sep 2013 11:43:05 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3

* Tue 17 Sep 2013 11:43:05 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19

* Tue 17 Sep 2013 11:43:06 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19

* Tue 17 Sep 2013 11:43:07 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1

* Tue 17 Sep 2013 11:43:07 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1

* Tue 17 Sep 2013 11:43:07 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4

* Tue 17 Sep 2013 11:43:07 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4

* Tue 17 Sep 2013 11:43:07 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1

* Tue 17 Sep 2013 11:43:08 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1

* Tue 17 Sep 2013 11:43:08 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0

* Tue 17 Sep 2013 11:43:08 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0

* Tue 17 Sep 2013 11:43:09 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2

* Tue 17 Sep 2013 11:43:09 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2

* Tue 17 Sep 2013 11:43:09 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2

* Tue 17 Sep 2013 11:43:10 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2

* Tue 17 Sep 2013 11:43:10 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2
scapy==2.2.0

* Tue 17 Sep 2013 11:43:10 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2
scapy==2.2.0

* Tue 17 Sep 2013 11:43:10 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2
scapy==2.2.0
sexpdata==0.0.3

* Tue 17 Sep 2013 11:43:11 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2
scapy==2.2.0
sexpdata==0.0.3

* Tue 17 Sep 2013 11:43:11 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2
scapy==2.2.0
sexpdata==0.0.3
simplegeneric==0.8.1

* Tue 17 Sep 2013 11:43:12 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2
scapy==2.2.0
sexpdata==0.0.3
simplegeneric==0.8.1

* Tue 17 Sep 2013 11:43:12 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2
scapy==2.2.0
sexpdata==0.0.3
simplegeneric==0.8.1
simplejson==2.5.2

* Tue 17 Sep 2013 11:43:13 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2
scapy==2.2.0
sexpdata==0.0.3
simplegeneric==0.8.1
simplejson==2.5.2

* Tue 17 Sep 2013 11:43:13 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2
scapy==2.2.0
sexpdata==0.0.3
simplegeneric==0.8.1
simplejson==2.5.2
six==1.1.0

* Tue 17 Sep 2013 11:43:13 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2
scapy==2.2.0
sexpdata==0.0.3
simplegeneric==0.8.1
simplejson==2.5.2
six==1.1.0

* Tue 17 Sep 2013 11:43:13 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2
scapy==2.2.0
sexpdata==0.0.3
simplegeneric==0.8.1
simplejson==2.5.2
six==1.1.0
stevedore==0.8

* Tue 17 Sep 2013 11:43:14 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2
scapy==2.2.0
sexpdata==0.0.3
simplegeneric==0.8.1
simplejson==2.5.2
six==1.1.0
stevedore==0.8

* Tue 17 Sep 2013 11:43:14 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2
scapy==2.2.0
sexpdata==0.0.3
simplegeneric==0.8.1
simplejson==2.5.2
six==1.1.0
stevedore==0.8
tweepy==1.7.1

* Tue 17 Sep 2013 11:43:15 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2
scapy==2.2.0
sexpdata==0.0.3
simplegeneric==0.8.1
simplejson==2.5.2
six==1.1.0
stevedore==0.8
tweepy==1.7.1

* Tue 17 Sep 2013 11:43:15 PM JST
python-xlib==0.14
pytidylib==0.2.1
pytz==2012c
pyusb==1.0.0a3
pyxdg==0.19
rednose==0.4.1
reportbug==6.4.4
requests==0.12.1
rfidiot==1.0
rope==0.9.2
ropemacs==0.6c2
scapy==2.2.0
sexpdata==0.0.3
simplegeneric==0.8.1
simplejson==2.5.2
six==1.1.0
stevedore==0.8
tweepy==1.7.1
uTidylib==0.2

* Tue 17 Sep 2013 11:43:24 PM JST

* Tue 17 Sep 2013 11:43:24 PM JST

* Tue 17 Sep 2013 11:43:24 PM JST
unicodecsv==0.9.4

* Tue 17 Sep 2013 11:43:24 PM JST
unicodecsv==0.9.4

* Tue 17 Sep 2013 11:43:24 PM JST
unicodecsv==0.9.4
urwid==1.0.1

* Tue 17 Sep 2013 11:43:25 PM JST
unicodecsv==0.9.4
urwid==1.0.1

* Tue 17 Sep 2013 11:43:25 PM JST
unicodecsv==0.9.4
urwid==1.0.1
vboxapi==1.0

* Tue 17 Sep 2013 11:43:27 PM JST

* Tue 17 Sep 2013 11:43:27 PM JST

* Tue 17 Sep 2013 11:43:27 PM JST
wadllib==1.3.0

* Tue 17 Sep 2013 11:43:27 PM JST
wadllib==1.3.0

* Tue 17 Sep 2013 11:43:27 PM JST
wadllib==1.3.0
webunit==1.3.10

* Tue 17 Sep 2013 11:43:27 PM JST
wadllib==1.3.0
webunit==1.3.10

* Tue 17 Sep 2013 11:43:28 PM JST
wadllib==1.3.0
webunit==1.3.10
wsgiref==0.1.2

* Tue 17 Sep 2013 11:43:28 PM JST
wadllib==1.3.0
webunit==1.3.10
wsgiref==0.1.2

* Tue 17 Sep 2013 11:43:28 PM JST
wadllib==1.3.0
webunit==1.3.10
wsgiref==0.1.2
wxGlade==0.6.5

* Tue 17 Sep 2013 11:43:29 PM JST
wadllib==1.3.0
webunit==1.3.10
wsgiref==0.1.2
wxGlade==0.6.5

* Tue 17 Sep 2013 11:43:29 PM JST
wadllib==1.3.0
webunit==1.3.10
wsgiref==0.1.2
wxGlade==0.6.5
wxPython==2.8.12.1

* Tue 17 Sep 2013 11:43:29 PM JST
wadllib==1.3.0
webunit==1.3.10
wsgiref==0.1.2
wxGlade==0.6.5
wxPython==2.8.12.1

* Tue 17 Sep 2013 11:43:29 PM JST
wadllib==1.3.0
webunit==1.3.10
wsgiref==0.1.2
wxGlade==0.6.5
wxPython==2.8.12.1
wxPython-common==2.8.12.1

* Tue 17 Sep 2013 11:43:31 PM JST
wadllib==1.3.0
webunit==1.3.10
wsgiref==0.1.2
wxGlade==0.6.5
wxPython==2.8.12.1
wxPython-common==2.8.12.1

* Tue 17 Sep 2013 11:43:31 PM JST
wadllib==1.3.0
webunit==1.3.10
wsgiref==0.1.2
wxGlade==0.6.5
wxPython==2.8.12.1
wxPython-common==2.8.12.1
xsser==1.6

* Tue 17 Sep 2013 11:43:32 PM JST
wadllib==1.3.0
webunit==1.3.10
wsgiref==0.1.2
wxGlade==0.6.5
wxPython==2.8.12.1
wxPython-common==2.8.12.1
xsser==1.6

* Tue 17 Sep 2013 11:43:32 PM JST
wadllib==1.3.0
webunit==1.3.10
wsgiref==0.1.2
wxGlade==0.6.5
wxPython==2.8.12.1
wxPython-common==2.8.12.1
xsser==1.6
zim==0.56

* Tue 17 Sep 2013 11:43:32 PM JST
wadllib==1.3.0
webunit==1.3.10
wsgiref==0.1.2
wxGlade==0.6.5
wxPython==2.8.12.1
wxPython-common==2.8.12.1
xsser==1.6
zim==0.56

* Tue 17 Sep 2013 11:43:32 PM JST
wadllib==1.3.0
webunit==1.3.10
wsgiref==0.1.2
wxGlade==0.6.5
wxPython==2.8.12.1
wxPython-common==2.8.12.1
xsser==1.6
zim==0.56
zope.interface==3.6.1

* Tue 17 Sep 2013 11:43:56 PM JST

* Tue 17 Sep 2013 11:43:56 PM JST

* Tue 17 Sep 2013 11:43:57 PM JST
Xpresser==1.1

* Tue 17 Sep 2013 11:44:40 PM JST

* Tue 17 Sep 2013 11:44:40 PM JST

* Tue 17 Sep 2013 11:44:40 PM JST
dnspython==1.10.0

* Tue 17 Sep 2013 11:46:31 PM JST

* Tue 17 Sep 2013 11:46:31 PM JST

* Tue 17 Sep 2013 11:46:31 PM JST
pyrit==0.4.0

* Tue 17 Sep 2013 11:54:12 PM JST
use '
* Tue 17 Sep 2013 11:54:12 PM JST
not use '
* Tue 17 Sep 2013 11:54:12 PM JST
Do not use '
* Tue 17 Sep 2013 11:54:12 PM JST
WARNING!! Do not use '
* Tue 17 Sep 2013 11:54:13 PM JST
09 =# WARNING!! Do not use '
* Wed 18 Sep 2013 12:01:46 AM JST
%a %b %d %H:%M:%S %Y
* Wed 18 Sep 2013 12:03:36 AM JST
realpath
* Wed 18 Sep 2013 12:04:28 AM JST
backuped
* Wed 18 Sep 2013 12:04:54 AM JST

* Wed 18 Sep 2013 12:04:54 AM JST

* Wed 18 Sep 2013 12:04:54 AM JST
        month = date[4:6]

* Wed 18 Sep 2013 12:04:55 AM JST
        month = date[4:6]

* Wed 18 Sep 2013 12:04:56 AM JST
        month = date[4:6]
        # trim 09 => 9

* Wed 18 Sep 2013 12:04:56 AM JST
        month = date[4:6]
        # trim 09 => 9

* Wed 18 Sep 2013 12:04:56 AM JST
        month = date[4:6]
        # trim 09 => 9
        if 0 == month[0]:

* Wed 18 Sep 2013 12:04:56 AM JST
        month = date[4:6]
        # trim 09 => 9
        if 0 == month[0]:

* Wed 18 Sep 2013 12:04:56 AM JST
        month = date[4:6]
        # trim 09 => 9
        if 0 == month[0]:
            month = month[1]

* Wed 18 Sep 2013 12:05:19 AM JST
datetime.datetime.now().month
* Wed 18 Sep 2013 12:14:25 AM JST
month
* Wed 18 Sep 2013 12:14:40 AM JST
month
* Wed 18 Sep 2013 12:14:58 AM JST
latest_path = '/data/.backup/king_remote/latest'
* Wed 18 Sep 2013 12:15:04 AM JST
realpath = os.path.realpath(latest_path)
* Wed 18 Sep 2013 12:15:08 AM JST
fmonth = datetime.datetime.fromtimestamp(os.path.getctime(realpath)).strftime('%Y%m')
* Wed 18 Sep 2013 12:15:55 AM JST
datetime.
* Wed 18 Sep 2013 12:16:00 AM JST
datetime.
* Wed 18 Sep 2013 12:17:19 AM JST
king_pullbackup()
* Wed 18 Sep 2013 12:42:38 AM JST

* Wed 18 Sep 2013 12:42:38 AM JST

* Wed 18 Sep 2013 12:42:39 AM JST
        if opts.debug:

* Wed 18 Sep 2013 12:42:45 AM JST

* Wed 18 Sep 2013 12:42:45 AM JST

* Wed 18 Sep 2013 12:42:45 AM JST
            if opts.debug:

* Wed 18 Sep 2013 12:42:54 AM JST

* Wed 18 Sep 2013 12:42:54 AM JST

* Wed 18 Sep 2013 12:42:54 AM JST
        if opts.debug:

* Wed 18 Sep 2013 12:43:15 AM JST

* Wed 18 Sep 2013 12:43:15 AM JST

* Wed 18 Sep 2013 12:43:15 AM JST
        if opts.debug:

* Wed 18 Sep 2013 12:46:51 AM JST
_walker
* Wed 18 Sep 2013 12:47:07 AM JST
_walker
* Wed 18 Sep 2013 12:47:19 AM JST
    def _walker(self):
        r"""SUMMARY

        @Return:
        """
        for modname, obj in getbuiltinmodules():
            for d in self.walk(obj=obj, parent=modname):
                yield d

* Wed 18 Sep 2013 12:49:28 AM JST
Exit
* Wed 18 Sep 2013 12:49:33 AM JST
Exit
* Wed 18 Sep 2013 12:49:37 AM JST
Exit
* Wed 18 Sep 2013 12:49:42 AM JST
Exit
* Wed 18 Sep 2013 12:50:19 AM JST
getbuiltins()
* Wed 18 Sep 2013 12:50:57 AM JST

* Wed 18 Sep 2013 12:50:57 AM JST

* Wed 18 Sep 2013 12:50:57 AM JST
getbuiltins()

* Wed 18 Sep 2013 12:53:52 AM JST
def getdocsummary(obj):
    r"""SUMMARY

    @Arguments:
    - `obj`:

    @Return:
    """
    # Do not use splitlines instead split('\n'), it will raise IndexError.
    return (_inspect.getdoc(obj) or '').split('\n')[0]


* Wed 18 Sep 2013 12:54:43 AM JST
findfile
* Wed 18 Sep 2013 12:54:58 AM JST

* Wed 18 Sep 2013 12:54:58 AM JST

* Wed 18 Sep 2013 12:54:58 AM JST
        # FIXME: (Atami) [2013/09/16]

* Wed 18 Sep 2013 12:54:58 AM JST
        # FIXME: (Atami) [2013/09/16]

* Wed 18 Sep 2013 12:54:58 AM JST
        # FIXME: (Atami) [2013/09/16]
        print('type error')

* Wed 18 Sep 2013 12:54:59 AM JST
        # FIXME: (Atami) [2013/09/16]
        print('type error')

* Wed 18 Sep 2013 12:54:59 AM JST
        # FIXME: (Atami) [2013/09/16]
        print('type error')
        print(obj)

* Wed 18 Sep 2013 12:55:16 AM JST

* Wed 18 Sep 2013 12:55:16 AM JST

* Wed 18 Sep 2013 12:55:16 AM JST
    except:

* Wed 18 Sep 2013 12:55:17 AM JST
    except:

* Wed 18 Sep 2013 12:55:17 AM JST
    except:
        pass

* Wed 18 Sep 2013 12:55:27 AM JST
    except:
        pass

* Wed 18 Sep 2013 12:55:27 AM JST
    except:
        pass
    return fname

* Wed 18 Sep 2013 12:55:32 AM JST
fname =
* Wed 18 Sep 2013 12:55:41 AM JST
def getsafeabsfile(obj):
    r"""SUMMARY

    @Arguments:
    - `obj`:

    @Return:
    """
    try:
        return _inspect.getabsfile(obj)
    except TypeError:
        return ''


* Wed 18 Sep 2013 12:56:16 AM JST
getsafeabsfile(subobj)
* Wed 18 Sep 2013 12:56:20 AM JST

* Wed 18 Sep 2013 12:56:20 AM JST

* Wed 18 Sep 2013 12:56:20 AM JST
                subfile = 

* Wed 18 Sep 2013 12:56:29 AM JST
file_
* Wed 18 Sep 2013 12:58:16 AM JST
def getdef(obj, name):
    r"""SUMMARY

    @Arguments:
    - `obj`:
    - `name`:

    @Return:
    """
    if not callable(obj):
        return name
    try:
        return str(_inspect.getargspec(obj)).replace('ArgSpec', name)
    except TypeError:
        return name + '()'


* Wed 18 Sep 2013 12:58:35 AM JST
def getmodules():
    r"""SUMMARY

    @Return:
    """
    pass


* Wed 18 Sep 2013 01:00:04 AM JST
def iterbuiltinsinfo(sammary=True, doc=True):
    r"""SUMMARY

    @Return:
    """
    for bname, builtin in getbuiltins():
        if sammary:
            smmry = getdocsummary(builtin)
        else:
            smmry = ''
        if doc:
            dc = _inspect.getdoc(builtin)
        else:
            doc = ''
        yield _defaultdict(str, name=bname, type=type(builtin),
                           summary=smmry, doc=dc)



* Wed 18 Sep 2013 01:21:23 AM JST
sys.path_importer_cache
* Wed 18 Sep 2013 01:28:20 AM JST

* Wed 18 Sep 2013 01:28:20 AM JST

* Wed 18 Sep 2013 01:28:20 AM JST
import 

* Wed 18 Sep 2013 01:37:54 AM JST
inspect.getmembers(__builtins__):
* Wed 18 Sep 2013 01:43:13 AM JST

* Wed 18 Sep 2013 01:43:13 AM JST

* Wed 18 Sep 2013 01:43:13 AM JST
ModWalker()

* Wed 18 Sep 2013 01:46:12 AM JST
import contex
* Wed 18 Sep 2013 01:50:49 AM JST

* Wed 18 Sep 2013 01:50:49 AM JST

* Wed 18 Sep 2013 01:50:49 AM JST
    raise StopIteration

* Wed 18 Sep 2013 01:56:00 AM JST
python_path="/usr/bin/python"
script_path="/usr/share/king/autohalt.py"

[ -x $python_path ] || exit 1
[ -x $script_path ] || exit 1

$python_path $script_path $@

exit 0

* Wed 18 Sep 2013 01:57:32 AM JST
echo "debug from shell2" >> /var/log/autohalt.log
* Wed 18 Sep 2013 01:57:42 AM JST
echo 
* Wed 18 Sep 2013 01:57:44 AM JST
echo "debug from shell3" >> /var/log/autohalt.log
* Wed 18 Sep 2013 02:05:53 AM JST
sys.path.append('/root/.pylib')
* Wed 18 Sep 2013 02:06:07 AM JST
import sys
sys.path.append('/root/.pylib')

* Wed 18 Sep 2013 02:13:29 AM JST
class PsChecker(object):
    """
    """

    def __init__(self):
        """

        Arguments:
        - `names`:
        """
        self._ps = _psutil.get_process_list()

    def name_exists(self, name):
        """SUMMARY

        @Arguments:

        - `name`:

        @Return:
        """
        for ps in self._ps:
            if name == ps.name:
                return True
        return False

## check process name exists
#
def psexists(name):
    """Check process name exists

    @Arguments:
    - `name`:

    @Return:
    """
    for ps in _psutil.get_process_list():
        if name == ps.name:
            return ps
    return None

def get_running_time():
    """SUMMARY

    @Return:
    """
    return _time.time() - _psutil.get_boot_time()

def isless_running_time(sec):
    """SUMMARY

    @Arguments:
    - `sec`: epoc time

    @Return:
    """
    return get_running_time() < sec

def get_connects_samba():
    """SUMMARY

    @Return:
    """
    smb_ps = []
    for ps in _psutil.get_process_list():
        if ps.name == 'smbd':
            smb_ps.append(ps)
    ip = []
    for ps in smb_ps:
        for con in ps.get_connections():
           if con.raddr:
               ip.append(con.raddr)
    return list(set(ip))

* Wed 18 Sep 2013 02:14:45 AM JST
sleep
* Wed 18 Sep 2013 02:14:45 AM JST
import sleep
* Wed 18 Sep 2013 02:15:03 AM JST
time.
* Wed 18 Sep 2013 03:03:48 AM JST
for _, modname, _ in _pkgutil.iter_modules():
* Wed 18 Sep 2013 03:35:37 AM JST
def walk_packages(path=None, prefix='', onerror=None):
    """Yields (module_loader, name, ispkg) for all modules recursively
    on path, or, if path is None, all accessible modules.

    'path' should be either None or a list of paths to look for
    modules in.

    'prefix' is a string to output on the front of every module name
    on output.

    Note that this function must import all *packages* (NOT all
    modules!) on the given path, in order to access the __path__
    attribute to find submodules.

    'onerror' is a function which gets called with one argument (the
    name of the package which was being imported) if any exception
    occurs while trying to import a package.  If no onerror function is
    supplied, ImportErrors are caught and ignored, while all other
    exceptions are propagated, terminating the search.

    Examples:

    # list all modules python can access
    walk_packages()

    # list all submodules of ctypes
    walk_packages(ctypes.__path__, ctypes.__name__+'.')
    """

    def seen(p, m={}):
        if p in m:
            return True
        m[p] = True

    for importer, name, ispkg in iter_modules(path, prefix):
        yield importer, name, ispkg

        if ispkg:
            try:
                __import__(name)
            except ImportError:
                if onerror is not None:
                    onerror(name)
            except Exception:
                if onerror is not None:
                    onerror(name)
                else:
                    raise
            else:
                path = getattr(sys.modules[name], '__path__', None) or []

                # don't traverse path items we've seen before
                path = [p for p in path if not seen(p)]

                for item in walk_packages(path, name+'.', onerror):
                    yield item

* Wed 18 Sep 2013 03:47:38 AM JST
            except TypeError:
                continue

* Wed 18 Sep 2013 04:00:25 AM JST
_pkgutil.walk_packages(onerror=lambda name: None)
* Wed 18 Sep 2013 04:08:31 AM JST
object=obj
* Wed 18 Sep 2013 04:16:04 AM JST
        if '' == parent and hasattr(obj, '__name__'):
            parent = obj.__name__

* Wed 18 Sep 2013 04:17:20 AM JST

* Wed 18 Sep 2013 04:17:20 AM JST

* Wed 18 Sep 2013 04:17:20 AM JST
        if _inspect.ismodule(obj):

* Wed 18 Sep 2013 04:21:13 AM JST
start
* Wed 18 Sep 2013 04:22:43 AM JST
name=key,
                               file=getsafeabsfile(obj),
                               type=type(obj),
                               definition=key,
                               summary=getdocsummary(obj),
                               doc = (_inspect.getdoc(obj) or '')
* Wed 18 Sep 2013 04:23:24 AM JST
key
* Wed 18 Sep 2013 04:24:43 AM JST
mod
* Wed 18 Sep 2013 04:24:46 AM JST
mod
* Wed 18 Sep 2013 04:24:53 AM JST
mod
* Wed 18 Sep 2013 04:25:39 AM JST
key
* Wed 18 Sep 2013 04:29:40 AM JST
                yield _defaultdict(name=parent+'.'+memname,
                                   file=getsafeabsfile(subobj),
                                   type=type(subobj),
                                   definition=parent+'.'+memname+'()',
                                   summary=getdocsummary(subobj),
                                   doc = (_inspect.getdoc(subobj) or ''))

* Wed 18 Sep 2013 04:30:33 AM JST
parent+'.'+memname
* Wed 18 Sep 2013 04:41:15 AM JST
momo
* Wed 18 Sep 2013 04:42:00 AM JST
momo
* Wed 18 Sep 2013 04:44:52 AM JST
momo
* Wed 18 Sep 2013 04:58:02 AM JST

* Wed 18 Sep 2013 04:58:02 AM JST

* Wed 18 Sep 2013 04:58:02 AM JST
                except NotImplementedError:

* Wed 18 Sep 2013 04:58:02 AM JST
                except NotImplementedError:

* Wed 18 Sep 2013 04:58:02 AM JST
                except NotImplementedError:
                    continue

* Wed 18 Sep 2013 05:00:18 AM JST

* Wed 18 Sep 2013 05:00:18 AM JST

* Wed 18 Sep 2013 05:00:18 AM JST
                try:

* Wed 18 Sep 2013 02:14:09 PM JST
def matcher(key, elements, iter_):
    r"""SUMMARY

    @Arguments:
    - `key`:

    @Return:
    """
    for d in iter_:
        for el in elements:
            if _re.search(key, str(d[el])):
                yield d
                break


* Wed 18 Sep 2013 02:14:17 PM JST
elements = ['name', 'file', 'type', 'definition', 'object', 'summary', 'doc']

def matcher(key, elements, iter_):
    r"""SUMMARY

    @Arguments:
    - `key`:

    @Return:
    """
    for d in iter_:
        for el in elements:
            if _re.search(key, str(d[el])):
                yield d
                break

* Wed 18 Sep 2013 02:14:44 PM JST
iter_
* Wed 18 Sep 2013 02:14:44 PM JST
elements, iter_
* Wed 18 Sep 2013 02:22:57 PM JST
'{0:<10} : {1}'
* Wed 18 Sep 2013 02:23:13 PM JST
FORMAT
* Wed 18 Sep 2013 02:25:06 PM JST
    
* Wed 18 Sep 2013 02:25:08 PM JST
name
* Wed 18 Sep 2013 02:25:12 PM JST
name
* Wed 18 Sep 2013 02:25:16 PM JST
    
* Wed 18 Sep 2013 02:25:18 PM JST
file
* Wed 18 Sep 2013 02:25:23 PM JST
file
* Wed 18 Sep 2013 02:25:29 PM JST
    
* Wed 18 Sep 2013 02:25:32 PM JST
definition
* Wed 18 Sep 2013 02:25:36 PM JST
definition
* Wed 18 Sep 2013 02:25:40 PM JST
    
* Wed 18 Sep 2013 02:25:42 PM JST
summary
* Wed 18 Sep 2013 02:25:48 PM JST
summary
* Wed 18 Sep 2013 02:26:29 PM JST
test()
* Wed 18 Sep 2013 02:27:56 PM JST
def test(key, o, **flags):
    r"""SUMMARY

    @Arguments:
    - `key`:
    - `o`:
    - `**flags`:

    @Return:
    """
    print(key)
    print(o)

    print(flags['name'])

* Wed 18 Sep 2013 02:29:43 PM JST
                
* Wed 18 Sep 2013 02:30:39 PM JST
summary
* Wed 18 Sep 2013 02:38:27 PM JST
print(str(dic['obj']))
* Wed 18 Sep 2013 02:39:02 PM JST
n**********************************
* Wed 18 Sep 2013 02:43:24 PM JST

* Wed 18 Sep 2013 02:43:24 PM JST

* Wed 18 Sep 2013 02:43:24 PM JST
# from .dataholder import AproposDataHolder

* Wed 18 Sep 2013 02:46:38 PM JST
def matcher(key, pager=pager,
            inname=True, infile=False, indef=False, insummary=True, indoc=False):
    r"""SUMMARY

    @Arguments:
    - `key`:

    @Return:
    """
    for d in ModuleInfoWalker():
        if ((inname and _re.search(key, str(d['name']))) or
            (infile and _re.search(key, str(d['file']))) or
            (indef and _re.search(key, str(d['definition']))) or
            (insummary and _re.search(key, str(d['summary']))) or
            (indoc and _re.search(key, str(d['doc'])))):

            pager(key, d, inname=inname, infile=infile, indef=indef,
                  insummary=insummary, indoc=indoc)


def pager(key, dic, **flags):
    r"""SUMMARY

    @Arguments:
    - `key`:
    - `dic`:

    @Return:
    """
    fmt = '{0:<10} : {1}'
    print('\n{0:*<50}'.format(''))
    print(fmt.format('name', str(dic['name'])))
    print(fmt.format('file', str(dic['file'])))
    print(fmt.format('definition', str(dic['definition'])))
    print(fmt.format('summary', str(dic['summary'])))
    if flags.get('indoc', False):
        print(fmt.format('doc', str(dic['doc'])))

* Wed 18 Sep 2013 02:47:13 PM JST
## functions
#
def getbuiltins():
    r"""SUMMARY

    @Return:
    """
    for name, builtin in _inspect.getmembers(__builtins__):
        if name.startswith('_'):
            continue
        yield name, builtin


def getbuiltinmodules():
    r"""SUMMARY

    @Return:
    """
    for modname in _sys.builtin_module_names:
        if modname == '__main__':
            continue
        yield modname, __import__(modname)


def getmodules():
    r"""SUMMARY

    @Return:
    """
    for _, modname, _ in _pkgutil.iter_modules():
        yield modname, __import__(modname)



* Wed 18 Sep 2013 02:49:44 PM JST
modules
* Wed 18 Sep 2013 02:49:53 PM JST
object
* Wed 18 Sep 2013 02:50:22 PM JST
class ModuleInfoWalker(object):
    r"""
    """

    def __init__(self, ):
        r"""
        """
        for _, _, _ in _pkgutil.walk_packages(onerror=lambda name: None):
            pass
        self._iters = self._itermodinfo()

    def __iter__(self):
        r"""SUMMARY

        @Return:
        """
        return self

    def next(self):
        r"""SUMMARY

        @Return:
        """
        return self._iters.next()

    def _itermodinfo(self):
        r"""SUMMARY

        @Return:
        """
        for key, obj in sys.modules.iteritems():
            if obj is None:
                continue
            yield _defaultdict(str,
                               name=key,
                               file=getsafeabsfile(obj),
                               type=type(obj),
                               definition=key,
                               summary=getdocsummary(obj),
                               doc = (_inspect.getdoc(obj) or ''))
            try:
                for d in self._recursivemod(obj, parent=key):
                    yield d
            except NotImplementedError:
                continue

    def _recursivemod(self, obj, parent=''):
        r"""SUMMARY

        @Return:
        """
        if '' == parent and hasattr(obj, '__name__'):
            parent = obj.__name__

        for memname, subobj in _inspect.getmembers(obj):
            if memname.startswith('_') and memname.endswith('__'):
                continue
            if _inspect.isfunction(subobj) or _inspect.ismethod(subobj):
                yield _defaultdict(str,
                                   name=parent+'.'+memname,
                                   file=getsafeabsfile(subobj),
                                   type=type(subobj),
                                   definition=getdef(subobj, parent+'.'+memname),
                                   summary=getdocsummary(subobj),
                                   doc = (_inspect.getdoc(subobj) or ''))

            if _inspect.isclass(subobj):
                yield _defaultdict(str,
                                   name=parent+'.'+memname,
                                   file=getsafeabsfile(subobj),
                                   type=type(subobj),
                                   definition=parent+'.'+memname+'()',
                                   summary=getdocsummary(subobj),
                                   doc = (_inspect.getdoc(subobj) or ''))
                self._recursivemod(subobj, parent=parent+'.'+memname+'()')


## functions
#
def getbuiltins():
    r"""SUMMARY

    @Return:
    """
    for name, builtin in _inspect.getmembers(__builtins__):
        if name.startswith('_'):
            continue
        yield name, builtin


def getbuiltinmodules():
    r"""SUMMARY

    @Return:
    """
    for modname in _sys.builtin_module_names:
        if modname == '__main__':
            continue
        yield modname, __import__(modname)


def getmodules():
    r"""SUMMARY

    @Return:
    """
    for _, modname, _ in _pkgutil.iter_modules():
        yield modname, __import__(modname)


def getdef(obj, name):
    r"""SUMMARY

    @Arguments:
    - `obj`:
    - `name`:

    @Return:
    """
    if not callable(obj):
        return name
    try:
        return str(_inspect.getargspec(obj)).replace('ArgSpec', name)
    except TypeError:
        return name + '()'


def getdocsummary(obj):
    r"""SUMMARY

    @Arguments:
    - `obj`:

    @Return:
    """
    # Do not use splitlines instead split('\n'),
    # it will raise IndexError.
    return (_inspect.getdoc(obj) or '').split('\n')[0]


def getsafeabsfile(obj):
    r"""SUMMARY

    @Arguments:
    - `obj`:

    @Return:
    """
    try:
        return _inspect.getabsfile(obj)
    except TypeError:
        return ''

* Wed 18 Sep 2013 02:52:44 PM JST
def _pager(key, dic, **flags):
    r"""SUMMARY

    @Arguments:
    - `key`:
    - `dic`:

    @Return:
    """
    fmt = '{0:<10} : {1}'
    print('\n{0:*<50}'.format(''))
    print(fmt.format('name', str(dic['name'])))
    print(fmt.format('file', str(dic['file'])))
    print(fmt.format('definition', str(dic['definition'])))
    print(fmt.format('summary', str(dic['summary'])))
    if flags.get('indoc', False):
        print(fmt.format('doc', str(dic['doc'])))


* Wed 18 Sep 2013 02:52:53 PM JST
def _pager(key, dic, **flags):
    r"""SUMMARY

    @Arguments:
    - `key`:
    - `dic`:

    @Return:
    """
    fmt = '{0:<10} : {1}'
    print('\n{0:*<50}'.format(''))
    print(fmt.format('name', str(dic['name'])))
    print(fmt.format('file', str(dic['file'])))
    print(fmt.format('definition', str(dic['definition'])))
    print(fmt.format('summary', str(dic['summary'])))
    if flags.get('indoc', False):
        print(fmt.format('doc', str(dic['doc'])))



* Wed 18 Sep 2013 02:56:53 PM JST

* Wed 18 Sep 2013 02:56:53 PM JST

* Wed 18 Sep 2013 02:56:53 PM JST
if __name__ == '__main__':

* Wed 18 Sep 2013 02:59:20 PM JST
matcher
* Wed 18 Sep 2013 03:00:36 PM JST

* Wed 18 Sep 2013 03:00:36 PM JST

* Wed 18 Sep 2013 03:00:36 PM JST
# sys.exit(_main())

* Wed 18 Sep 2013 03:02:48 PM JST
def _pager(key, dic, **flags):
    r"""SUMMARY

    @Arguments:
    - `key`:
    - `dic`:

    @Return:
    """
    fmt = '{0:<10} : {1}'
    print('\n{0:*<50}'.format(''))
    print(fmt.format('name', str(dic['name'])))
    print(fmt.format('file', str(dic['file'])))
    print(fmt.format('definition', str(dic['definition'])))
    print(fmt.format('summary', str(dic['summary'])))
    if flags.get('indoc', False):
        print(fmt.format('doc', str(dic['doc'])))

* Wed 18 Sep 2013 03:08:59 PM JST
## main functions
#
def explorer(key, pager=normalpager,
            inname=True, infile=False, indef=False, insummary=True, indoc=False):
    r"""SUMMARY

    @Arguments:
    - `key`:

    @Return:
    """
    for d in ModuleInfoWalker():
        if ((inname and _re.search(key, str(d['name']))) or
            (infile and _re.search(key, str(d['file']))) or
            (indef and _re.search(key, str(d['definition']))) or
            (insummary and _re.search(key, str(d['summary']))) or
            (indoc and _re.search(key, str(d['doc'])))):

            pager(key, d, inname=inname, infile=infile, indef=indef,
                  insummary=insummary, indoc=indoc)


* Wed 18 Sep 2013 03:09:33 PM JST
from .moduleinfowalker import ModuleInfoWalker
from .pager import normalpager

* Wed 18 Sep 2013 03:10:32 PM JST
from time import sleep
import os
import sys as _sys
import re as _re
import inspect as _inspect
from collections import defaultdict as _defaultdict
import types as _types

import pkgutil as _pkgutil

* Wed 18 Sep 2013 03:11:01 PM JST

* Wed 18 Sep 2013 03:11:01 PM JST

* Wed 18 Sep 2013 03:11:01 PM JST
import sys as _sys

* Wed 18 Sep 2013 03:11:03 PM JST
import sys as _sys

* Wed 18 Sep 2013 03:11:03 PM JST
import sys as _sys
from time import sleep

* Wed 18 Sep 2013 03:13:40 PM JST

* Wed 18 Sep 2013 03:13:40 PM JST

* Wed 18 Sep 2013 03:13:40 PM JST
import os

* Wed 18 Sep 2013 03:15:15 PM JST
(flymake-mode 1)
* Wed 18 Sep 2013 03:17:09 PM JST

* Wed 18 Sep 2013 03:17:09 PM JST

* Wed 18 Sep 2013 03:17:09 PM JST
import re as _re

* Wed 18 Sep 2013 03:17:47 PM JST

* Wed 18 Sep 2013 03:17:47 PM JST

* Wed 18 Sep 2013 03:17:47 PM JST
import types as _types

* Wed 18 Sep 2013 03:20:29 PM JST

* Wed 18 Sep 2013 03:20:29 PM JST

* Wed 18 Sep 2013 03:20:29 PM JST
import types as _types

* Wed 18 Sep 2013 03:20:48 PM JST

* Wed 18 Sep 2013 03:20:48 PM JST

* Wed 18 Sep 2013 03:20:48 PM JST
import types as _types

* Wed 18 Sep 2013 03:31:45 PM JST
print('hello')
* Wed 18 Sep 2013 03:42:03 PM JST

* Wed 18 Sep 2013 03:42:03 PM JST

* Wed 18 Sep 2013 03:42:03 PM JST
                    const=None,

* Wed 18 Sep 2013 03:42:05 PM JST

* Wed 18 Sep 2013 03:42:05 PM JST

* Wed 18 Sep 2013 03:42:05 PM JST
                    choices=None,

* Wed 18 Sep 2013 03:42:16 PM JST
def _predef_options():
    parser = argparse.ArgumentParser(description="""apropos""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,
                        help='Version Strings.')

    parser.add_argument('key',
                    dest='key',
                    action='store',
                    nargs=1,
                    default=None,
                    type=str,
                    required=True,
                    # (yas/expand-link "argparse_other_options" t)
                    help='Search key as regexp.')
    # (yas/expand-link "argparse_add_argument" t)
    return parser

def _main():
    r"""Main function."""
    parser = _predef_options()
    opts = parser.parse_args()
    # parser.print_usage()



    return 0


## Do Main!!
if __name__ == '__main__':
    sys.exit(_main())

* Wed 18 Sep 2013 03:45:17 PM JST

* Wed 18 Sep 2013 03:45:17 PM JST

* Wed 18 Sep 2013 03:45:17 PM JST
                    dest='key',

* Wed 18 Sep 2013 03:45:25 PM JST

* Wed 18 Sep 2013 03:45:25 PM JST

* Wed 18 Sep 2013 03:45:25 PM JST
    # (yas/expand-link "argparse_other_options" t)

* Wed 18 Sep 2013 03:49:28 PM JST
('worldyahoo')
* Wed 18 Sep 2013 03:51:26 PM JST
store
* Wed 18 Sep 2013 03:53:13 PM JST
store_const
* Wed 18 Sep 2013 03:55:04 PM JST
'|'.join(opts.key)
* Wed 18 Sep 2013 03:59:27 PM JST
argparse.ONE_OR_MORE
* Wed 18 Sep 2013 04:01:13 PM JST
append
* Wed 18 Sep 2013 04:07:30 PM JST

* Wed 18 Sep 2013 04:07:30 PM JST

* Wed 18 Sep 2013 04:07:30 PM JST
    if 1 == len(opts.key):

* Wed 18 Sep 2013 04:08:43 PM JST
key, 
* Wed 18 Sep 2013 04:08:45 PM JST
key, 
* Wed 18 Sep 2013 04:08:47 PM JST
key, 
* Wed 18 Sep 2013 04:08:49 PM JST
key, 
* Wed 18 Sep 2013 04:08:51 PM JST
key, 
* Wed 18 Sep 2013 04:09:15 PM JST

* Wed 18 Sep 2013 04:09:15 PM JST

* Wed 18 Sep 2013 04:09:15 PM JST
                        nargs=1,

* Wed 18 Sep 2013 04:09:18 PM JST

* Wed 18 Sep 2013 04:09:18 PM JST

* Wed 18 Sep 2013 04:09:18 PM JST
                        type=str,

* Wed 18 Sep 2013 04:09:41 PM JST

* Wed 18 Sep 2013 04:09:41 PM JST

* Wed 18 Sep 2013 04:09:41 PM JST
                    required=True,

* Wed 18 Sep 2013 04:09:42 PM JST

* Wed 18 Sep 2013 04:09:42 PM JST

* Wed 18 Sep 2013 04:09:42 PM JST
                    # const = True,

* Wed 18 Sep 2013 04:09:42 PM JST
                    # const = True,

* Wed 18 Sep 2013 04:09:43 PM JST
                    # const = True,
                    # type=str,

* Wed 18 Sep 2013 04:09:43 PM JST
                    # const = True,
                    # type=str,

* Wed 18 Sep 2013 04:09:43 PM JST
                    # const = True,
                    # type=str,
                    # (yas/expand-link "argparse_other_options" t)

* Wed 18 Sep 2013 04:09:45 PM JST

* Wed 18 Sep 2013 04:09:45 PM JST

* Wed 18 Sep 2013 04:09:45 PM JST
                    # dest='key',

* Wed 18 Sep 2013 04:09:53 PM JST
    parser.add_argument('key',
                        action='store',
                        nargs=argparse.ONE_OR_MORE,
                        default=None,
                        help='Search key as regexp.')

* Wed 18 Sep 2013 04:11:34 PM JST

* Wed 18 Sep 2013 04:11:34 PM JST

* Wed 18 Sep 2013 04:11:34 PM JST
    # parser.print_usage()

* Wed 18 Sep 2013 04:12:14 PM JST
re.compile('|'.join(opts.key))
* Wed 18 Sep 2013 04:20:12 PM JST
normalpager
* Wed 18 Sep 2013 04:37:02 PM JST
There is no such reader #0, PCSC sees only 0 reader(s)
* Wed 18 Sep 2013 04:41:18 PM JST
/usr/lib/python2.7/dist-packages/rfidiot/
* Wed 18 Sep 2013 04:42:36 PM JST
RFIDIOt
* Wed 18 Sep 2013 04:42:40 PM JST
pynfc
* Wed 18 Sep 2013 04:42:48 PM JST
rfidiotglobals
* Wed 18 Sep 2013 04:42:54 PM JST
pyandroid
* Wed 18 Sep 2013 04:43:01 PM JST
iso3166
* Wed 18 Sep 2013 04:50:19 PM JST

* Wed 18 Sep 2013 04:50:19 PM JST

* Wed 18 Sep 2013 04:50:19 PM JST
        except SystemExit:

* Wed 18 Sep 2013 04:50:19 PM JST
        except SystemExit:

* Wed 18 Sep 2013 04:50:19 PM JST
        except SystemExit:
            pass

* Wed 18 Sep 2013 04:50:25 PM JST

* Wed 18 Sep 2013 04:50:25 PM JST

* Wed 18 Sep 2013 04:50:25 PM JST
        try:

* Wed 18 Sep 2013 04:53:32 PM JST
        for _, _, _ in _pkgutil.walk_packages(onerror=lambda name: None):
            pass

* Wed 18 Sep 2013 04:55:21 PM JST
pkgutil.walk_packages(onerror=lambda name: None)
* Wed 18 Sep 2013 04:56:58 PM JST
pass
* Wed 18 Sep 2013 05:00:21 PM JST
def walk_packages(path=None, prefix='', onerror=None):
    """Yields (module_loader, name, ispkg) for all modules recursively
    on path, or, if path is None, all accessible modules.

    'path' should be either None or a list of paths to look for
    modules in.

    'prefix' is a string to output on the front of every module name
    on output.

    Note that this function must import all *packages* (NOT all
    modules!) on the given path, in order to access the __path__
    attribute to find submodules.

    'onerror' is a function which gets called with one argument (the
    name of the package which was being imported) if any exception
    occurs while trying to import a package.  If no onerror function is
    supplied, ImportErrors are caught and ignored, while all other
    exceptions are propagated, terminating the search.

    Examples:

    # list all modules python can access
    walk_packages()

    # list all submodules of ctypes
    walk_packages(ctypes.__path__, ctypes.__name__+'.')
    """

    def seen(p, m={}):
        if p in m:
            return True
        m[p] = True

    for importer, name, ispkg in iter_modules(path, prefix):
        yield importer, name, ispkg

        if ispkg:
            try:
                __import__(name)
            except ImportError:
                if onerror is not None:
                    onerror(name)
            except Exception:
                if onerror is not None:
                    onerror(name)
                else:
                    raise
            else:
                path = getattr(sys.modules[name], '__path__', None) or []

                # don't traverse path items we've seen before
                path = [p for p in path if not seen(p)]

                for item in walk_packages(path, name+'.', onerror):
                    yield item

* Wed 18 Sep 2013 05:01:53 PM JST
iter_modules
* Wed 18 Sep 2013 05:10:22 PM JST
_pkgutil.
* Wed 18 Sep 2013 05:14:09 PM JST

* Wed 18 Sep 2013 05:14:09 PM JST

* Wed 18 Sep 2013 05:14:09 PM JST
        print('DEBUG-2-explorer.py')

* Wed 18 Sep 2013 05:14:13 PM JST

* Wed 18 Sep 2013 05:14:13 PM JST

* Wed 18 Sep 2013 05:14:13 PM JST
            print('DEBUG-1-explorer.py')

* Wed 18 Sep 2013 05:14:19 PM JST
None
* Wed 18 Sep 2013 05:15:36 PM JST
RuntimeError: dictionary changed size during iteration
* Wed 18 Sep 2013 05:19:05 PM JST
_sys
* Wed 18 Sep 2013 05:19:34 PM JST

* Wed 18 Sep 2013 05:19:34 PM JST

* Wed 18 Sep 2013 05:19:34 PM JST
from copy import deepcopy

* Wed 18 Sep 2013 05:22:50 PM JST

* Wed 18 Sep 2013 05:22:51 PM JST

* Wed 18 Sep 2013 05:22:51 PM JST
        self._modules = _sys.modules

* Wed 18 Sep 2013 05:22:52 PM JST

* Wed 18 Sep 2013 05:22:52 PM JST

* Wed 18 Sep 2013 05:22:52 PM JST
        self._modules = _sys.modules

* Wed 18 Sep 2013 05:22:56 PM JST
_modules
* Wed 18 Sep 2013 05:22:57 PM JST
self._modules
* Wed 18 Sep 2013 05:23:04 PM JST
iter
* Wed 18 Sep 2013 05:32:16 PM JST

* Wed 18 Sep 2013 05:32:16 PM JST

* Wed 18 Sep 2013 05:32:16 PM JST
        elif 'posix' == _os.name:

* Wed 18 Sep 2013 05:35:19 PM JST
junk.
* Wed 18 Sep 2013 05:35:19 PM JST
173517.junk.
* Wed 18 Sep 2013 05:35:20 PM JST
18-173517.junk.
* Wed 18 Sep 2013 05:35:20 PM JST
09-18-173517.junk.
* Wed 18 Sep 2013 05:35:21 PM JST
2013-09-18-173517.junk.
* Wed 18 Sep 2013 05:39:30 PM JST
    
* Wed 18 Sep 2013 05:39:31 PM JST
GREEN
* Wed 18 Sep 2013 05:39:36 PM JST
    
* Wed 18 Sep 2013 05:39:38 PM JST
BLACK
* Wed 18 Sep 2013 05:39:42 PM JST
    
* Wed 18 Sep 2013 05:39:44 PM JST
YELLOW
* Wed 18 Sep 2013 05:39:49 PM JST
    
* Wed 18 Sep 2013 05:39:51 PM JST
BLUE
* Wed 18 Sep 2013 05:39:57 PM JST
    
* Wed 18 Sep 2013 05:39:58 PM JST
MAGENTA
* Wed 18 Sep 2013 05:40:03 PM JST
    
* Wed 18 Sep 2013 05:40:04 PM JST
CYAN
* Wed 18 Sep 2013 05:40:09 PM JST
    
* Wed 18 Sep 2013 05:40:12 PM JST

* Wed 18 Sep 2013 05:40:12 PM JST

* Wed 18 Sep 2013 05:40:12 PM JST
    print(Fore.WHITE + 'world')

* Wed 18 Sep 2013 05:41:11 PM JST

* Wed 18 Sep 2013 05:41:11 PM JST

* Wed 18 Sep 2013 05:41:11 PM JST
    if 'nt' == _os.name:

* Wed 18 Sep 2013 05:41:11 PM JST
    if 'nt' == _os.name:

* Wed 18 Sep 2013 05:41:11 PM JST
    if 'nt' == _os.name:
        from colorama import init

* Wed 18 Sep 2013 05:41:15 PM JST

* Wed 18 Sep 2013 05:41:15 PM JST

* Wed 18 Sep 2013 05:41:15 PM JST
    init()

* Wed 18 Sep 2013 05:41:37 PM JST
'{0:<10} : {1}'
* Wed 18 Sep 2013 05:42:35 PM JST
    print('\n{0:*<50}'.format(''))
    print(fmt.format('name', str(dic['name'])))
    try:
        types = str(dic['type']).split("type ")[1].split('>')[0].replace("'", "")
        print(fmt.format('type', types))
    except IndexError:
        pass
    print(fmt.format('definition', str(dic['definition'])))
    print(fmt.format('file', str(dic['file'])))
    print(fmt.format('summary', str(dic['summary'])))
    if flags.get('indoc', False):
        print(fmt.format('doc', str(dic['doc'])))

* Wed 18 Sep 2013 05:43:18 PM JST
normal
* Wed 18 Sep 2013 05:47:25 PM JST
' : '
* Wed 18 Sep 2013 05:51:25 PM JST

* Wed 18 Sep 2013 05:51:25 PM JST

* Wed 18 Sep 2013 05:51:25 PM JST
    print('\n{0:*<50}'.format(''))

* Wed 18 Sep 2013 05:51:40 PM JST
str(dic['name'])
* Wed 18 Sep 2013 05:54:59 PM JST
Style.BRIGHT
* Wed 18 Sep 2013 06:00:08 PM JST

* Wed 18 Sep 2013 06:00:08 PM JST

* Wed 18 Sep 2013 06:00:08 PM JST
    # print(fmt.format('name', str(dic['name'])))

* Wed 18 Sep 2013 06:02:00 PM JST
           
* Wed 18 Sep 2013 06:02:34 PM JST
NORMAL
* Wed 18 Sep 2013 06:04:47 PM JST
NORMAL
* Wed 18 Sep 2013 06:05:31 PM JST
RESET_ALL
* Wed 18 Sep 2013 06:05:41 PM JST
Style.NORMAL
* Wed 18 Sep 2013 06:05:54 PM JST
           
* Wed 18 Sep 2013 06:06:17 PM JST
RESET_ALL
* Wed 18 Sep 2013 06:09:51 PM JST
NoneType
* Wed 18 Sep 2013 06:10:39 PM JST
NoneType
* Wed 18 Sep 2013 06:13:15 PM JST
Style.BRIGHT
* Wed 18 Sep 2013 06:13:24 PM JST
Fore.RESET
* Wed 18 Sep 2013 06:13:30 PM JST
Style.NORMAL
* Wed 18 Sep 2013 06:13:59 PM JST
Style.BRIGHT
* Wed 18 Sep 2013 06:14:08 PM JST
+ Style.NORMAL
* Wed 18 Sep 2013 06:15:47 PM JST
Style.BRIGHT
* Thu 19 Sep 2013 01:06:24 AM JST
not
* Thu 19 Sep 2013 01:16:08 AM JST
Style
* Thu 19 Sep 2013 01:17:35 AM JST
makeanotation(str(dic['name']), key, Fore.RED)
* Thu 19 Sep 2013 01:18:22 AM JST
def makeanotation(str_, regexp, color):
    r"""SUMMARY

    @Arguments:
    - `str_`:
    - `regexp`:
    - `color`:

    @Return:
    """
    match = regexp.search(str_)
    if match is None:
        return str_
    try:
        return (str_[:match.start()] + color + str_[match.start():match.end] +
                Fore.RESET + str_[match.end():])
    except TypeError:
        return str_


* Thu 19 Sep 2013 01:19:58 AM JST

* Thu 19 Sep 2013 01:19:58 AM JST

* Thu 19 Sep 2013 01:19:58 AM JST
            print('DEBUG-1-pager.py')

* Thu 19 Sep 2013 01:22:12 AM JST

* Thu 19 Sep 2013 01:22:12 AM JST

* Thu 19 Sep 2013 01:22:13 AM JST
    print(makeanotation(str(dic['name']), key, Fore.RED))

* Thu 19 Sep 2013 01:24:18 AM JST
makeano
* Thu 19 Sep 2013 01:26:23 AM JST
search
* Thu 19 Sep 2013 01:26:45 AM JST
VAR
* Thu 19 Sep 2013 01:26:47 AM JST
COLLECTION
* Thu 19 Sep 2013 01:26:47 AM JST
in COLLECTION
* Thu 19 Sep 2013 01:26:50 AM JST
match in regexp.finditer(str_)
* Thu 19 Sep 2013 01:27:42 AM JST
news
* Thu 19 Sep 2013 01:28:18 AM JST
(str_[:match.start()] +
                    Style.BRIGHT + color +
                    str_[match.start():match.end()] +
                    Style.NORMAL + Fore.RESET +
                    str_[match.end():])
* Thu 19 Sep 2013 01:29:13 AM JST

* Thu 19 Sep 2013 01:29:13 AM JST

* Thu 19 Sep 2013 01:29:13 AM JST
    match = key.search(str(dic['name']))

* Thu 19 Sep 2013 01:33:12 AM JST
makeanotation(
* Thu 19 Sep 2013 01:33:16 AM JST
RED)
* Thu 19 Sep 2013 01:33:17 AM JST
Fore.RED)
* Thu 19 Sep 2013 01:33:17 AM JST
key, Fore.RED)
* Thu 19 Sep 2013 01:33:18 AM JST
                                                     key, Fore.RED)
* Thu 19 Sep 2013 01:33:54 AM JST
BRIGHT + 
* Thu 19 Sep 2013 01:33:55 AM JST
Style.BRIGHT + 
* Thu 19 Sep 2013 01:34:00 AM JST
NORMAL + 
* Thu 19 Sep 2013 01:34:00 AM JST
Style.NORMAL + 
* Thu 19 Sep 2013 01:34:03 AM JST
                          
* Thu 19 Sep 2013 01:34:05 AM JST
                          
* Thu 19 Sep 2013 01:34:07 AM JST
                          
* Thu 19 Sep 2013 01:34:54 AM JST
'|'.join(opts.key))
* Thu 19 Sep 2013 01:35:20 AM JST
key
* Thu 19 Sep 2013 01:35:21 AM JST
opts.key
* Thu 19 Sep 2013 01:35:21 AM JST
print(opts.key
* Thu 19 Sep 2013 01:35:21 AM JST
print(opts.key
* Thu 19 Sep 2013 01:35:22 AM JST
print(opts.key    )

* Thu 19 Sep 2013 01:35:23 AM JST

* Thu 19 Sep 2013 01:35:23 AM JST

* Thu 19 Sep 2013 01:35:23 AM JST
    print()

* Thu 19 Sep 2013 01:36:04 AM JST
print('*** 
* Thu 19 Sep 2013 02:09:03 AM JST
def
* Thu 19 Sep 2013 02:11:58 AM JST
summa
* Thu 19 Sep 2013 02:11:58 AM JST
nosearch - summa
* Thu 19 Sep 2013 02:13:45 AM JST
    
* Thu 19 Sep 2013 02:15:13 AM JST
normalpager
* Thu 19 Sep 2013 02:21:23 AM JST

* Thu 19 Sep 2013 02:21:23 AM JST

* Thu 19 Sep 2013 02:21:23 AM JST
import types

* Thu 19 Sep 2013 02:34:59 AM JST
import
* Thu 19 Sep 2013 02:48:44 AM JST
KEYWORD
* Thu 19 Sep 2013 02:53:11 AM JST
start-process
* Thu 19 Sep 2013 02:58:34 AM JST
pylintp
* Thu 19 Sep 2013 03:10:39 AM JST
https://github.com/dhgxx/elisp/blob/master/mi-ansi-color.el
* Thu 19 Sep 2013 03:20:43 AM JST
term
* Thu 19 Sep 2013 03:28:17 AM JST
(start-process "pyapropos" (get-buffer-create "*pyapropos*")
               "/usr/bin/python" "-m" "apropos" "--color-normal" )
* Thu 19 Sep 2013 03:33:18 AM JST
(interactive "sSearch keywords as regexp: ")
* Thu 19 Sep 2013 03:36:13 AM JST
erroneous
* Thu 19 Sep 2013 03:44:52 AM JST
create 
* Thu 19 Sep 2013 03:44:52 AM JST
buffer-create 
* Thu 19 Sep 2013 03:44:52 AM JST
get-buffer-create 
* Thu 19 Sep 2013 03:46:12 AM JST
           
* Thu 19 Sep 2013 03:48:06 AM JST
erroneous
* Thu 19 Sep 2013 03:53:52 AM JST
    # create mail form
    sleep(300) # 5 min
    while 1:
        sleep(5)
        if psutil.cpu_percent(interval=1, percpu=False) < 20.0:
            EVELEMENT['mailto'] = GMAIL.get('taka16daily')
            EVELEMENT['subject'] = 'Daily Routines'
            EVELEMENT['body'] = 'WEATHER: \nRECIPE: ' + ', '.join(menus) + '\n'
            cmd = EVOLUTION.get('fmailformat') % EVELEMENT
            print(cmd)
            os.system(cmd)
            break


* Thu 19 Sep 2013 03:54:58 AM JST
    # parse file name as extracted extension
    menus = []
    for m in os.listdir(today_path):
        fname, ext = os.path.splitext(m)
        menus.append(fname)


* Thu 19 Sep 2013 03:55:31 AM JST
    # parse file name as extracted extension
    menus = []
    for m in os.listdir(today_path):
        fname, ext = os.path.splitext(m)
        menus.append(fname)

    # create mail form
    sleep(300) # 5 min
    while 1:
        sleep(5)
        if psutil.cpu_percent(interval=1, percpu=False) < 20.0:
            EVELEMENT['mailto'] = GMAIL.get('taka16daily')
            EVELEMENT['subject'] = 'Daily Routines'
            EVELEMENT['body'] = 'WEATHER: \nRECIPE: ' + ', '.join(menus) + '\n'
            cmd = EVOLUTION.get('fmailformat') % EVELEMENT
            print(cmd)
            os.system(cmd)
            break


* Thu 19 Sep 2013 02:18:38 PM JST
(skip-chars-backward " \t")
* Thu 19 Sep 2013 02:19:06 PM JST
(before-cha)
* Thu 19 Sep 2013 02:19:23 PM JST
(before-char)
* Thu 19 Sep 2013 02:20:17 PM JST
(before-)
* Thu 19 Sep 2013 02:20:51 PM JST
char-before
* Thu 19 Sep 2013 02:21:31 PM JST
(char-before)
* Thu 19 Sep 2013 02:21:53 PM JST
(progn (end-of-line) (skip-chars-backward " \t") (insert ":"))
* Thu 19 Sep 2013 02:22:13 PM JST
(char-before)
* Thu 19 Sep 2013 02:22:33 PM JST
(eq (char-before) 58)
* Thu 19 Sep 2013 02:22:54 PM JST
(progn (end-of-line) (skip-chars-backward " \t") (unless (eq (char-before) 58) (insert ":")))
* Thu 19 Sep 2013 02:25:57 PM JST
(unless (eq (char-before) 58) (insert ":"))
* Thu 19 Sep 2013 02:32:25 PM JST
lisp-interaction-mode
* Thu 19 Sep 2013 02:34:43 PM JST
unless
* Thu 19 Sep 2013 02:34:46 PM JST
time
* Thu 19 Sep 2013 02:34:46 PM JST
init-time
* Thu 19 Sep 2013 02:34:46 PM JST
before-init-time
* Thu 19 Sep 2013 02:36:32 PM JST
bound-and-true-p
* Thu 19 Sep 2013 02:36:47 PM JST

* Thu 19 Sep 2013 02:36:48 PM JST
mode
* Thu 19 Sep 2013 02:36:49 PM JST
complete-mode
* Thu 19 Sep 2013 02:36:49 PM JST
auto-complete-mode
* Thu 19 Sep 2013 02:36:54 PM JST
                  
* Thu 19 Sep 2013 02:37:01 PM JST
(bound-and-true-p auto-complete-mode)
* Thu 19 Sep 2013 02:37:28 PM JST
(interactiv)
* Thu 19 Sep 2013 02:38:31 PM JST
(if (bound-and-true-p auto-complete-mode)
    (setq ac-sources (append ac-sources '(ac-emacs-lisp-features
                                          ac-source-functions
                                          ac-source-variables
                                          ac-source-symbols))))
* Thu 19 Sep 2013 02:39:56 PM JST
load-scratch-auto-complete
* Thu 19 Sep 2013 02:40:17 PM JST
  
* Thu 19 Sep 2013 02:41:09 PM JST
  
* Thu 19 Sep 2013 02:41:23 PM JST
(ac-sou)
* Thu 19 Sep 2013 02:41:28 PM JST
(be)
* Thu 19 Sep 2013 02:41:41 PM JST
(before-)
* Thu 19 Sep 2013 02:44:47 PM JST
ac
* Thu 19 Sep 2013 02:44:49 PM JST
ac-sources
* Thu 19 Sep 2013 02:48:01 PM JST
 
* Thu 19 Sep 2013 02:48:30 PM JST
ac-emacs-lisp-features ac-source-yasnippet ac-source-words-in-same-mode-buffers ac-source-functions ac-source-variables ac-source-symbols)
* Thu 19 Sep 2013 02:48:54 PM JST
(dolist (acs '(ac-emacs-lisp-features ac-source-functions ac-source-variables ac-source-symbols))
  (add-to-list 'ac-sources acs 'append))
* Thu 19 Sep 2013 02:50:37 PM JST
(message "Loading ac-sources for scratch.")
* Thu 19 Sep 2013 02:51:12 PM JST
(defun )
* Thu 19 Sep 2013 02:51:35 PM JST
(end)
* Thu 19 Sep 2013 02:51:58 PM JST
(end-of-line )
* Thu 19 Sep 2013 02:56:54 PM JST
(defun scratch-load-ac-sources-after-auto-complete-predefine ()
  "Load ac-sources after load auto-complete."
  (save-window-excursion )
  )
* Thu 19 Sep 2013 02:57:27 PM JST
(if (get-buffer "*scratch*")
      (switch-to-buffer "*scratch*"))
* Thu 19 Sep 2013 02:58:03 PM JST
scratch-load-ac-sources-after-auto-complete-predefine
* Thu 19 Sep 2013 03:00:46 PM JST
(scratch-load-ac-sources-after-auto-complete-predefine)
* Thu 19 Sep 2013 03:01:16 PM JST
(defun scratch-load-ac-sources-after-auto-complete-predefine ()
  "Load ac-sources after load auto-complete."
  (save-window-excursion
    (if (get-buffer "*scratch*")
        (switch-to-buffer "*scratch*"))
    (load-scratch-auto-complete))
  )
* Thu 19 Sep 2013 03:01:48 PM JST
scratch-load-ac-sources-after-auto-complete-predefine
* Thu 19 Sep 2013 03:06:05 PM JST

* Thu 19 Sep 2013 03:06:05 PM JST

* Thu 19 Sep 2013 03:06:05 PM JST
(eval-after-load 'auto-complete '(scratch-load-ac-sources-after-auto-complete-predefine))

* Thu 19 Sep 2013 03:11:17 PM JST
try:
	import Xlib
except:
	import os
	print "Run 'sudo apt-get install python-xlib -y'"
	os.system('sudo apt-get install python-xlib -y')
	try:
		import Xlib
	except:
		sys.exit(0)
import Xlib.display
import Xlib.X
import Xlib.XK
import Xlib.protocol.event
import Xlib.ext.xtest

display = Xlib.display.Display()

special_X_keysyms = {
	' ' : "space",
	'\t' : "Tab",
	'\n' : "Return",  # for some reason this needs to be cr, not lf
	'\r' : "Return",
	'\e' : "Escape",
	'!' : "exclam",
	'#' : "numbersign",
	'%' : "percent",
	'$' : "dollar",
	'&' : "ampersand",
	'"' : "quotedbl",
	'\'' : "apostrophe",
	'(' : "parenleft",
	')' : "parenright",
	'*' : "asterisk",
	'=' : "equal",
	'+' : "plus",
	',' : "comma",
	'-' : "minus",
	'.' : "period",
	'/' : "slash",
	':' : "colon",
	';' : "semicolon",
	'<' : "less",
	'>' : "greater",
	'?' : "question",
	'@' : "at",
	'[' : "bracketleft",
	']' : "bracketright",
	'\\' : "backslash",
	'^' : "asciicircum",
	'_' : "underscore",
	'`' : "grave",
	'{' : "braceleft",
	'|' : "bar",
	'}' : "braceright",
	'~' : "asciitilde"
}


def get_keysym(ch) :
	keysym = Xlib.XK.string_to_keysym(ch)
	if keysym == 0 :
		# Unfortunately, although this works to get the correct keysym
		# i.e. keysym for '#' is returned as "numbersign"
		# the subsequent display.keysym_to_keycode("numbersign") is 0.
		keysym = Xlib.XK.string_to_keysym(special_X_keysyms[ch])
	return keysym

def char_to_keycode(ch) :
	keysym = get_keysym(ch)
#	print keysym
	keycode = display.keysym_to_keycode(keysym)
#	if keycode == 0 :
#		print "Sorry, can't map", ch
#	print keycode
	return keycode

ctrlkey=display.keysym_to_keycode(Xlib.XK.XK_Control_L)
altkey=display.keysym_to_keycode(Xlib.XK.XK_Alt_L)
shiftkey=display.keysym_to_keycode(Xlib.XK.XK_Shift_L)

def sendkey(keystroke):
	ctrl = alt = shift = 0
	key = ""
	splitted = keystroke.split(" ")
	for stroke in splitted:
		if stroke == "Ctrl":
			ctrl = 1
		elif stroke == "Shift":
			shift = 1
		elif stroke == "Alt":
			alt = 1
		elif stroke == "Space": 
			key = char_to_keycode(" ")
		else: # an ordinary key
			key = char_to_keycode(stroke)
	if ctrl==1:
		Xlib.ext.xtest.fake_input(display, Xlib.X.KeyPress, ctrlkey)
	if alt==1:
		Xlib.ext.xtest.fake_input(display, Xlib.X.KeyPress, altkey)
	if shift==1:
		Xlib.ext.xtest.fake_input(display, Xlib.X.KeyPress, shiftkey)
	Xlib.ext.xtest.fake_input(display, Xlib.X.KeyPress, key)
	Xlib.ext.xtest.fake_input(display, Xlib.X.KeyRelease, key)
	if ctrl==1:
		Xlib.ext.xtest.fake_input(display, Xlib.X.KeyRelease, ctrlkey)
	if alt==1:
		Xlib.ext.xtest.fake_input(display, Xlib.X.KeyRelease, altkey)
	if shift==1:
		Xlib.ext.xtest.fake_input(display, Xlib.X.KeyRelease, shiftkey)
	display.sync()
* Thu 19 Sep 2013 03:11:22 PM JST

* Thu 19 Sep 2013 03:11:22 PM JST

* Thu 19 Sep 2013 03:11:22 PM JST
#	print keysym

* Thu 19 Sep 2013 03:11:22 PM JST

* Thu 19 Sep 2013 03:11:22 PM JST

* Thu 19 Sep 2013 03:11:22 PM JST
#	if keycode == 0 :

* Thu 19 Sep 2013 03:11:23 PM JST
#	if keycode == 0 :

* Thu 19 Sep 2013 03:11:23 PM JST
#	if keycode == 0 :
#		print "Sorry, can't map", ch

* Thu 19 Sep 2013 03:11:23 PM JST
#	if keycode == 0 :
#		print "Sorry, can't map", ch

* Thu 19 Sep 2013 03:11:23 PM JST
#	if keycode == 0 :
#		print "Sorry, can't map", ch
#	print keycode

* Thu 19 Sep 2013 03:11:32 PM JST

* Thu 19 Sep 2013 03:11:32 PM JST

* Thu 19 Sep 2013 03:11:32 PM JST
try:

* Thu 19 Sep 2013 03:14:51 PM JST
http://ubuntueasysetuper.googlecode.com/svn/trunk/FutureWork/sendkey.py
* Thu 19 Sep 2013 03:15:13 PM JST
import Xlib
import Xlib.display
import Xlib.X
import Xlib.XK
import Xlib.protocol.event
import Xlib.ext.xtest

display = Xlib.display.Display()

special_X_keysyms = {
	' ' : "space",
	'\t' : "Tab",
	'\n' : "Return",  # for some reason this needs to be cr, not lf
	'\r' : "Return",
	'\e' : "Escape",
	'!' : "exclam",
	'#' : "numbersign",
	'%' : "percent",
	'$' : "dollar",
	'&' : "ampersand",
	'"' : "quotedbl",
	'\'' : "apostrophe",
	'(' : "parenleft",
	')' : "parenright",
	'*' : "asterisk",
	'=' : "equal",
	'+' : "plus",
	',' : "comma",
	'-' : "minus",
	'.' : "period",
	'/' : "slash",
	':' : "colon",
	';' : "semicolon",
	'<' : "less",
	'>' : "greater",
	'?' : "question",
	'@' : "at",
	'[' : "bracketleft",
	']' : "bracketright",
	'\\' : "backslash",
	'^' : "asciicircum",
	'_' : "underscore",
	'`' : "grave",
	'{' : "braceleft",
	'|' : "bar",
	'}' : "braceright",
	'~' : "asciitilde"
}


def get_keysym(ch) :
	keysym = Xlib.XK.string_to_keysym(ch)
	if keysym == 0 :
		# Unfortunately, although this works to get the correct keysym
		# i.e. keysym for '#' is returned as "numbersign"
		# the subsequent display.keysym_to_keycode("numbersign") is 0.
		keysym = Xlib.XK.string_to_keysym(special_X_keysyms[ch])
	return keysym

def char_to_keycode(ch) :
	keysym = get_keysym(ch)
	keycode = display.keysym_to_keycode(keysym)
	return keycode

ctrlkey=display.keysym_to_keycode(Xlib.XK.XK_Control_L)
altkey=display.keysym_to_keycode(Xlib.XK.XK_Alt_L)
shiftkey=display.keysym_to_keycode(Xlib.XK.XK_Shift_L)

def sendkey(keystroke):
	ctrl = alt = shift = 0
	key = ""
	splitted = keystroke.split(" ")
	for stroke in splitted:
		if stroke == "Ctrl":
			ctrl = 1
		elif stroke == "Shift":
			shift = 1
		elif stroke == "Alt":
			alt = 1
		elif stroke == "Space":
			key = char_to_keycode(" ")
		else: # an ordinary key
			key = char_to_keycode(stroke)
	if ctrl==1:
		Xlib.ext.xtest.fake_input(display, Xlib.X.KeyPress, ctrlkey)
	if alt==1:
		Xlib.ext.xtest.fake_input(display, Xlib.X.KeyPress, altkey)
	if shift==1:
		Xlib.ext.xtest.fake_input(display, Xlib.X.KeyPress, shiftkey)
	Xlib.ext.xtest.fake_input(display, Xlib.X.KeyPress, key)
	Xlib.ext.xtest.fake_input(display, Xlib.X.KeyRelease, key)
	if ctrl==1:
		Xlib.ext.xtest.fake_input(display, Xlib.X.KeyRelease, ctrlkey)
	if alt==1:
		Xlib.ext.xtest.fake_input(display, Xlib.X.KeyRelease, altkey)
	if shift==1:
		Xlib.ext.xtest.fake_input(display, Xlib.X.KeyRelease, shiftkey)
	display.sync()

* Thu 19 Sep 2013 04:01:15 PM JST
(purecopy "\\.py\\'")
* Thu 19 Sep 2013 04:01:39 PM JST
(cons (purecopy "\\.py\\'")  'python-mode)
* Thu 19 Sep 2013 04:06:48 PM JST
mc/cmds-to-run-for-all
* Thu 19 Sep 2013 04:06:56 PM JST
mc/cmds-to-run-once
* Thu 19 Sep 2013 04:07:08 PM JST
(t1-parence)
* Thu 19 Sep 2013 09:12:56 PM JST
def sendkey(keystroke):
    ctrl = alt = shift = 0
    key = ""
    splitted = keystroke.split(" ")
    for stroke in splitted:
        if stroke == "Ctrl":
            ctrl = 1
        elif stroke == "Shift":
            shift = 1
        elif stroke == "Alt":
            alt = 1
        elif stroke == "Space":
            key = char_to_keycode(" ")
        else: # an ordinary key
            key = char_to_keycode(stroke)
    if ctrl==1:
        Xlib.ext.xtest.fake_input(display, Xlib.X.KeyPress, ctrlkey)
    if alt==1:
        Xlib.ext.xtest.fake_input(display, Xlib.X.KeyPress, altkey)
    if shift==1:
        Xlib.ext.xtest.fake_input(display, Xlib.X.KeyPress, shiftkey)
    Xlib.ext.xtest.fake_input(display, Xlib.X.KeyPress, key)
    Xlib.ext.xtest.fake_input(display, Xlib.X.KeyRelease, key)
    if ctrl==1:
        Xlib.ext.xtest.fake_input(display, Xlib.X.KeyRelease, ctrlkey)
    if alt==1:
        Xlib.ext.xtest.fake_input(display, Xlib.X.KeyRelease, altkey)
    if shift==1:
        Xlib.ext.xtest.fake_input(display, Xlib.X.KeyRelease, shiftkey)
    display.sync()

* Thu 19 Sep 2013 09:13:51 PM JST

* Thu 19 Sep 2013 09:13:51 PM JST

* Thu 19 Sep 2013 09:13:51 PM JST
    ctrl = alt = shift = 0

* Thu 19 Sep 2013 09:15:26 PM JST
keystroke.split(" ")
* Thu 19 Sep 2013 09:15:30 PM JST

* Thu 19 Sep 2013 09:15:30 PM JST

* Thu 19 Sep 2013 09:15:30 PM JST
    splitted = 

* Thu 19 Sep 2013 09:20:19 PM JST
    for flag, spkey in [(ctrl, ctrlkey), (alt, altkey), (shift, shiftkey)]:
        if flag is True:
            Xlib.ext.xtest.fake_input(display, Xlib.X.KeyPress, spkey)

* Thu 19 Sep 2013 09:21:38 PM JST
[(ctrl, ctrlkey), (alt, altkey), (shift, shiftkey)]
* Thu 19 Sep 2013 09:42:57 PM JST

* Thu 19 Sep 2013 09:42:57 PM JST

* Thu 19 Sep 2013 09:42:57 PM JST
    for stroke in keystroke.split(" "):

* Thu 19 Sep 2013 09:42:58 PM JST
    for stroke in keystroke.split(" "):

* Thu 19 Sep 2013 09:42:58 PM JST
    for stroke in keystroke.split(" "):
        if stroke == "Space":

* Thu 19 Sep 2013 09:43:00 PM JST

* Thu 19 Sep 2013 09:43:00 PM JST

* Thu 19 Sep 2013 09:43:00 PM JST
        else: # an ordinary key

* Thu 19 Sep 2013 09:43:00 PM JST
        else: # an ordinary key

* Thu 19 Sep 2013 09:43:00 PM JST
        else: # an ordinary key
            key = char_to_keycode(stroke)

* Thu 19 Sep 2013 09:43:03 PM JST
keystroke
* Thu 19 Sep 2013 09:43:07 PM JST

* Thu 19 Sep 2013 09:43:07 PM JST

* Thu 19 Sep 2013 09:43:07 PM JST
    key = ""

* Thu 19 Sep 2013 09:43:08 PM JST
char_to_keycode(" "
* Thu 19 Sep 2013 09:50:56 PM JST
[(ctrl, CTRL_L), (alt, ALT_L), (shift, SHIFT_L)]
* Thu 19 Sep 2013 09:52:47 PM JST

* Thu 19 Sep 2013 09:52:47 PM JST

* Thu 19 Sep 2013 09:52:47 PM JST
    key = char_to_keycode(key)

* Thu 19 Sep 2013 10:03:27 PM JST
True
* Thu 19 Sep 2013 10:03:27 PM JST
ctrl=True
* Thu 19 Sep 2013 10:06:13 PM JST
display = Xlib.display.Display()
* Thu 19 Sep 2013 10:06:18 PM JST
import Xlib.display
* Thu 19 Sep 2013 10:06:27 PM JST
display = Xlib.display.Display()
* Thu 19 Sep 2013 10:42:59 PM JST

* Thu 19 Sep 2013 10:42:59 PM JST

* Thu 19 Sep 2013 10:42:59 PM JST
    if ctrl or :

* Thu 19 Sep 2013 10:43:01 PM JST

* Thu 19 Sep 2013 10:43:01 PM JST

* Thu 19 Sep 2013 10:43:01 PM JST
    if ctrl or alt or shift:

* Thu 19 Sep 2013 11:09:07 PM JST
/tmp/junk/
* Thu 19 Sep 2013 11:11:07 PM JST

* Thu 19 Sep 2013 11:11:08 PM JST
chrome
* Thu 19 Sep 2013 11:11:09 PM JST
chrome/chrome
* Thu 19 Sep 2013 11:11:09 PM JST
google/chrome/chrome
* Thu 19 Sep 2013 11:11:09 PM JST
opt/google/chrome/chrome
* Thu 19 Sep 2013 11:15:45 PM JST
edit 
* Thu 19 Sep 2013 11:26:41 PM JST
None
* Thu 19 Sep 2013 11:26:49 PM JST
CHROME_PATH
* Thu 19 Sep 2013 11:27:05 PM JST
CHROME_PATH
* Thu 19 Sep 2013 11:27:10 PM JST
CHROME_PATH
* Thu 19 Sep 2013 11:27:14 PM JST
CHROME_PATH
* Thu 19 Sep 2013 11:32:35 PM JST
test
* Thu 19 Sep 2013 11:32:45 PM JST

* Thu 19 Sep 2013 11:32:45 PM JST

* Thu 19 Sep 2013 11:32:45 PM JST
                        nargs=0,

* Thu 19 Sep 2013 11:33:07 PM JST
opts.path
* Thu 19 Sep 2013 11:33:12 PM JST

* Thu 19 Sep 2013 11:33:12 PM JST

* Thu 19 Sep 2013 11:33:12 PM JST
    print()

* Thu 19 Sep 2013 11:35:27 PM JST
bin_
* Thu 19 Sep 2013 11:36:44 PM JST

* Thu 19 Sep 2013 11:36:45 PM JST

* Thu 19 Sep 2013 11:36:45 PM JST
CHROME_PATH = '/tmp/junk/chrome'

* Thu 19 Sep 2013 11:43:47 PM JST
os.path.basename
* Thu 19 Sep 2013 11:46:00 PM JST
    tmpdir = tempfile.mkdtemp()
    shutil.copy2(chromepath, tmpdir)
    print('copy: {0} => {1}'.format(chromepath,
                              os.path.join(tmpdir, os.path.basename(chromepath))))

* Thu 19 Sep 2013 11:46:17 PM JST
                              
* Fri 20 Sep 2013 12:44:10 AM JST
python_path="/usr/bin/python"

* Fri 20 Sep 2013 12:45:02 AM JST

* Fri 20 Sep 2013 12:45:05 AM JST
path
* Fri 20 Sep 2013 12:45:05 AM JST
python_path
* Fri 20 Sep 2013 12:51:19 AM JST
        with King(verbose=self._verbose) as ki:
            if not ki.ismount():
                raise ki.MountError('Data is not mounted.')

* Fri 20 Sep 2013 12:51:30 AM JST

* Fri 20 Sep 2013 12:51:30 AM JST

* Fri 20 Sep 2013 12:51:30 AM JST
        if not ki.ismount():

* Fri 20 Sep 2013 12:51:31 AM JST
        if not ki.ismount():

* Fri 20 Sep 2013 12:51:31 AM JST
        if not ki.ismount():
            raise ki.MountError('Data is not mounted.')

* Fri 20 Sep 2013 12:53:40 AM JST
king
* Fri 20 Sep 2013 12:54:09 AM JST
path
* Fri 20 Sep 2013 12:54:09 AM JST
script_path
* Fri 20 Sep 2013 12:55:04 AM JST

* Fri 20 Sep 2013 12:55:04 AM JST

* Fri 20 Sep 2013 12:55:04 AM JST
python ~/.pylib/king.py --halt

* Fri 20 Sep 2013 12:56:10 AM JST
def _main():
    parser = argparse.ArgumentParser(description="""\
    This script handle King server.""")

    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,
                        help='Show version Strings.')

    parser.add_argument('-s', '--silent',
                        dest='silent',
                        action='store_false',
                        default=True,
                        required=False,
                        # (yas/expand-link "argparse_other_options" t)
                        help='No verbosly')

    # parser.add_argument('-v', '--verbose',
    #                     dest='verbose',
    #                     action='count',
    #                     default=0,
    #                     help='A lot of messages.')

    parser.add_argument('-p', '--pave',
                        dest='pave',
                        action='store_true',
                        default=False,
                        required=False,
                        help='Pave for king server.')

    parser.add_argument('--shutdown', '--halt',
                        dest='halt',
                        action='store_true',
                        default=False,
                        required=False,
                        help='Shutdown king server.')

    parser.add_argument('--no-decrypt',
                        dest='no_decrypt',
                        action='store_false',
                        default=True,
                        required=False,
                        help='No decrypt flag.')

    parser.add_argument('-w', '--wol',
                        dest='wol',
                        action='store_true',
                        default=False,
                        required=False,
                        help='Send Wake On Lan packet.')

    parser.add_argument('-a', '--check-active',
                        dest='isactive',
                        action='store_true',
                        default=False,
                        required=False,
                        help='Check running server.')

    parser.add_argument('-o', '--onlyssh-pave',
                    dest='onlyssh_pave',
                    action='store_true',
                    default=False,
                    required=False,
                    # (yas/expand-link "argparse_other_options" t)
                    help='Pave ssh agent and portforward.')

    # (yas/expand-link "argparse_add_argument" t)

    args = parser.parse_args()
    with King(verbose=args.silent) as ki:
        if args.onlyssh_pave:
            ki.script._pave_rook()
            ki.script._pave_tunnel()
            sys.exit(0)
        if args.halt:
            ki.halt()
        elif args.pave:
            ki.script.pave(decrypt=args.no_decrypt)
        elif args.wol:
            ki.script.wol()
        elif args.isactive:
            if ki.isactive():
                print "ACTIVE"
            else:
                print "DOWN"
        else:
            ki.script.pave(decrypt=args.no_decrypt)


if __name__ == '__main__':
    _main()

* Fri 20 Sep 2013 12:56:45 AM JST
    parser = argparse.ArgumentParser(description="""\
    This script handle King server.""")

    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,
                        help='Show version Strings.')

    parser.add_argument('-s', '--silent',
                        dest='silent',
                        action='store_false',
                        default=True,
                        required=False,
                        # (yas/expand-link "argparse_other_options" t)
                        help='No verbosly')

    # parser.add_argument('-v', '--verbose',
    #                     dest='verbose',
    #                     action='count',
    #                     default=0,
    #                     help='A lot of messages.')

    parser.add_argument('-p', '--pave',
                        dest='pave',
                        action='store_true',
                        default=False,
                        required=False,
                        help='Pave for king server.')

    parser.add_argument('--shutdown', '--halt',
                        dest='halt',
                        action='store_true',
                        default=False,
                        required=False,
                        help='Shutdown king server.')

    parser.add_argument('--no-decrypt',
                        dest='no_decrypt',
                        action='store_false',
                        default=True,
                        required=False,
                        help='No decrypt flag.')

    parser.add_argument('-w', '--wol',
                        dest='wol',
                        action='store_true',
                        default=False,
                        required=False,
                        help='Send Wake On Lan packet.')

    parser.add_argument('-a', '--check-active',
                        dest='isactive',
                        action='store_true',
                        default=False,
                        required=False,
                        help='Check running server.')

    parser.add_argument('-o', '--onlyssh-pave',
                    dest='onlyssh_pave',
                    action='store_true',
                    default=False,
                    required=False,
                    # (yas/expand-link "argparse_other_options" t)
                    help='Pave ssh agent and portforward.')

    # (yas/expand-link "argparse_add_argument" t)


* Fri 20 Sep 2013 12:57:00 AM JST

* Fri 20 Sep 2013 12:57:00 AM JST

* Fri 20 Sep 2013 12:57:00 AM JST
    args = parser.parse_args()

* Fri 20 Sep 2013 12:57:02 AM JST
    with King(verbose=args.silent) as ki:
        if args.onlyssh_pave:
            ki.script._pave_rook()
            ki.script._pave_tunnel()
            sys.exit(0)
        if args.halt:
            ki.halt()
        elif args.pave:
            ki.script.pave(decrypt=args.no_decrypt)
        elif args.wol:
            ki.script.wol()
        elif args.isactive:
            if ki.isactive():
                print "ACTIVE"
            else:
                print "DOWN"
        else:
            ki.script.pave(decrypt=args.no_decrypt)


* Fri 20 Sep 2013 12:57:31 AM JST
args
* Fri 20 Sep 2013 12:57:34 AM JST
args
* Fri 20 Sep 2013 12:57:36 AM JST
args
* Fri 20 Sep 2013 12:59:43 AM JST
python_path="/usr/bin/python"
modulename="king"

[ -x $python_path ] || exit 1

$python_path -m $modulename --halt

exit 0

* Fri 20 Sep 2013 12:59:53 AM JST

* Fri 20 Sep 2013 12:59:53 AM JST

* Fri 20 Sep 2013 12:59:53 AM JST
python ~/.pylib/king.py --onlyssh-pave

* Fri 20 Sep 2013 01:58:31 AM JST

* Fri 20 Sep 2013 01:58:31 AM JST

* Fri 20 Sep 2013 01:58:31 AM JST
import argparse

* Fri 20 Sep 2013 01:58:36 AM JST

* Fri 20 Sep 2013 01:58:36 AM JST

* Fri 20 Sep 2013 01:58:36 AM JST
import sys

* Fri 20 Sep 2013 02:07:39 AM JST
junk.
* Fri 20 Sep 2013 02:07:40 AM JST
020739.junk.
* Fri 20 Sep 2013 02:07:40 AM JST
20-020739.junk.
* Fri 20 Sep 2013 02:07:40 AM JST
09-20-020739.junk.
* Fri 20 Sep 2013 02:07:41 AM JST
2013-09-20-020739.junk.
* Fri 20 Sep 2013 02:22:16 AM JST
import Xlib.display
* Fri 20 Sep 2013 02:22:30 AM JST
display = Xlib.display.Display()
* Fri 20 Sep 2013 02:22:47 AM JST
screen = display.screen()
* Fri 20 Sep 2013 02:22:54 AM JST
root = screen.root
* Fri 20 Sep 2013 02:23:00 AM JST
tree = root.query_tree()
* Fri 20 Sep 2013 02:23:10 AM JST
wins = tree.children
* Fri 20 Sep 2013 02:23:46 AM JST
for win in wins:
* Fri 20 Sep 2013 02:23:52 AM JST
win.get_wm_name()
* Fri 20 Sep 2013 02:26:22 AM JST
display = Xlib.display.Display()
* Fri 20 Sep 2013 02:26:27 AM JST
screen = display.screen()
* Fri 20 Sep 2013 03:00:16 AM JST
Xlib.ext.xtest.fake_input
* Fri 20 Sep 2013 03:10:22 AM JST
    
* Fri 20 Sep 2013 03:15:16 AM JST
right
* Fri 20 Sep 2013 04:03:15 AM JST
ScreenSaverActive
* Fri 20 Sep 2013 02:41:57 PM JST
[Xlib.protocol.rq.DictWrapper({'min_installed_maps': 1, 'max_installed_maps': 1, 'current_input_mask': 8028207, 'default_colormap': <Xlib.xobject.colormap.Colormap 0x00000020>, 'width_in_pixels': 2960, 'height_in_pixels': 1050, 'height_in_mms': 303, 'white_pixel': 65535, 'width_in_mms': 835, 'backing_store': 0, 'save_unders': 0, 'root_depth': 16, 'black_pixel': 0, 'root_visual': 33, 'root': <Xlib.display.Window 0x000001e2>, 'allowed_depths': [Xlib.protocol.rq.DictWrapper({'visuals': [Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 33, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 34, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 244, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 245, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 246, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 247, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 248, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 249, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 250, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 251, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 252, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 253, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 254, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 255, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 256, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 257, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 258, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 259, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 260, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 261, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 262, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 263, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 264, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 265, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 266, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 4}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 267, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 268, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 269, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 270, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 271, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 272, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 273, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 274, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 275, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 276, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 277, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 278, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 279, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 280, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 281, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 282, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 283, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 284, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 285, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 286, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 287, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 288, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5}), Xlib.protocol.rq.DictWrapper({'colormap_entries': 64, 'visual_id': 289, 'blue_mask': 31, 'green_mask': 2016, 'red_mask': 63488, 'bits_per_rgb_value': 6, 'visual_class': 5})], 'depth': 16}), Xlib.protocol.rq.DictWrapper({'visuals': [], 'depth': 1}), Xlib.protocol.rq.DictWrapper({'visuals': [], 'depth': 4}), Xlib.protocol.rq.DictWrapper({'visuals': [], 'depth': 8}), Xlib.protocol.rq.DictWrapper({'visuals': [], 'depth': 15}), Xlib.protocol.rq.DictWrapper({'visuals': [], 'depth': 24}), Xlib.protocol.rq.DictWrapper({'visuals': [Xlib.protocol.rq.DictWrapper({'colormap_entries': 256, 'visual_id': 97, 'blue_mask': 255, 'green_mask': 65280, 'red_mask': 16711680, 'bits_per_rgb_value': 8, 'visual_class': 4})], 'depth': 32})]})]
* Fri 20 Sep 2013 03:01:35 PM JST
def _options_maker():
    parser = argparse.ArgumentParser(description="""Overview.""")
    parser.add_argument('--version',
                        dest='version',
                        action='version',
                        version=__version__,
                        help='Version Strings.')
    parser.add_argument('file',
                        action='store',
                        help='File name.')
                        # (yas/expand-link "argparse_add_argument")
    return parser.parse_args()


def _main():
    """Main function."""
    # check Arguments
    args = _options_maker()
    target = _os.path.abspath(_os.path.normcase(args.file))
    # if target does not exists raise Error
    path_checker(target)

    # dst_dir
    # set files directory, if target is a file.
    # set as it, if target is a directory.
    if _os.path.isfile(target):
        dst_dir = _os.path.splitext(target)[0]
    elif _os.path.isdir(target):
        dst_dir = target

    # make destination directory
    if _os.path.isfile(target) and not _os.path.exists(dst_dir):
        _os.mkdir(dst_dir)

    view = Overview(target, dst_dir)
    # pyreverse
    # my_pyreverse(target, dst_dir)
    # my_pyreverse(target, dst_dir, detail=False)
    view.pyreverse()

    # epydoc
    my_epydoc(target, dst_dir)
    view.epydoc()

    # doxygen
    # orig_dir = _os.getcwd()
    # try:
        # my_doxygen(target, dst_dir)
    # finally:
        # _os.chdir(orig_dir)
    view.doxygen()

if __name__ == '__main__':
    _main()


* Fri 20 Sep 2013 03:03:00 PM JST

* Fri 20 Sep 2013 03:03:00 PM JST

* Fri 20 Sep 2013 03:03:00 PM JST
    target = _os.path.abspath(_os.path.normcase(args.file))

* Fri 20 Sep 2013 03:03:06 PM JST
args
* Fri 20 Sep 2013 03:03:14 PM JST

* Fri 20 Sep 2013 03:03:14 PM JST

* Fri 20 Sep 2013 03:03:14 PM JST
    # check Arguments

* Fri 20 Sep 2013 03:03:14 PM JST
    # check Arguments

* Fri 20 Sep 2013 03:03:14 PM JST
    # check Arguments
    args = _options_maker()

* Fri 20 Sep 2013 03:03:15 PM JST
    # check Arguments
    args = _options_maker()

* Fri 20 Sep 2013 03:03:16 PM JST
    # check Arguments
    args = _options_maker()
    # if target does not exists raise Error

* Fri 20 Sep 2013 03:03:20 PM JST
    path_checker(target)
* Fri 20 Sep 2013 03:03:37 PM JST
def path_checker(path):
    """Check exists path. If not exists raise error.

    @Arguments:
    - `path`: file or directory
    """
    if not _os.path.exists(path):
        raise IOError('File does not exists: %s' % _os.path.abspath(path))


* Fri 20 Sep 2013 03:04:36 PM JST
    parser.add_argument('file',
                        action='store',
                        help='File name.')
                        # (yas/expand-link "argparse_add_argument")

* Fri 20 Sep 2013 03:04:57 PM JST
    if _os.path.isfile(target):
        dst_dir = _os.path.splitext(target)[0]
    elif _os.path.isdir(target):
        dst_dir = target


* Fri 20 Sep 2013 03:05:17 PM JST
    # dst_dir
    # set files directory, if target is a file.
    # set as it, if target is a directory.
    # make destination directory
    if _os.path.isfile(target) and not _os.path.exists(dst_dir):
        _os.mkdir(dst_dir)

    view = Overview(target, dst_dir)
    # pyreverse
    # my_pyreverse(target, dst_dir)
    # my_pyreverse(target, dst_dir, detail=False)
    view.pyreverse()

    # epydoc
    my_epydoc(target, dst_dir)
    view.epydoc()

    # doxygen
    # orig_dir = _os.getcwd()
    # try:
        # my_doxygen(target, dst_dir)
    # finally:
        # _os.chdir(orig_dir)
    view.doxygen()

* Fri 20 Sep 2013 03:08:57 PM JST

* Fri 20 Sep 2013 03:08:57 PM JST

* Fri 20 Sep 2013 03:08:57 PM JST
import argparse

* Fri 20 Sep 2013 03:09:26 PM JST
overview
* Fri 20 Sep 2013 03:11:53 PM JST
/usr/share/pyshared/Xlib
* Fri 20 Sep 2013 03:55:07 PM JST
Xlib.display.Display().screen().root.query_tree().children
* Fri 20 Sep 2013 04:14:07 PM JST
get_wm_name()
* Fri 20 Sep 2013 04:14:08 PM JST
win.get_wm_name()
* Fri 20 Sep 2013 04:14:49 PM JST
None
* Fri 20 Sep 2013 04:19:05 PM JST
Xlib.display.Display().screen().root.query_tree().children
* Fri 20 Sep 2013 04:29:28 PM JST
display = Xlib.display.Display()
* Fri 20 Sep 2013 04:29:33 PM JST
screen = display.screen()
* Fri 20 Sep 2013 04:29:36 PM JST
root = screen.root
* Fri 20 Sep 2013 04:43:26 PM JST
Xlib.display.Display().get_input_focus().focus.get_wm_name()
* Fri 20 Sep 2013 04:44:56 PM JST
Xlib.display.Display().get_input_focus().focus.query_tree().parent.get_wm_name()
* Fri 20 Sep 2013 04:45:12 PM JST
.query_tree().parent.get_wm_name()
* Fri 20 Sep 2013 04:47:25 PM JST

* Fri 20 Sep 2013 04:47:25 PM JST

* Fri 20 Sep 2013 04:47:25 PM JST
        wmname

* Fri 20 Sep 2013 04:48:11 PM JST
getactivewindowname()
* Fri 20 Sep 2013 04:48:29 PM JST
return getactivewindow().get_wm_name()
* Fri 20 Sep 2013 05:22:55 PM JST
Xlib.display.Display()
* Fri 20 Sep 2013 05:29:55 PM JST
getactivewindowname()
* Fri 20 Sep 2013 05:36:35 PM JST
Xlib.display.Display().get_input_focus()
* Fri 20 Sep 2013 05:42:27 PM JST
get_geometry
* Fri 20 Sep 2013 05:44:26 PM JST
get_geometry
* Fri 20 Sep 2013 05:55:38 PM JST
query_pointer
* Fri 20 Sep 2013 06:03:59 PM JST
    for win in getwindows():
        klass = win.get_wm_class()
        win.get_wm_icon_name

        if klass is not None:
            yield klass

* Fri 20 Sep 2013 06:04:16 PM JST

* Fri 20 Sep 2013 06:04:16 PM JST

* Fri 20 Sep 2013 06:04:16 PM JST
        win.get_wm_icon_name

* Fri 20 Sep 2013 06:04:18 PM JST

* Fri 20 Sep 2013 06:04:19 PM JST

* Fri 20 Sep 2013 06:04:19 PM JST
        win.get_wm_icon_name

* Fri 20 Sep 2013 06:10:44 PM JST
    for win in getwindows():
        klass = win.get_wm_class()

        if klass is not None and klass == classname:
            yield win

* Fri 20 Sep 2013 06:11:04 PM JST
klass
* Fri 20 Sep 2013 06:11:08 PM JST
klass
* Fri 20 Sep 2013 06:11:13 PM JST
klass
* Fri 20 Sep 2013 06:11:22 PM JST
classname
* Fri 20 Sep 2013 06:12:13 PM JST
yield
* Fri 20 Sep 2013 06:12:27 PM JST
yield
* Fri 20 Sep 2013 06:13:49 PM JST
win.change_attributes(win_gravity=X.NorthWestGravity, bit_gravity=X.StaticGravity)
* Fri 20 Sep 2013 06:16:12 PM JST
mv = xobject.drawable.Window(display, win.)
* Fri 20 Sep 2013 06:18:07 PM JST
Xlib.display.Display()
* Fri 20 Sep 2013 10:16:22 PM JST
'_NET_SUPPORTING_WM_CHECK'
* Fri 20 Sep 2013 10:37:39 PM JST
getwindowbyname
* Fri 20 Sep 2013 10:43:26 PM JST
display.py
* Fri 20 Sep 2013 11:11:35 PM JST
create_resource_object
* Fri 20 Sep 2013 11:15:23 PM JST
comix = 
* Fri 20 Sep 2013 11:22:32 PM JST
create_resource_object
* Fri 20 Sep 2013 11:28:04 PM JST
windowIDs = root.get_full_property(display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
* Fri 20 Sep 2013 11:33:11 PM JST
root = display.screen().root
* Fri 20 Sep 2013 11:33:16 PM JST
windowIDs = root.get_full_property(display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
* Fri 20 Sep 2013 11:46:27 PM JST
win.get_wm_name()
* Fri 20 Sep 2013 11:50:09 PM JST

* Fri 20 Sep 2013 11:50:09 PM JST

* Fri 20 Sep 2013 11:50:09 PM JST
        print(win.get_wm_name())

* Fri 20 Sep 2013 11:50:19 PM JST
def getwindowbyname2(windowname):
    r"""SUMMARY

    @Arguments:
    - `windowname`:

    @Return:
    """
    display =  Xlib.display.Display()
    root = display.screen().root
    windowIDs = root.get_full_property(display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
    for id_ in windowIDs:
        win = display.create_resource_object('window', id_)
        if windowname == win.get_wm_name():
            return win

* Fri 20 Sep 2013 11:50:29 PM JST
windowname
* Fri 20 Sep 2013 11:50:36 PM JST
if windowname == 
* Fri 20 Sep 2013 11:50:37 PM JST
return win
* Sat 21 Sep 2013 01:14:01 AM JST
display =  Xlib.display.Display()
* Sat 21 Sep 2013 01:16:07 AM JST
getwindowbyname2(name)
* Sat 21 Sep 2013 01:16:10 AM JST
name
* Sat 21 Sep 2013 01:20:59 AM JST
panel
* Sat 21 Sep 2013 01:21:00 AM JST
xfce4-panel
* Sat 21 Sep 2013 01:22:35 AM JST
hange - Google Chrome
* Sat 21 Sep 2013 01:23:52 AM JST
w=getwindowbyname2('Comix')
* Sat 21 Sep 2013 01:23:58 AM JST
Comix
* Sat 21 Sep 2013 01:24:02 AM JST
hange - Google Chrome
* Sat 21 Sep 2013 01:35:03 AM JST
windowIDs = root.get_full_property(display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
* Sat 21 Sep 2013 01:35:15 AM JST
for id_ in windowIDs:
* Sat 21 Sep 2013 01:35:19 AM JST
win = display.create_resource_object('window', id_)
* Sat 21 Sep 2013 01:36:12 AM JST
display.create_resource_object('window', id_)
* Sat 21 Sep 2013 01:40:32 AM JST
win = display.create_resource_object('window', w.id)
* Sat 21 Sep 2013 01:45:52 AM JST
display.create_resource_object('window', id_)
* Sat 21 Sep 2013 01:46:09 AM JST
chrome.children[3].id
* Sat 21 Sep 2013 01:48:54 AM JST
winnamemoveresize(name, **args)
* Sat 21 Sep 2013 03:18:50 AM JST
getactivewindow()
* Sat 21 Sep 2013 03:19:17 AM JST
getactivewindowname
* Sat 21 Sep 2013 03:21:25 AM JST
Xlib.display.Display()
* Sat 21 Sep 2013 03:21:30 AM JST
display =  Xlib.display.Display()
* Sat 21 Sep 2013 03:21:33 AM JST
root = display.screen().root
* Sat 21 Sep 2013 03:21:37 AM JST
windowIDs = root.get_full_property(display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
* Sat 21 Sep 2013 03:21:52 AM JST
display.create_resource_object('window', id_)
* Sat 21 Sep 2013 03:23:40 AM JST
win = display.create_resource_object('window', w.id)
* Sat 21 Sep 2013 03:24:36 AM JST
get_full_property(display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
* Sat 21 Sep 2013 03:26:02 AM JST
getwindowsname2()
* Sat 21 Sep 2013 03:27:35 AM JST
getwindowbyname2(windowname)
* Sat 21 Sep 2013 03:27:38 AM JST
windowname
* Sat 21 Sep 2013 03:27:42 AM JST
python-xlib tab - Google Search - Google Chrome
* Sat 21 Sep 2013 03:42:31 AM JST
def getactivewindowname():
    r"""SUMMARY

    @Return:
    """
    return getactivewindow().get_wm_name()

* Sat 21 Sep 2013 03:42:50 AM JST
return 
* Sat 21 Sep 2013 03:42:54 AM JST
.get_wm_name()
* Sat 21 Sep 2013 03:49:56 AM JST
def getwindowsname2():
    r"""SUMMARY

    @Arguments:
    - `windowname`:

    @Return:
    """
    display =  Xlib.display.Display()
    root = display.screen().root
    windowIDs = root.get_full_property(display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
    for id_ in windowIDs:
        win = display.create_resource_object('window', id_)
        yield win.get_wm_name()

* Sat 21 Sep 2013 03:51:52 AM JST
def getwindowsclass2():
    r"""SUMMARY

    @Arguments:
    - `windowname`:

    @Return:
    """
    display =  Xlib.display.Display()
    root = display.screen().root
    windowIDs = root.get_full_property(display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
    for id_ in windowIDs:
        win = display.create_resource_object('window', id_)
        yield win.get_wm_class()

* Sat 21 Sep 2013 05:01:13 PM JST
print('{0:#^20}'.format('Pull backup king.'))
* Sat 21 Sep 2013 05:02:01 PM JST
print('{0:#^30}'.format(' Pull backup king '))
* Sat 21 Sep 2013 05:04:35 PM JST
VMWARE
* Sat 21 Sep 2013 05:08:55 PM JST
print('\n\n{0:#40}'.format(' Clean Downloads '))
* Sat 21 Sep 2013 05:09:07 PM JST

* Sat 21 Sep 2013 05:09:07 PM JST

* Sat 21 Sep 2013 05:09:07 PM JST
    print('Clean Bookamrks')

* Sat 21 Sep 2013 05:09:20 PM JST

* Sat 21 Sep 2013 05:09:20 PM JST

* Sat 21 Sep 2013 05:09:20 PM JST
import psutil

* Sat 21 Sep 2013 05:11:33 PM JST
    sbp.Popen([CMD.get('rm'), ' /root/Downloads/*.torrent'],
              stdout=sbp.PIPE, stderr=sbp.PIPE)

* Sat 21 Sep 2013 05:12:09 PM JST
               
* Sat 21 Sep 2013 05:12:42 PM JST
    with king.King(verbose=True) as ki:
        ki.script.pave()
        if not ki.isactive():
            sys.exit('kidead')

* Sat 21 Sep 2013 05:13:19 PM JST
kidead')
* Sat 21 Sep 2013 05:13:20 PM JST
exit('kidead')
* Sat 21 Sep 2013 05:13:20 PM JST
sys.exit('kidead')
* Sat 21 Sep 2013 05:14:16 PM JST
ismount
* Sat 21 Sep 2013 05:14:26 PM JST
Decrypt
* Sat 21 Sep 2013 05:14:52 PM JST
## Pre Execute
#
def preexecute():
    r"""SUMMARY

    @Return:
    """
    with king.King(verbose=True) as ki:
        ki.script.pave()
        if not ki.ismount():
            raise StandardError('Not mounted remote /data.')


* Sat 21 Sep 2013 05:32:16 PM JST

* Sat 21 Sep 2013 05:32:16 PM JST

* Sat 21 Sep 2013 05:32:16 PM JST
        sbp.check_call(['/usr/bin/thunar', '/data/archive'])

* Sat 21 Sep 2013 05:35:48 PM JST
Downloads - File Manager
* Sat 21 Sep 2013 05:48:26 PM JST
display =  Xlib.display.Display()
* Sat 21 Sep 2013 05:48:44 PM JST
w = getwindowbyname2('Downloads - File Manager')
* Sat 21 Sep 2013 05:49:03 PM JST
display.create_resource_object('window', w.id)
* Sat 21 Sep 2013 05:49:32 PM JST
w.configure(x=2120, y=1, width=840, height=1024)
* Sat 21 Sep 2013 05:50:14 PM JST
downwin = myxlib.getwindowbyname2('Downloads - File Manager')
* Sat 21 Sep 2013 05:50:18 PM JST
Downloads
* Sat 21 Sep 2013 05:50:27 PM JST
archive - File Manager
* Sat 21 Sep 2013 05:50:38 PM JST
downwin
* Sat 21 Sep 2013 05:50:48 PM JST
dwin = display.create_resource_object('window', downwin.id)
* Sat 21 Sep 2013 05:50:53 PM JST
downwin
* Sat 21 Sep 2013 05:51:10 PM JST
dwin.configure(x=2120, y=1, width=840, height=1024)
* Sat 21 Sep 2013 05:59:25 PM JST
CLEANLIST = ['/root/.local/share/Trash/',
             '/data/.Trash-0/',
             '/media/Data/.Trash-0/']

* Sat 21 Sep 2013 05:59:47 PM JST
CLEANLIST = 
* Sat 21 Sep 2013 06:01:21 PM JST
print('Failed: Clean Trashs.')
* Sat 21 Sep 2013 06:01:31 PM JST
               
* Sat 21 Sep 2013 06:01:35 PM JST
'/data/.Trash-0/*',
* Sat 21 Sep 2013 06:02:54 PM JST
    try:
        sbp.Popen([CMD.get('rm'), '-rf', '/root/.local/share/Trash/*',
                   '/data/.Trash-0/*', '/media/Data/.Trash-0/*'],
                   stdout=sbp.PIPE, stderr=sbp.PIPE)
    except sbp.CalledProcessError:
        print('Failed: Clean Trashs.')
    except OSError:
        print('Failed: Clean Trashs.')

* Sat 21 Sep 2013 06:32:22 PM JST
~/.pylib/myxlib/
* Sat 21 Sep 2013 06:48:53 PM JST
getwindowbyname2
* Sat 21 Sep 2013 10:32:00 PM JST
SIKULI
* Sat 21 Sep 2013 10:51:27 PM JST

* Sat 21 Sep 2013 10:51:27 PM JST

* Sat 21 Sep 2013 10:51:27 PM JST
cd /

* Sat 21 Sep 2013 10:53:30 PM JST
~/sikuli/v2c.skl
* Sat 21 Sep 2013 10:57:43 PM JST

* Sat 21 Sep 2013 10:57:43 PM JST

* Sat 21 Sep 2013 10:57:43 PM JST
cd /

* Sat 21 Sep 2013 10:58:37 PM JST

* Sat 21 Sep 2013 10:58:37 PM JST

* Sat 21 Sep 2013 10:58:37 PM JST
v2c_path="/opt/v2c/v2c"

* Sat 21 Sep 2013 10:58:37 PM JST
v2c_path="/opt/v2c/v2c"

* Sat 21 Sep 2013 10:58:38 PM JST
v2c_path="/opt/v2c/v2c"
sikuli_path="/usr/bin/sikuli-ide"

* Sat 21 Sep 2013 10:58:38 PM JST
v2c_path="/opt/v2c/v2c"
sikuli_path="/usr/bin/sikuli-ide"

* Sat 21 Sep 2013 10:58:38 PM JST
v2c_path="/opt/v2c/v2c"
sikuli_path="/usr/bin/sikuli-ide"
sikuli_opt="-r"

* Sat 21 Sep 2013 10:58:38 PM JST
v2c_path="/opt/v2c/v2c"
sikuli_path="/usr/bin/sikuli-ide"
sikuli_opt="-r"

* Sat 21 Sep 2013 10:58:38 PM JST
v2c_path="/opt/v2c/v2c"
sikuli_path="/usr/bin/sikuli-ide"
sikuli_opt="-r"
v2c_sikuli_path="~/sikuli/v2c.skl"

* Sat 21 Sep 2013 10:58:40 PM JST

* Sat 21 Sep 2013 10:58:40 PM JST

* Sat 21 Sep 2013 10:58:40 PM JST
$v2c_path &

* Sat 21 Sep 2013 10:58:41 PM JST

* Sat 21 Sep 2013 10:58:41 PM JST

* Sat 21 Sep 2013 10:58:41 PM JST
$sikuli_path $sikuli_opt $v2c_sikuli_path

* Sat 21 Sep 2013 11:04:59 PM JST
system
* Sat 21 Sep 2013 11:04:59 PM JST
os.system
* Sat 21 Sep 2013 11:05:07 PM JST
system
* Sat 21 Sep 2013 11:05:07 PM JST
os.system
* Sat 21 Sep 2013 11:05:44 PM JST
call
* Sat 21 Sep 2013 11:06:14 PM JST
spawn
* Sat 21 Sep 2013 11:06:49 PM JST
spawn
* Sat 21 Sep 2013 11:07:05 PM JST
os.spawn
* Sat 21 Sep 2013 11:07:13 PM JST
call
* Sat 21 Sep 2013 11:09:08 PM JST

* Sat 21 Sep 2013 11:09:08 PM JST

* Sat 21 Sep 2013 11:09:08 PM JST
    sleep(3)

* Sat 21 Sep 2013 11:09:22 PM JST

* Sat 21 Sep 2013 11:09:22 PM JST

* Sat 21 Sep 2013 11:09:22 PM JST
from time import sleep

* Sat 21 Sep 2013 11:09:22 PM JST
from time import sleep

* Sat 21 Sep 2013 11:09:22 PM JST
from time import sleep
import os

* Sat 21 Sep 2013 11:35:23 PM JST
    display =  Xlib.display.Display()
    root = display.screen().root
    windowIDs = root.get_full_property(display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
    for id_ in windowIDs:
        win = display.create_resource_object('window', id_)
        if windowname == win.get_wm_name():
            return win

* Sat 21 Sep 2013 11:35:53 PM JST
get_full_property(display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
* Sat 21 Sep 2013 11:36:00 PM JST

* Sat 21 Sep 2013 11:36:00 PM JST

* Sat 21 Sep 2013 11:36:00 PM JST
    windowIDs = root.

* Sat 21 Sep 2013 11:36:04 PM JST
windowIDs
* Sat 21 Sep 2013 11:36:07 PM JST

* Sat 21 Sep 2013 11:36:07 PM JST

* Sat 21 Sep 2013 11:36:07 PM JST
    windowIDs = root.

* Sat 21 Sep 2013 11:37:56 PM JST
windowname
* Sat 21 Sep 2013 11:41:11 PM JST
win.get_w
* Sat 21 Sep 2013 11:47:06 PM JST
_re.search(regexp, win.get_wm_name())
* Sat 21 Sep 2013 11:50:19 PM JST
        if klass is not None and klass == win.get_wm_class():
            return win

* Sat 21 Sep 2013 11:57:59 PM JST

* Sat 21 Sep 2013 11:57:59 PM JST

* Sat 21 Sep 2013 11:57:59 PM JST
    print(args.get('x'))

* Sat 21 Sep 2013 11:57:59 PM JST
    print(args.get('x'))

* Sat 21 Sep 2013 11:57:59 PM JST
    print(args.get('x'))
    print(args.get('y'))

* Sun 22 Sep 2013 12:01:39 AM JST
regexp
* Sun 22 Sep 2013 12:04:12 AM JST

* Sun 22 Sep 2013 12:04:12 AM JST

* Sun 22 Sep 2013 12:04:12 AM JST
    print('DEBUG-1-__init__.py')

* Sun 22 Sep 2013 12:04:12 AM JST
    print('DEBUG-1-__init__.py')

* Sun 22 Sep 2013 12:04:12 AM JST
    print('DEBUG-1-__init__.py')
    print(win.get_wm_name())

* Sun 22 Sep 2013 12:04:48 AM JST

* Sun 22 Sep 2013 12:04:48 AM JST

* Sun 22 Sep 2013 12:04:48 AM JST
        # win.configure(x=1, y=1)

* Sun 22 Sep 2013 12:27:01 AM JST
display, win = determine_target_window(title=args.get('title'),
                                  klass=args.get('klass'),
                                  pid=args.get('pid'),
                                  activewin=args.get('activewin'),
                                  regexp=args.get('regexp'))
* Sun 22 Sep 2013 12:28:27 AM JST

* Sun 22 Sep 2013 12:28:27 AM JST

* Sun 22 Sep 2013 12:28:27 AM JST
    return (display, win)

* Sun 22 Sep 2013 12:45:22 AM JST
USE_FOREGROUND_WINDOW
* Sun 22 Sep 2013 12:55:39 AM JST
SetCriteria
* Sun 22 Sep 2013 01:10:11 AM JST
tab
* Sun 22 Sep 2013 01:10:29 AM JST
tab
* Sun 22 Sep 2013 01:11:01 AM JST
TAB)]
* Sun 22 Sep 2013 02:12:18 AM JST

* Sun 22 Sep 2013 02:12:18 AM JST

* Sun 22 Sep 2013 02:12:19 AM JST
        if display is None:

* Sun 22 Sep 2013 02:12:19 AM JST
        if display is None:

* Sun 22 Sep 2013 02:12:19 AM JST
        if display is None:
            self._

* Sun 22 Sep 2013 02:14:42 AM JST
    # active window
    if activewin is not None:
        return getactivewindow()

* Sun 22 Sep 2013 02:15:14 AM JST
    if not (title or klass or pid or activewin or regexp):
        return None

* Sun 22 Sep 2013 02:15:41 AM JST
    # parse other windows
    windowIDs = display.screen().root.get_full_property(
        display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
    for id_ in windowIDs:
        win = display.create_resource_object('window', id_)
        if win is None:
            continue
        if title is not None and title == win.get_wm_name():
            return display, win
        if klass is not None and klass == win.get_wm_class():
            return display, win
        # not inplimented pid
        if ((regexp is not None) and
            (_re.search(regexp, win.get_wm_name()) is not None)):
            return display, win
    # not match
    return None

* Sun 22 Sep 2013 02:17:41 AM JST
                
* Sun 22 Sep 2013 02:19:04 AM JST
_display,
* Sun 22 Sep 2013 02:19:04 AM JST
self._display,
* Sun 22 Sep 2013 02:19:15 AM JST
display, 
* Sun 22 Sep 2013 02:19:18 AM JST
display, 
* Sun 22 Sep 2013 02:23:26 AM JST
Xlib.display.Display()
* Sun 22 Sep 2013 02:25:35 AM JST
hash(
* Sun 22 Sep 2013 02:26:15 AM JST
display.screen().root.get_full_property(
            self._display.intern_atom('_NET_CLIENT_LIST'),
            Xlib.X.AnyPropertyType).value
* Sun 22 Sep 2013 02:26:18 AM JST
            
* Sun 22 Sep 2013 02:26:19 AM JST
            
* Sun 22 Sep 2013 02:30:08 AM JST

* Sun 22 Sep 2013 02:30:08 AM JST

* Sun 22 Sep 2013 02:30:08 AM JST
        self._reload_display()

* Sun 22 Sep 2013 02:35:55 AM JST
self._root = self._display.screen().root
* Sun 22 Sep 2013 02:42:56 AM JST
screen().
* Sun 22 Sep 2013 02:42:57 AM JST
_display.screen().
* Sun 22 Sep 2013 02:44:13 AM JST
            if ((regexp is not None) and
                (_re.search(regexp, win.get_wm_name()) is not None)):
                return win

* Sun 22 Sep 2013 02:44:45 AM JST
self._root.get_full_property(
            self._display.intern_atom('_NET_CLIENT_LIST'),
            Xlib.X.AnyPropertyType).value
* Sun 22 Sep 2013 02:45:54 AM JST
self._root.get_full_property(
            self._display.intern_atom('_NET_CLIENT_LIST'),
            Xlib.X.AnyPropertyType).value
* Sun 22 Sep 2013 02:46:09 AM JST
            
* Sun 22 Sep 2013 02:46:21 AM JST
            
* Sun 22 Sep 2013 02:46:48 AM JST
windowIDs
* Sun 22 Sep 2013 02:46:56 AM JST

* Sun 22 Sep 2013 02:46:57 AM JST

* Sun 22 Sep 2013 02:46:57 AM JST
        windowIDs = self._root.get_full_property(

* Sun 22 Sep 2013 02:46:57 AM JST
        windowIDs = self._root.get_full_property(

* Sun 22 Sep 2013 02:46:57 AM JST
        windowIDs = self._root.get_full_property(
            self._display.intern_atom('_NET_CLIENT_LIST'),

* Sun 22 Sep 2013 02:46:57 AM JST
        windowIDs = self._root.get_full_property(
            self._display.intern_atom('_NET_CLIENT_LIST'),

* Sun 22 Sep 2013 02:46:57 AM JST
        windowIDs = self._root.get_full_property(
            self._display.intern_atom('_NET_CLIENT_LIST'),
            Xlib.X.AnyPropertyType).value

* Sun 22 Sep 2013 02:52:27 AM JST
    def __init__(self, display=None):
        r"""

        Arguments:
        - `display`:
        """
        self._display = (display or Xlib.display.Display())
        self._root = self._display.screen().root

    def _reload_display(self):
        r"""SUMMARY

        @Return:
        """
        old = self._display
        self._display = Xlib.display.Display()
        return (not (hash(old) == hash(self._display)))

    def _reload_root(self):
        r"""SUMMARY

        @Return:
        """
        self._reload_display()
        old = self._root
        self._root = self._display.screen().root
        return (not (hash(old) == hash(self._root)))

    def _getwindowids(self):
        r"""SUMMARY

        @Return:
        """
        return (self._root.get_full_property(self._display.intern_atom(
            '_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value)


* Sun 22 Sep 2013 02:52:48 AM JST
object
* Sun 22 Sep 2013 03:19:43 AM JST

* Sun 22 Sep 2013 03:19:43 AM JST

* Sun 22 Sep 2013 03:19:43 AM JST


* Sun 22 Sep 2013 03:23:23 AM JST
klass is not None and klass == win.get_wm_class()
* Sun 22 Sep 2013 03:23:50 AM JST
((regexp is not None) and
                (_re.search(regexp, win.get_wm_name()) is not None))
* Sun 22 Sep 2013 03:24:35 AM JST
            if klass is not None and klass == win.get_wm_class():
                return win
            if ((regexp is not None) and
                (_re.search(regexp, win.get_wm_name()) is not None)):
                return win

* Sun 22 Sep 2013 03:25:21 AM JST
            # TODO: (Atami) [2013/09/22]
            # not inplimented pid

* Sun 22 Sep 2013 03:26:02 AM JST

* Sun 22 Sep 2013 03:26:02 AM JST

* Sun 22 Sep 2013 03:26:02 AM JST
            wm_name = win.get_wm_name()

* Sun 22 Sep 2013 03:26:30 AM JST
def winmove(**args):
    r"""SUMMARY

    @Arguments:
    - `**args`:

    @Return:
    """
    # display = Xlib.display.Display()
    display, win = determine_target_window(title=args.get('title'),
                                  klass=args.get('klass'),
                                  pid=args.get('pid'),
                                  activewin=args.get('activewin'),
                                  regexp=args.get('regexp'))
    if win is not None:
        win.configure(**args)
        display.sync()

* Sun 22 Sep 2013 03:26:59 AM JST
determine
* Sun 22 Sep 2013 03:27:09 AM JST
display, 
* Sun 22 Sep 2013 03:30:03 AM JST
SUMMARY
* Sun 22 Sep 2013 03:37:04 AM JST
        # prevent
        if not (title or klass or pid or active or regexp):
            return None

* Sun 22 Sep 2013 03:37:30 AM JST
            # TODO: (Atami) [2013/09/22]
            # not inplimented pid
            if ((title is not None and title == win.get_wm_name()) or
                (klass is not None and klass == win.get_wm_class()) or
                (regexp is not None) and
                (_re.search(regexp, win.get_wm_name()) is not None)):
                return win

* Sun 22 Sep 2013 03:38:06 AM JST
win
* Sun 22 Sep 2013 03:43:00 AM JST
get_active_win
* Sun 22 Sep 2013 03:53:28 AM JST
print()
* Sun 22 Sep 2013 03:54:40 AM JST
None
* Sun 22 Sep 2013 03:54:44 AM JST
None
* Sun 22 Sep 2013 03:54:48 AM JST
None
* Sun 22 Sep 2013 03:54:52 AM JST
None
* Sun 22 Sep 2013 03:55:07 AM JST

* Sun 22 Sep 2013 03:55:07 AM JST

* Sun 22 Sep 2013 03:55:07 AM JST
        self._reload_display()

* Sun 22 Sep 2013 03:55:09 AM JST

* Sun 22 Sep 2013 03:55:09 AM JST

* Sun 22 Sep 2013 03:55:09 AM JST
        print(win.get_wm_name())

* Sun 22 Sep 2013 03:55:16 AM JST

* Sun 22 Sep 2013 03:55:16 AM JST

* Sun 22 Sep 2013 03:55:16 AM JST
        print('DEBUG-1-__init__.py')

* Sun 22 Sep 2013 03:55:16 AM JST
        print('DEBUG-1-__init__.py')

* Sun 22 Sep 2013 03:55:16 AM JST
        print('DEBUG-1-__init__.py')
        print(win.get_wm_name())

* Sun 22 Sep 2013 04:25:22 AM JST
get_full_property(self._display.intern_atom(
            '_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType)
* Sun 22 Sep 2013 04:25:46 AM JST
            
* Sun 22 Sep 2013 04:46:24 AM JST
X atom
* Sun 22 Sep 2013 05:11:51 PM JST
SubstructureRedirectMask
* Sun 22 Sep 2013 05:15:19 PM JST
'_NET_WM_STATE_MAXIMIZED_VERT'
* Sun 22 Sep 2013 05:15:26 PM JST
'_NET_WM_STATE_MAXIMIZED_HORZ'
* Sun 22 Sep 2013 05:20:51 PM JST
        win = self.get_target_win(title=args.get('title'),
                                      klass=args.get('klass'),
                                      pid=args.get('pid'),
                                      active=args.get('activewin'),
                                      regexp=args.get('regexp'))

* Sun 22 Sep 2013 05:21:30 PM JST
                                      
* Sun 22 Sep 2013 05:21:31 PM JST
                                      
* Sun 22 Sep 2013 05:21:33 PM JST
                                      
* Sun 22 Sep 2013 05:21:36 PM JST
                                      
* Sun 22 Sep 2013 05:21:58 PM JST
mask = X.SubstructureRedirectMask
* Sun 22 Sep 2013 05:23:15 PM JST
max_vert=display.intern_atom('_NET_WM_STATE_MAXIMIZED_VERT')
* Sun 22 Sep 2013 05:23:28 PM JST
max_horz = display.intern_atom('_NET_WM_STATE_MAXIMIZED_HORZ')
* Sun 22 Sep 2013 05:23:47 PM JST

* Sun 22 Sep 2013 05:23:47 PM JST

* Sun 22 Sep 2013 05:23:47 PM JST
        mode_set = 1

* Sun 22 Sep 2013 05:23:49 PM JST

* Sun 22 Sep 2013 05:23:50 PM JST

* Sun 22 Sep 2013 05:23:50 PM JST
        mask = X.SubstructureRedirectMask

* Sun 22 Sep 2013 05:23:54 PM JST
data = [mode_set, max_vert, max_horz, 0, 0]
* Sun 22 Sep 2013 05:24:19 PM JST
type_ = display.intern_atom('_NET_WM_STATE')
* Sun 22 Sep 2013 05:25:00 PM JST
event = protocol.event.ClientMessage(window=w, client_type=type_,data=(32,(data)))
* Sun 22 Sep 2013 05:29:06 PM JST
    def maximize(self, title=None, klass=None, active=None, pid=None, regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 1
        max_vert = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_VERT')
        max_horz = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_HORZ')
        data = [mode_set, max_vert, max_horz, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Sun 22 Sep 2013 05:33:22 PM JST
'_NET_WM_STATE_MAXIMIZED_VERT'
* Sun 22 Sep 2013 05:47:00 PM JST
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 1
        max_vert = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_VERT')
        max_horz = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_HORZ')
        data = [mode_set, max_vert, max_horz, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Sun 22 Sep 2013 06:01:39 PM JST

* Sun 22 Sep 2013 06:01:40 PM JST

* Sun 22 Sep 2013 06:01:40 PM JST
        max_vert = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_VERT')

* Sun 22 Sep 2013 06:01:40 PM JST
        max_vert = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_VERT')

* Sun 22 Sep 2013 06:01:40 PM JST
        max_vert = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_VERT')
        max_horz = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_HORZ')

* Sun 22 Sep 2013 06:01:44 PM JST
max_vert
* Sun 22 Sep 2013 06:01:46 PM JST
max_horz
* Sun 22 Sep 2013 06:02:14 PM JST
'_NET_WM_STATE_FULLSCREEN'
* Sun 22 Sep 2013 06:02:39 PM JST
resetmaximize
* Sun 22 Sep 2013 06:03:11 PM JST
    def fullscreen(self, title=None, klass=None, active=None, pid=None,
                   regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 1
        fullscreen = self._display.intern_atom('_NET_WM_STATE_FULLSCREEN')
        data = [mode_set, fullscreen, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Sun 22 Sep 2013 06:14:08 PM JST
'_NET_WM_STATE_SHADED'
* Sun 22 Sep 2013 06:14:21 PM JST
    def fullscreen(self, title=None, klass=None, active=None, pid=None,
                   regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 1
        fullscreen = self._display.intern_atom('_NET_WM_STATE_FULLSCREEN')
        data = [mode_set, fullscreen, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Sun 22 Sep 2013 06:14:38 PM JST
fullscreen
* Sun 22 Sep 2013 06:15:18 PM JST
    def fullscreen(self, title=None, klass=None, active=None, pid=None,
                   regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 1
        fullscreen = self._display.intern_atom('_NET_WM_STATE_FULLSCREEN')
        data = [mode_set, fullscreen, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Sun 22 Sep 2013 06:15:29 PM JST
fullscreen
* Sun 22 Sep 2013 06:15:54 PM JST
'_NET_WM_STATE_SHADED'
* Sun 22 Sep 2013 06:15:58 PM JST
fullscreen
* Sun 22 Sep 2013 06:16:04 PM JST
fullscreen
* Sun 22 Sep 2013 06:16:32 PM JST
    def shade(self, title=None, klass=None, active=None, pid=None,
                   regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 1
        shade = self._display.intern_atom('_NET_WM_STATE_SHADED')
        data = [mode_set, shade, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Sun 22 Sep 2013 06:16:45 PM JST
mode_
* Sun 22 Sep 2013 06:16:53 PM JST
mode_
* Sun 22 Sep 2013 06:17:19 PM JST
resetfullscreen
* Sun 22 Sep 2013 06:21:32 PM JST
'_NET_WM_STATE_HIDDEN'
* Sun 22 Sep 2013 06:21:48 PM JST
    def shade(self, title=None, klass=None, active=None, pid=None,
                   regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 1
        shade = self._display.intern_atom('_NET_WM_STATE_SHADED')
        data = [mode_set, shade, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Sun 22 Sep 2013 06:21:55 PM JST
shade
* Sun 22 Sep 2013 06:22:05 PM JST
'_NET_WM_STATE_HIDDEN'
* Sun 22 Sep 2013 06:22:16 PM JST
shade
* Sun 22 Sep 2013 06:22:19 PM JST
shade
* Sun 22 Sep 2013 06:22:31 PM JST
    def hide(self, title=None, klass=None, active=None, pid=None,
                   regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 1
        hide = self._display.intern_atom('_NET_WM_STATE_HIDDEN')
        data = [mode_set, hide, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Sun 22 Sep 2013 06:22:37 PM JST
mode_
* Sun 22 Sep 2013 06:22:41 PM JST
mode_
* Sun 22 Sep 2013 06:31:25 PM JST
display.intern_atom('_NET_WM_STATE_HIDDEN')
* Sun 22 Sep 2013 09:43:15 PM JST
'Foreign News'
* Sun 22 Sep 2013 09:48:38 PM JST
    week = {0: '1mon',
            1: '2tue',
            2: '3wed',
            3: '4thu',
            4: '5fri',
            5: '6sta',
            6: '0sun'}

* Sun 22 Sep 2013 09:52:41 PM JST
os.system
* Sun 22 Sep 2013 09:54:22 PM JST

* Sun 22 Sep 2013 09:54:22 PM JST

* Sun 22 Sep 2013 09:54:22 PM JST
            break

* Sun 22 Sep 2013 09:54:39 PM JST

* Sun 22 Sep 2013 09:54:39 PM JST

* Sun 22 Sep 2013 09:54:39 PM JST
        sleep(5)

* Sun 22 Sep 2013 11:19:52 PM JST
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)

* Sun 22 Sep 2013 11:20:00 PM JST
        mode_set = 1
        hide = self._display.intern_atom('_NET_WM_STATE_HIDDEN')
        data = [mode_set, hide, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Sun 22 Sep 2013 11:35:12 PM JST
display.intern_atom('_NET_WM_STATE_HIDDEN')
* Sun 22 Sep 2013 11:36:02 PM JST
_NET_WM_STATE_ADD
* Sun 22 Sep 2013 11:38:33 PM JST
hide
* Sun 22 Sep 2013 11:40:59 PM JST
mode_set, 
* Sun 22 Sep 2013 11:50:11 PM JST
0
* Sun 22 Sep 2013 11:50:11 PM JST
0, 0
* Sun 22 Sep 2013 11:50:11 PM JST
0, 0, 0
* Sun 22 Sep 2013 11:52:55 PM JST
_NET_WM_STATE_FULLSCREEN
* Sun 22 Sep 2013 11:56:59 PM JST
SubstructureNotifyMask
* Sun 22 Sep 2013 11:57:49 PM JST

* Sun 22 Sep 2013 11:57:49 PM JST

* Sun 22 Sep 2013 11:57:49 PM JST
        mode_set = 1

* Sun 22 Sep 2013 11:59:06 PM JST
self._display.intern_atom('_NET_WM_STATE_ADD')
* Sun 22 Sep 2013 11:59:23 PM JST

* Sun 22 Sep 2013 11:59:24 PM JST

* Sun 22 Sep 2013 11:59:24 PM JST
        mask = X.SubstructureNotifyMask

* Sun 22 Sep 2013 11:59:37 PM JST
X.SubstructureNotifyMask
* Mon 23 Sep 2013 12:02:09 AM JST
self._display.intern_atom('_NET_WM_STATE_ADD')
* Mon 23 Sep 2013 12:02:14 AM JST

* Mon 23 Sep 2013 12:02:14 AM JST

* Mon 23 Sep 2013 12:02:14 AM JST
        # self._display.intern_atom('_NET_WM_STATE_ADD')

* Mon 23 Sep 2013 12:04:46 AM JST
'_NET_WM_STATE_HIDDEN'
* Mon 23 Sep 2013 12:16:27 AM JST
(x-send-client-message nil 0 nil "_NET_WM_STATE" 32
                         ;; if first parameter is '1', can't toggle fullscreen status
                         '(1 "_NET_WM_STATE_FULLSCREEN" 0)))
* Mon 23 Sep 2013 12:16:40 AM JST
(x-send-client-message nil 0 nil "_NET_WM_STATE" 32
                         ;; if first parameter is '2', can toggle fullscreen status
                         '(2 "_NET_WM_STATE_FULLSCREEN" 0)))
* Mon 23 Sep 2013 12:27:02 AM JST
    def fullscreen(self, title=None, klass=None, active=None, pid=None,
                   regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 1
        fullscreen = self._display.intern_atom('_NET_WM_STATE_FULLSCREEN')
        data = [mode_set, fullscreen, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Mon 23 Sep 2013 12:27:10 AM JST
fullscreen
* Mon 23 Sep 2013 12:27:30 AM JST
fullscreen
* Mon 23 Sep 2013 12:27:36 AM JST
fullscreen
* Mon 23 Sep 2013 12:28:10 AM JST
    def top(self, title=None, klass=None, active=None, pid=None,
                   regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 1
        above = self._display.intern_atom('_NET_WM_STATE_ABOVE')
        data = [mode_set, above, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Mon 23 Sep 2013 12:28:52 AM JST
above
* Mon 23 Sep 2013 12:28:57 AM JST
above
* Mon 23 Sep 2013 12:30:09 AM JST
    def top(self, title=None, klass=None, active=None, pid=None,
                   regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 1
        above = self._display.intern_atom('_NET_WM_STATE_ABOVE')
        data = [mode_set, above, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Mon 23 Sep 2013 12:31:29 AM JST
    def below(self, title=None, klass=None, active=None, pid=None,
                   regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 1
        below = self._display.intern_atom('_NET_WM_STATE_BELOW')
        data = [mode_set, below, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Mon 23 Sep 2013 12:32:47 AM JST
    def resethide(self, title=None, klass=None, active=None, pid=None,
                   regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        unset = 0
        hide = self._display.intern_atom('_NET_WM_STATE_HIDDEN')
        data = [unset, hide, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Mon 23 Sep 2013 12:32:57 AM JST
rese
* Mon 23 Sep 2013 12:33:11 AM JST
un
* Mon 23 Sep 2013 12:33:47 AM JST
resetbelow
* Mon 23 Sep 2013 12:36:59 AM JST
_NET_WM_STATE_HIDDEN
* Mon 23 Sep 2013 12:41:45 AM JST
_NET_WM_ACTION_MINIMIZE
* Mon 23 Sep 2013 12:41:55 AM JST
mode_set, 
* Mon 23 Sep 2013 12:57:01 AM JST
winswi
* Mon 23 Sep 2013 12:57:01 AM JST
import winswi
* Mon 23 Sep 2013 01:09:52 AM JST
get_property(display.intern_atom('_NET_WM_PID'), X.AnyPropertyType, 0, 10)
* Mon 23 Sep 2013 01:17:28 AM JST

* Mon 23 Sep 2013 01:17:28 AM JST

* Mon 23 Sep 2013 01:17:28 AM JST
        # TODO: (Atami) [2013/09/22]

* Mon 23 Sep 2013 01:17:28 AM JST
        # TODO: (Atami) [2013/09/22]

* Mon 23 Sep 2013 01:17:28 AM JST
        # TODO: (Atami) [2013/09/22]
        # not inplimented pid

* Mon 23 Sep 2013 01:19:35 AM JST
get_wm_state()
* Mon 23 Sep 2013 01:19:55 AM JST
list_properties
* Mon 23 Sep 2013 01:21:40 AM JST
window.get_wm_class(), window.get_wm_name(), window.get_wm_state(), window.list_properties(), window.get_attributes(), window.get_wm_icon_size(), window.get_wm_client_machine()
* Mon 23 Sep 2013 01:23:13 AM JST
WM_DELETE_WINDOW
* Mon 23 Sep 2013 01:24:46 AM JST
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 0
        below = self._display.intern_atom('_NET_WM_STATE_BELOW')
        data = [mode_set, below, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Mon 23 Sep 2013 01:24:59 AM JST
WM_DELETE_WINDOW
* Mon 23 Sep 2013 01:26:09 AM JST
title
* Mon 23 Sep 2013 01:26:12 AM JST
klass
* Mon 23 Sep 2013 01:26:15 AM JST
pid
* Mon 23 Sep 2013 01:26:18 AM JST
active
* Mon 23 Sep 2013 01:26:21 AM JST
regexp
* Mon 23 Sep 2013 01:26:38 AM JST
below
* Mon 23 Sep 2013 01:26:44 AM JST
below
* Mon 23 Sep 2013 01:28:28 AM JST
mode_set, 
* Mon 23 Sep 2013 01:29:18 AM JST
self.display.intern_atom("WM_PROTOCOLS")
* Mon 23 Sep 2013 01:33:42 AM JST
    def closewin(self, title=None, klass=None, pid=None, active=None,
                 regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        # mode_set = 1
        delete = self._display.intern_atom('WM_DELETE_WINDOW')
        data = [delete, X.CurrentTime, 0, 0, 0]
        # mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom("WM_PROTOCOLS")
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event=event, event_mask=0, propagate=0)
        self._display.sync()

* Mon 23 Sep 2013 01:33:48 AM JST
closewin
* Mon 23 Sep 2013 01:34:25 AM JST
_NET_WM_ACTION_MINIMIZE
* Mon 23 Sep 2013 01:34:46 AM JST
delete
* Mon 23 Sep 2013 01:34:50 AM JST
delete
* Mon 23 Sep 2013 02:02:08 AM JST
WM_PROTOCOLS
* Mon 23 Sep 2013 02:05:46 AM JST
WM_DELETE_WINDOW
* Mon 23 Sep 2013 02:10:01 AM JST
get_wm_protocols
* Mon 23 Sep 2013 02:10:25 AM JST
display.intern_atom('WM_DELETE_WINDOW')
* Mon 23 Sep 2013 02:11:00 AM JST
display.intern_atom('_NET_WM_ACTION_MINIMIZE')
* Mon 23 Sep 2013 02:11:39 AM JST
display.intern_atom('_NET_WM_STATE')
* Mon 23 Sep 2013 02:18:19 AM JST
True
* Mon 23 Sep 2013 02:20:18 AM JST
0
* Mon 23 Sep 2013 02:20:19 AM JST
propagate=0
* Mon 23 Sep 2013 02:21:38 AM JST
mask
* Mon 23 Sep 2013 02:25:55 AM JST
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        # mode_set = 1
        delete = self._display.intern_atom('WM_DELETE_WINDOW')
        data = [delete, X.CurrentTime, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom("WM_PROTOCOLS", True)
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event=event, event_mask=0)
        self._display.sync()

* Mon 23 Sep 2013 02:26:21 AM JST
WM_PROTOCOLS
* Mon 23 Sep 2013 02:30:28 AM JST
SubstructureNotifyMask
* Mon 23 Sep 2013 02:30:52 AM JST
StructureNotifyMask
* Mon 23 Sep 2013 02:41:56 AM JST
_root
* Mon 23 Sep 2013 02:41:57 AM JST
self._root
* Mon 23 Sep 2013 02:42:09 AM JST
self._root
* Mon 23 Sep 2013 02:42:17 AM JST
True
* Mon 23 Sep 2013 02:42:49 AM JST
SubstructureRedirectMask
* Mon 23 Sep 2013 02:43:29 AM JST
self._root
* Mon 23 Sep 2013 02:45:18 AM JST
delete = self._display.intern_atom('WM_DELETE_WINDOW')
* Mon 23 Sep 2013 02:45:27 AM JST
type_ = self._display.intern_atom("WM_PROTOCOLS", True)
* Mon 23 Sep 2013 03:14:08 AM JST
self._root
* Mon 23 Sep 2013 03:14:15 AM JST
0
* Mon 23 Sep 2013 03:14:16 AM JST
propagate=0
* Mon 23 Sep 2013 03:17:31 AM JST

* Mon 23 Sep 2013 03:17:31 AM JST

* Mon 23 Sep 2013 03:17:32 AM JST
        # mode_set = 1

* Mon 23 Sep 2013 03:17:45 AM JST
_NET_WM_ACTION_MINIMIZE
* Mon 23 Sep 2013 03:26:37 AM JST
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        # mode_set = 1
        delete = self._display.intern_atom('WM_DELETE_WINDOW')
        data = [delete, X.CurrentTime, 0, 0, 0]
        # mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom("WM_PROTOCOLS", True)
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        win.send_event(event=event, event_mask=0)
        self._display.sync()

* Mon 23 Sep 2013 03:26:55 AM JST
'_NET_WM_ACTION_MINIMIZE'
* Mon 23 Sep 2013 03:39:14 AM JST
'_NET_WM_STATE_HIDDEN'
* Mon 23 Sep 2013 03:39:58 AM JST
minimize
* Mon 23 Sep 2013 03:46:47 AM JST
delete
* Mon 23 Sep 2013 03:46:52 AM JST
delete
* Mon 23 Sep 2013 03:47:27 AM JST
CurrentTime,
* Mon 23 Sep 2013 03:48:55 AM JST
_NET_WM_STATE
* Mon 23 Sep 2013 03:49:16 AM JST
True
* Mon 23 Sep 2013 03:50:48 AM JST
win
* Mon 23 Sep 2013 04:05:48 AM JST
_NET_WM_ALLOWED_ACTIONS
* Mon 23 Sep 2013 04:06:28 AM JST
self._root
* Mon 23 Sep 2013 04:06:43 AM JST
win
* Mon 23 Sep 2013 04:10:54 AM JST
    def closewin(self, title=None, klass=None, pid=None, active=None,
                 regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        # mode_set = 1
        delete = self._display.intern_atom('WM_DELETE_WINDOW')
        data = [delete, X.CurrentTime, 0, 0, 0]
        # mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('WM_PROTOCOLS', True)
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        win.send_event(event=event, event_mask=0)
        self._display.sync()

* Mon 23 Sep 2013 04:11:54 AM JST
delete, 
* Mon 23 Sep 2013 04:12:51 AM JST
minimize
* Mon 23 Sep 2013 04:13:03 AM JST
win
* Mon 23 Sep 2013 04:13:31 AM JST
True
* Mon 23 Sep 2013 04:13:44 AM JST
0
* Mon 23 Sep 2013 04:13:44 AM JST
event_mask=0
* Mon 23 Sep 2013 04:19:32 AM JST
CurrentTime
* Mon 23 Sep 2013 04:19:35 AM JST
CurrentTime
* Mon 23 Sep 2013 04:19:49 AM JST
0
* Mon 23 Sep 2013 04:20:18 AM JST
closewin2
* Mon 23 Sep 2013 04:20:30 AM JST
mask
* Mon 23 Sep 2013 04:21:09 AM JST
_root
* Mon 23 Sep 2013 04:21:09 AM JST
self._root
* Mon 23 Sep 2013 04:31:22 AM JST
'_NET_WM_STATE'
* Mon 23 Sep 2013 04:31:35 AM JST
hiden
* Mon 23 Sep 2013 04:31:40 AM JST
CurrentTime
* Mon 23 Sep 2013 04:31:41 AM JST
X.CurrentTime
* Mon 23 Sep 2013 04:31:47 AM JST
0
* Mon 23 Sep 2013 04:32:16 AM JST
win
* Mon 23 Sep 2013 04:41:47 AM JST
mini
* Mon 23 Sep 2013 04:41:51 AM JST
mini
* Mon 23 Sep 2013 04:42:10 AM JST
	def xlib_error(self, *err):
		self.error("(%s)" % str(err))

* Mon 23 Sep 2013 04:42:30 AM JST
error
* Mon 23 Sep 2013 04:42:30 AM JST
self.error
* Mon 23 Sep 2013 04:45:17 AM JST
	
* Mon 23 Sep 2013 04:45:22 AM JST
		
* Mon 23 Sep 2013 05:42:21 AM JST
close
* Mon 23 Sep 2013 06:25:43 AM JST
_Display
* Mon 23 Sep 2013 06:50:38 AM JST
display
* Mon 23 Sep 2013 07:04:17 AM JST
window
* Mon 23 Sep 2013 07:04:18 AM JST
display, window
* Mon 23 Sep 2013 07:04:28 AM JST
display
* Mon 23 Sep 2013 07:04:46 AM JST
window
* Mon 23 Sep 2013 07:04:47 AM JST
_window
* Mon 23 Sep 2013 07:05:19 AM JST
self._display.create_resource_object('window', id_)
* Mon 23 Sep 2013 07:09:05 AM JST
    def maximize(self, title=None, klass=None, active=None, pid=None, regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 1
        max_vert = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_VERT')
        max_horz = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_HORZ')
        data = [mode_set, max_vert, max_horz, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Mon 23 Sep 2013 07:09:26 AM JST

* Mon 23 Sep 2013 07:09:26 AM JST

* Mon 23 Sep 2013 07:09:26 AM JST
        win = self.get_target_win(title=title, klass=klass, pid=pid,

* Mon 23 Sep 2013 07:09:26 AM JST
        win = self.get_target_win(title=title, klass=klass, pid=pid,

* Mon 23 Sep 2013 07:09:26 AM JST
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)

* Mon 23 Sep 2013 07:10:05 AM JST
protocol
* Mon 23 Sep 2013 07:10:27 AM JST
event.
* Mon 23 Sep 2013 07:10:27 AM JST
protocol.event.
* Mon 23 Sep 2013 07:10:29 AM JST
            
* Mon 23 Sep 2013 07:13:54 AM JST
/usr/share/pyshared/Xlib/
* Mon 23 Sep 2013 07:16:16 AM JST

* Mon 23 Sep 2013 07:16:16 AM JST

* Mon 23 Sep 2013 07:16:16 AM JST
        mode_set = 1

* Mon 23 Sep 2013 07:16:24 AM JST

* Mon 23 Sep 2013 07:16:24 AM JST

* Mon 23 Sep 2013 07:16:24 AM JST
        - `klass`:

* Mon 23 Sep 2013 07:16:24 AM JST
        - `klass`:

* Mon 23 Sep 2013 07:16:24 AM JST
        - `klass`:
        - `active`:

* Mon 23 Sep 2013 07:16:24 AM JST
        - `klass`:
        - `active`:

* Mon 23 Sep 2013 07:16:24 AM JST
        - `klass`:
        - `active`:
        - `pid`:

* Mon 23 Sep 2013 07:16:25 AM JST
        - `klass`:
        - `active`:
        - `pid`:

* Mon 23 Sep 2013 07:16:25 AM JST
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

* Mon 23 Sep 2013 07:16:26 AM JST
title
* Mon 23 Sep 2013 07:17:08 AM JST
mode_set
* Mon 23 Sep 2013 07:18:44 AM JST
_display.
* Mon 23 Sep 2013 07:18:54 AM JST
_display
* Mon 23 Sep 2013 07:21:59 AM JST
self._root.send_event(event, event_mask=mask)
* Mon 23 Sep 2013 07:22:02 AM JST
mask
* Mon 23 Sep 2013 07:23:33 AM JST
                
* Mon 23 Sep 2013 07:26:44 AM JST
[action, max_vert, max_horz, 0, 0]
* Mon 23 Sep 2013 07:27:30 AM JST

* Mon 23 Sep 2013 07:27:30 AM JST

* Mon 23 Sep 2013 07:27:30 AM JST
        mask = X.SubstructureRedirectMask

* Mon 23 Sep 2013 07:29:02 AM JST
_netstatewm
* Mon 23 Sep 2013 07:29:32 AM JST
self._display.intern_atom('_NET_WM_STATE')
* Mon 23 Sep 2013 07:30:18 AM JST

* Mon 23 Sep 2013 07:30:18 AM JST

* Mon 23 Sep 2013 07:30:18 AM JST
        # data = [action, max_vert, max_horz, 0, 0]

* Mon 23 Sep 2013 07:30:18 AM JST
        # data = [action, max_vert, max_horz, 0, 0]

* Mon 23 Sep 2013 07:30:18 AM JST
        # data = [action, max_vert, max_horz, 0, 0]
        # type_ = self._display.intern_atom('_NET_WM_STATE')

* Mon 23 Sep 2013 07:30:29 AM JST
X.SubstructureRedirectMask
* Mon 23 Sep 2013 07:30:34 AM JST

* Mon 23 Sep 2013 07:30:34 AM JST

* Mon 23 Sep 2013 07:30:34 AM JST
        mask = 

* Mon 23 Sep 2013 07:33:58 AM JST
    def _send_event(self, event, event_mask=0, propagate=0, sender='root'):
        r"""SUMMARY

        @Arguments:

        - `event`:
        - `event_mask`:
        - `propagate`:

        @Return:
        """
        if 'root' == sender:
            self._root.send_event(
                event, event_mask=event_mask, propagate=propagate)
        elif 'window' == sender:
            self._window.send_event(
                event, event_mask=event_mask, propagate=propagate)
        self._sync()

    def _sync(self):
        r"""SUMMARY

        @Return:
        """
        self._display.sync()


* Mon 23 Sep 2013 07:35:56 AM JST
    def get_active_win(self):
        r"""SUMMARY

        @Return:
        """
        win = self._display.get_input_focus().focus
        if win.get_wm_name() is None and win.get_wm_class() is None:
            win = win.query_tree().parent
        return win


* Mon 23 Sep 2013 07:39:02 AM JST

* Mon 23 Sep 2013 07:39:03 AM JST

* Mon 23 Sep 2013 07:39:03 AM JST
        if activewin:

* Mon 23 Sep 2013 07:39:27 AM JST

* Mon 23 Sep 2013 07:39:27 AM JST

* Mon 23 Sep 2013 07:39:27 AM JST
        activewin = self._get_active_win()

* Mon 23 Sep 2013 07:41:04 AM JST
self._get_active_win()
* Mon 23 Sep 2013 07:43:19 AM JST
    def fullscreen(self, title=None, klass=None, active=None, pid=None,
                   regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 1
        fullscreen = self._display.intern_atom('_NET_WM_STATE_FULLSCREEN')
        data = [mode_set, fullscreen, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Mon 23 Sep 2013 07:43:53 AM JST

* Mon 23 Sep 2013 07:43:53 AM JST

* Mon 23 Sep 2013 07:43:53 AM JST
        mode_set = 1

* Mon 23 Sep 2013 07:43:57 AM JST
assert action in [0, 1, 2]
* Mon 23 Sep 2013 07:44:13 AM JST
mode_set
* Mon 23 Sep 2013 07:44:19 AM JST
fullscreen
* Mon 23 Sep 2013 07:44:24 AM JST
fullscreen
* Mon 23 Sep 2013 07:44:32 AM JST
[action, atom, 0, 0, 0]
* Mon 23 Sep 2013 07:44:58 AM JST
event.
* Mon 23 Sep 2013 07:44:59 AM JST
protocol.event.
* Mon 23 Sep 2013 07:45:18 AM JST
            
* Mon 23 Sep 2013 07:45:43 AM JST

* Mon 23 Sep 2013 07:45:43 AM JST

* Mon 23 Sep 2013 07:45:43 AM JST
        data = [action, atom, 0, 0, 0]

* Mon 23 Sep 2013 07:45:54 AM JST
type_
* Mon 23 Sep 2013 07:46:14 AM JST

* Mon 23 Sep 2013 07:46:14 AM JST

* Mon 23 Sep 2013 07:46:15 AM JST
        type_ = self._display.intern_atom('_NET_WM_STATE')

* Mon 23 Sep 2013 07:46:50 AM JST
X.SubstructureRedirectMask
* Mon 23 Sep 2013 07:46:57 AM JST

* Mon 23 Sep 2013 07:46:57 AM JST

* Mon 23 Sep 2013 07:46:57 AM JST
        mask = 

* Mon 23 Sep 2013 07:49:57 AM JST
    def shade(self, title=None, klass=None, active=None, pid=None,
                   regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        mode_set = 1
        shade = self._display.intern_atom('_NET_WM_STATE_SHADED')
        data = [mode_set, shade, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_WM_STATE')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Mon 23 Sep 2013 07:51:00 AM JST

* Mon 23 Sep 2013 07:51:01 AM JST

* Mon 23 Sep 2013 07:51:01 AM JST
        mode_set = 1

* Mon 23 Sep 2013 07:51:23 AM JST
shade
* Mon 23 Sep 2013 07:51:26 AM JST
shade
* Mon 23 Sep 2013 07:51:30 AM JST
mode_set
* Mon 23 Sep 2013 07:51:36 AM JST
[action, atom, 0, 0, 0]
* Mon 23 Sep 2013 07:51:44 AM JST

* Mon 23 Sep 2013 07:51:44 AM JST

* Mon 23 Sep 2013 07:51:44 AM JST
        data = [action, atom, 0, 0, 0]

* Mon 23 Sep 2013 07:51:47 AM JST
X.SubstructureRedirectMask
* Mon 23 Sep 2013 07:52:11 AM JST

* Mon 23 Sep 2013 07:52:11 AM JST

* Mon 23 Sep 2013 07:52:11 AM JST
        self._root.send_event(event, event_mask=mask)

* Mon 23 Sep 2013 07:52:11 AM JST
        self._root.send_event(event, event_mask=mask)

* Mon 23 Sep 2013 07:52:11 AM JST
        self._root.send_event(event, event_mask=mask)
        self._display.sync()

* Mon 23 Sep 2013 07:52:15 AM JST

* Mon 23 Sep 2013 07:52:15 AM JST

* Mon 23 Sep 2013 07:52:16 AM JST
        mask = X.SubstructureRedirectMask

* Mon 23 Sep 2013 07:52:21 AM JST
event.
* Mon 23 Sep 2013 07:52:21 AM JST
protocol.event.
* Mon 23 Sep 2013 07:52:24 AM JST
            
* Mon 23 Sep 2013 07:52:43 AM JST
type_
* Mon 23 Sep 2013 07:52:55 AM JST

* Mon 23 Sep 2013 07:52:55 AM JST

* Mon 23 Sep 2013 07:52:55 AM JST
        type_ = self._display.intern_atom('_NET_WM_STATE')

* Mon 23 Sep 2013 07:55:27 AM JST
reset
* Mon 23 Sep 2013 08:02:09 AM JST
[action, max_vert, max_horz, 0, 0]
* Mon 23 Sep 2013 08:03:02 AM JST

* Mon 23 Sep 2013 08:03:02 AM JST

* Mon 23 Sep 2013 08:03:02 AM JST
        assert action in [0, 1, 2]

* Mon 23 Sep 2013 08:04:06 AM JST
[action, atom, 0, 0, 0]
* Mon 23 Sep 2013 08:04:25 AM JST

* Mon 23 Sep 2013 08:04:25 AM JST

* Mon 23 Sep 2013 08:04:25 AM JST
        assert action in [0, 1, 2]

* Mon 23 Sep 2013 08:04:57 AM JST

* Mon 23 Sep 2013 08:04:57 AM JST

* Mon 23 Sep 2013 08:04:57 AM JST
        assert action in [0, 1, 2]

* Mon 23 Sep 2013 08:05:58 AM JST
    def isactive(self):
        r"""SUMMARY

        @Return: boolean
        """
        activewin = self._get_active_win()
        if activewin is None:
            return False
        return self._id == activewin.id


* Mon 23 Sep 2013 08:06:21 AM JST
    def _sync(self):
        r"""SUMMARY

        @Return:
        """
        self._display.sync()


* Mon 23 Sep 2013 08:10:14 AM JST
above = self._display.intern_atom('_NET_WM_STATE_ABOVE')
* Mon 23 Sep 2013 08:11:03 AM JST
above =
* Mon 23 Sep 2013 08:13:13 AM JST
reset
* Mon 23 Sep 2013 08:13:51 AM JST
self._display.intern_atom('_NET_WM_STATE_BELOW')
* Mon 23 Sep 2013 08:14:06 AM JST
    def _above(self, action):
        r"""SUMMARY

        @Arguments:

        - `action`:

        @Return:
        """
        atom = self._display.intern_atom('_NET_WM_STATE_ABOVE')
        self._state_cmd(data=[action, atom, 0, 0, 0])

    def above(self):
        r"""SUMMARY

        @Return:
        """
        self._above(action=1)

    def reset_above(self):
        r"""SUMMARY

        @Return:
        """
        self._above(action=0)

    def toggle_above(self):
        r"""SUMMARY

        @Return:
        """
        self._above(action=2)

* Mon 23 Sep 2013 08:14:45 AM JST
self._display.intern_atom('_NET_WM_STATE_BELOW')
* Mon 23 Sep 2013 08:14:51 AM JST

* Mon 23 Sep 2013 08:14:51 AM JST

* Mon 23 Sep 2013 08:14:52 AM JST
# self._display.intern_atom('_NET_WM_STATE_BELOW')

* Mon 23 Sep 2013 08:15:25 AM JST
above
* Mon 23 Sep 2013 08:15:43 AM JST
reset
* Mon 23 Sep 2013 08:16:48 AM JST
    def get_pid(self, win):
        r"""SUMMARY

        @Arguments:
        - `win`:

        @Return:
        """
        pid_reply = win.get_property(self._display.intern_atom('_NET_WM_PID'),
                                     X.AnyPropertyType, 0, 10)
        return int(pid_reply.value.tolist()[0])

* Mon 23 Sep 2013 08:17:52 AM JST
win
* Mon 23 Sep 2013 08:18:09 AM JST
                                     
* Mon 23 Sep 2013 08:19:33 AM JST
    def killwin(self, title=None, klass=None, pid=None, active=None,
                 regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        # mode_set = 1
        delete = self._display.intern_atom('WM_DELETE_WINDOW')
        data = [delete, X.CurrentTime, 0, 0, 0]
        # mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('WM_PROTOCOLS', True)
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        win.send_event(event=event, event_mask=0)
        self._display.sync()

    def closewin(self, title=None, klass=None, pid=None, active=None,
                 regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        # mode_set = 1
        # delete = self._display.intern_atom('WM_DELETE_WINDOW')
        data = [X.CurrentTime, 0, 0, 0, 0]
        mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('_NET_CLOSE_WINDOW')
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        self._root.send_event(event=event, event_mask=mask)
        self._display.sync()

* Mon 23 Sep 2013 08:19:44 AM JST
event.
* Mon 23 Sep 2013 08:19:44 AM JST
protocol.event.
* Mon 23 Sep 2013 08:19:49 AM JST
event.
* Mon 23 Sep 2013 08:19:49 AM JST
protocol.event.
* Mon 23 Sep 2013 08:22:04 AM JST

* Mon 23 Sep 2013 08:22:04 AM JST

* Mon 23 Sep 2013 08:22:04 AM JST
        # mask = X.SubstructureRedirectMask

* Mon 23 Sep 2013 08:22:50 AM JST
delete
* Mon 23 Sep 2013 08:22:54 AM JST
delete
* Mon 23 Sep 2013 08:23:31 AM JST
            
* Mon 23 Sep 2013 08:23:44 AM JST
self._display.intern_atom('WM_PROTOCOLS', True)
* Mon 23 Sep 2013 08:24:16 AM JST
[atom, X.CurrentTime, 0, 0, 0]
* Mon 23 Sep 2013 08:24:23 AM JST

* Mon 23 Sep 2013 08:24:23 AM JST

* Mon 23 Sep 2013 08:24:23 AM JST
        data = 

* Mon 23 Sep 2013 08:24:25 AM JST

* Mon 23 Sep 2013 08:24:25 AM JST

* Mon 23 Sep 2013 08:24:25 AM JST
        atom = self._display.intern_atom('WM_DELETE_WINDOW')

* Mon 23 Sep 2013 08:24:39 AM JST

* Mon 23 Sep 2013 08:24:39 AM JST

* Mon 23 Sep 2013 08:24:39 AM JST
        # mode_set = 1

* Mon 23 Sep 2013 08:24:39 AM JST
        # mode_set = 1

* Mon 23 Sep 2013 08:24:39 AM JST
        # mode_set = 1
        # delete = self._display.intern_atom('WM_DELETE_WINDOW')

* Mon 23 Sep 2013 08:24:48 AM JST
[X.CurrentTime, 0, 0, 0, 0]
* Mon 23 Sep 2013 08:24:58 AM JST
            
* Mon 23 Sep 2013 08:25:06 AM JST

* Mon 23 Sep 2013 08:25:06 AM JST

* Mon 23 Sep 2013 08:25:06 AM JST
        data = 

* Mon 23 Sep 2013 08:25:48 AM JST

* Mon 23 Sep 2013 08:25:48 AM JST

* Mon 23 Sep 2013 08:25:48 AM JST
        self._root.send_event(event=event, event_mask=mask)

* Mon 23 Sep 2013 08:25:48 AM JST
        self._root.send_event(event=event, event_mask=mask)

* Mon 23 Sep 2013 08:25:49 AM JST
        self._root.send_event(event=event, event_mask=mask)
        self._display.sync()

* Mon 23 Sep 2013 08:26:02 AM JST
X.SubstructureRedirectMask
* Mon 23 Sep 2013 08:26:07 AM JST

* Mon 23 Sep 2013 08:26:07 AM JST

* Mon 23 Sep 2013 08:26:07 AM JST
        mask = 

* Mon 23 Sep 2013 08:28:03 AM JST
    def killwin(self, title=None, klass=None, pid=None, active=None,
                 regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        # mode_set = 1
        delete = self._display.intern_atom('WM_DELETE_WINDOW')
        data = [delete, X.CurrentTime, 0, 0, 0]
        # mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('WM_PROTOCOLS', True)
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        win.send_event(event=event, event_mask=0)
        self._display.sync()

* Mon 23 Sep 2013 08:34:26 AM JST
    def killwin(self, title=None, klass=None, pid=None, active=None,
                 regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return:
        """
        win = self.get_target_win(title=title, klass=klass, pid=pid,
                                  active=active, regexp=regexp)
        # mode_set = 1
        delete = self._display.intern_atom('WM_DELETE_WINDOW')
        data = [delete, X.CurrentTime, 0, 0, 0]
        # mask = X.SubstructureRedirectMask
        type_ = self._display.intern_atom('WM_PROTOCOLS', True)
        event = protocol.event.ClientMessage(
            window=win, client_type=type_,data=(32,(data)))
        win.send_event(event=event, event_mask=0)
        self._display.sync()

* Mon 23 Sep 2013 08:34:39 AM JST
event.
* Mon 23 Sep 2013 08:34:39 AM JST
protocol.event.
* Mon 23 Sep 2013 08:45:03 AM JST
"\M-o" 'll-debug-insert                     )
* Mon 23 Sep 2013 08:45:22 AM JST
"\M-o"
* Mon 23 Sep 2013 08:45:33 AM JST
ll-debug-insert
* Mon 23 Sep 2013 08:45:50 AM JST

* Mon 23 Sep 2013 08:45:50 AM JST

* Mon 23 Sep 2013 08:45:50 AM JST
            print('DEBUG-2-__init__.py')

* Mon 23 Sep 2013 08:45:50 AM JST
            print('DEBUG-2-__init__.py')

* Mon 23 Sep 2013 08:45:50 AM JST
            print('DEBUG-2-__init__.py')
            # TODO: (Atami) [2013/09/23]

* Mon 23 Sep 2013 08:46:29 AM JST

* Mon 23 Sep 2013 08:46:29 AM JST

* Mon 23 Sep 2013 08:46:29 AM JST
            print('DEBUG-1-__init__.py')

* Mon 23 Sep 2013 08:47:48 AM JST
SUMMARY
* Mon 23 Sep 2013 08:48:04 AM JST
SUMMARY
* Mon 23 Sep 2013 08:50:09 AM JST
display
* Mon 23 Sep 2013 08:58:08 AM JST
    def get_target_win(self, title=None, klass=None, pid=None,
                       active=None, regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return:
        """
        # prevent
        if not (title or klass or pid or active or regexp):
            return None
        # active window
        if active is not None:
            return self.get_active_win()
        # parse other windows
        for id_ in self.get_win_ids():
            win = self._display.create_resource_object('window', id_)
            if win is None:
                continue
            if self.determine_win(win=win, title=title, klass=klass,
                                  pid=pid, regexp=regexp):
                return win
        # not matched
        return None

    def determine_win(self, win, title=None, klass=None, pid=None, regexp=None):
        r"""SUMMARY

        @Arguments:

        - `win`:
        - `title`:
        - `klass`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        if win is None:
            return False
        # title or klass or pid or regexp
        if ((title is not None and title == win.get_wm_name()) or
            (klass is not None and klass == win.get_wm_class()) or
            (pid is not None and pid == self.get_pid(win)) or
            (regexp is not None and
             (_re.search(regexp, win.get_wm_name()) is not None))):
            return True
        return False

* Mon 23 Sep 2013 08:58:30 AM JST
self
* Mon 23 Sep 2013 08:58:38 AM JST
self.
* Mon 23 Sep 2013 08:58:46 AM JST
self.
* Mon 23 Sep 2013 08:58:53 AM JST
_
* Mon 23 Sep 2013 08:58:54 AM JST
self._
* Mon 23 Sep 2013 08:59:10 AM JST
self.
* Mon 23 Sep 2013 08:59:21 AM JST
self,
* Mon 23 Sep 2013 08:59:38 AM JST
self.
* Mon 23 Sep 2013 08:59:56 AM JST

* Mon 23 Sep 2013 08:59:56 AM JST

* Mon 23 Sep 2013 08:59:56 AM JST


* Mon 23 Sep 2013 02:30:55 PM JST
sock.connect((')
* Mon 23 Sep 2013 02:43:19 PM JST
        if not cmd.endswith('\n'):
            cmd += '\n'
        self._sock.send(cmd)

* Mon 23 Sep 2013 02:44:05 PM JST
cmd
* Mon 23 Sep 2013 02:44:14 PM JST
cmd
* Mon 23 Sep 2013 02:44:28 PM JST
cmd
* Mon 23 Sep 2013 02:44:31 PM JST

* Mon 23 Sep 2013 02:44:31 PM JST

* Mon 23 Sep 2013 02:44:31 PM JST
            result = self.send(passwd)

* Mon 23 Sep 2013 02:52:34 PM JST
POWR0   \n
* Mon 23 Sep 2013 03:09:54 PM JST
result
* Mon 23 Sep 2013 03:15:09 PM JST
self._sock.recv(1024).strip()
* Mon 23 Sep 2013 03:15:11 PM JST
if '
* Mon 23 Sep 2013 03:15:17 PM JST
self._sock.recv(1024).strip()
* Mon 23 Sep 2013 03:16:11 PM JST
_sock
* Mon 23 Sep 2013 03:17:17 PM JST
login
* Mon 23 Sep 2013 03:19:32 PM JST
self._cmds.get('check')
* Mon 23 Sep 2013 03:26:23 PM JST
responce = 
* Mon 23 Sep 2013 03:27:02 PM JST
self.getstatus()
* Mon 23 Sep 2013 03:27:35 PM JST
r'
* Mon 23 Sep 2013 03:27:42 PM JST
else:
* Mon 23 Sep 2013 03:36:45 PM JST
fmt = '{0:<12}: {1}\n{2:<14}'
* Mon 23 Sep 2013 03:38:19 PM JST
fmt = '{0:<12}: {1}\n{2:>14}'
* Mon 23 Sep 2013 03:38:43 PM JST
{2:>14}
* Mon 23 Sep 2013 03:41:37 PM JST
fmt2 = '{0:<14}{1}'.format(' ', '{0}') 
* Mon 23 Sep 2013 03:46:35 PM JST

* Mon 23 Sep 2013 03:46:35 PM JST

* Mon 23 Sep 2013 03:46:35 PM JST
        self._loaded_cmd = False

* Mon 23 Sep 2013 03:46:40 PM JST
self.
* Mon 23 Sep 2013 03:51:31 PM JST
fmt2 = 
* Mon 23 Sep 2013 03:51:32 PM JST
        fmt2 = 
* Mon 23 Sep 2013 03:54:21 PM JST
self, 
* Mon 23 Sep 2013 03:55:48 PM JST
        self.power = _POWR(sock=self._sock)
        self.inputtoggle = _ITGD(sock=self._sock)
        self.inputtv = _ITVD(sock=self._sock)
        self.input = _IAVD(sock=self._sock)
        self.inputdegital = _IDEG(sock=self._sock)
        # self.channelBS = _CBSD(sock=self._sock)
        # self.channelCS = _CCSD(sock=self._sock)
        # self.channelTB = _CTBD(sock=self._sock)
        self.channel = _Channel(sock=self._sock)
        self.input4 = _INP4(sock=self._sock)
        self.avposition = _AVMD(sock=self._sock)
        self.volume = _VOLM(sock=self._sock)
        self.horizon = _HPOS(sock=self._sock)
        self.vertical = _VPOS(sock=self._sock)
        self.clock = _CLCK(sock=self._sock)
        self.clockphese = _PHSE(sock=self._sock)
        self.display = _WIDE(sock=self._sock)
        self.mute = _MUTE(sock=self._sock)
        self.audio = _ACHA(sock=self._sock)
        self.offtimer = _OFTM(sock=self._sock)
        self._loaded_cmd = True

* Mon 23 Sep 2013 03:55:57 PM JST

* Mon 23 Sep 2013 03:55:57 PM JST

* Mon 23 Sep 2013 03:55:57 PM JST
# self.channelBS = _CBSD(sock=self._sock)

* Mon 23 Sep 2013 03:55:57 PM JST
# self.channelBS = _CBSD(sock=self._sock)

* Mon 23 Sep 2013 03:55:57 PM JST
# self.channelBS = _CBSD(sock=self._sock)
# self.channelCS = _CCSD(sock=self._sock)

* Mon 23 Sep 2013 03:55:57 PM JST
# self.channelBS = _CBSD(sock=self._sock)
# self.channelCS = _CCSD(sock=self._sock)

* Mon 23 Sep 2013 03:55:57 PM JST
# self.channelBS = _CBSD(sock=self._sock)
# self.channelCS = _CCSD(sock=self._sock)
# self.channelTB = _CTBD(sock=self._sock)

* Mon 23 Sep 2013 03:55:59 PM JST

* Mon 23 Sep 2013 03:55:59 PM JST

* Mon 23 Sep 2013 03:55:59 PM JST
self._loaded_cmd = True

* Mon 23 Sep 2013 03:56:11 PM JST
 = _OFTM(sock=self._sock)
* Mon 23 Sep 2013 03:56:11 PM JST
 = _ACHA(sock=self._sock)
* Mon 23 Sep 2013 03:56:11 PM JST
 = _MUTE(sock=self._sock)
* Mon 23 Sep 2013 03:56:11 PM JST
 = _WIDE(sock=self._sock)
* Mon 23 Sep 2013 03:56:11 PM JST
 = _PHSE(sock=self._sock)
* Mon 23 Sep 2013 03:56:11 PM JST
 = _CLCK(sock=self._sock)
* Mon 23 Sep 2013 03:56:11 PM JST
 = _VPOS(sock=self._sock)
* Mon 23 Sep 2013 03:56:11 PM JST
 = _HPOS(sock=self._sock)
* Mon 23 Sep 2013 03:56:11 PM JST
 = _VOLM(sock=self._sock)
* Mon 23 Sep 2013 03:56:11 PM JST
 = _AVMD(sock=self._sock)
* Mon 23 Sep 2013 03:56:11 PM JST
 = _INP4(sock=self._sock)
* Mon 23 Sep 2013 03:56:11 PM JST
 = _Channel(sock=self._sock)
* Mon 23 Sep 2013 03:56:11 PM JST
 = _IDEG(sock=self._sock)
* Mon 23 Sep 2013 03:56:11 PM JST
 = _IAVD(sock=self._sock)
* Mon 23 Sep 2013 03:56:11 PM JST
 = _ITVD(sock=self._sock)
* Mon 23 Sep 2013 03:56:12 PM JST
 = _ITGD(sock=self._sock)
* Mon 23 Sep 2013 03:56:12 PM JST
 = _POWR(sock=self._sock)
* Mon 23 Sep 2013 03:56:22 PM JST
        
* Mon 23 Sep 2013 03:56:24 PM JST
power
* Mon 23 Sep 2013 03:56:45 PM JST
        
* Mon 23 Sep 2013 03:56:47 PM JST
inputtoggle
* Mon 23 Sep 2013 03:56:54 PM JST
_inputtogle
* Mon 23 Sep 2013 03:57:19 PM JST
        
* Mon 23 Sep 2013 03:57:25 PM JST
        
* Mon 23 Sep 2013 03:57:30 PM JST
input
* Mon 23 Sep 2013 03:57:34 PM JST
input
* Mon 23 Sep 2013 03:57:40 PM JST
        
* Mon 23 Sep 2013 03:57:42 PM JST
channel
* Mon 23 Sep 2013 03:57:46 PM JST
channel
* Mon 23 Sep 2013 03:57:51 PM JST
        
* Mon 23 Sep 2013 03:57:53 PM JST
input4
* Mon 23 Sep 2013 03:57:56 PM JST
input4
* Mon 23 Sep 2013 03:58:02 PM JST
        
* Mon 23 Sep 2013 03:58:03 PM JST
avposition
* Mon 23 Sep 2013 03:58:07 PM JST
avposition
* Mon 23 Sep 2013 03:58:13 PM JST
        
* Mon 23 Sep 2013 03:58:15 PM JST
volume
* Mon 23 Sep 2013 03:58:18 PM JST
volume
* Mon 23 Sep 2013 03:58:23 PM JST
        
* Mon 23 Sep 2013 03:58:25 PM JST
horizon
* Mon 23 Sep 2013 03:58:30 PM JST
horizon
* Mon 23 Sep 2013 03:58:39 PM JST
        
* Mon 23 Sep 2013 03:58:42 PM JST
vertical
* Mon 23 Sep 2013 03:58:46 PM JST
vertical
* Mon 23 Sep 2013 03:58:51 PM JST
        
* Mon 23 Sep 2013 03:58:53 PM JST
clock
* Mon 23 Sep 2013 03:58:59 PM JST
clock
* Mon 23 Sep 2013 03:59:04 PM JST
        
* Mon 23 Sep 2013 03:59:06 PM JST
clockphese
* Mon 23 Sep 2013 03:59:09 PM JST
clockphese
* Mon 23 Sep 2013 03:59:13 PM JST
        
* Mon 23 Sep 2013 03:59:15 PM JST
display
* Mon 23 Sep 2013 03:59:23 PM JST
display
* Mon 23 Sep 2013 03:59:26 PM JST
        
* Mon 23 Sep 2013 03:59:27 PM JST
mute
* Mon 23 Sep 2013 03:59:30 PM JST
mute
* Mon 23 Sep 2013 03:59:34 PM JST
        
* Mon 23 Sep 2013 03:59:36 PM JST
audio
* Mon 23 Sep 2013 03:59:39 PM JST
audio
* Mon 23 Sep 2013 03:59:46 PM JST

* Mon 23 Sep 2013 03:59:46 PM JST

* Mon 23 Sep 2013 03:59:46 PM JST
        strs = []

* Mon 23 Sep 2013 04:02:40 PM JST
            def membercmds(obj):
                r"""SUMMARY

                @Return:
                """
                lis = []
                for memb in dir(obj):
                    if not memb.startswith('_'):
                        lis.append(memb)
                return lis


* Mon 23 Sep 2013 04:04:46 PM JST

* Mon 23 Sep 2013 04:04:46 PM JST

* Mon 23 Sep 2013 04:04:46 PM JST
            fmt = '{0:<12}: {1}'

* Mon 23 Sep 2013 04:26:10 PM JST
_sock.
* Mon 23 Sep 2013 04:28:03 PM JST
inputtoggle
* Mon 23 Sep 2013 04:31:10 PM JST
getattr(self, mem)
* Mon 23 Sep 2013 04:33:16 PM JST
'\n{0:=^30}'.format(' Sub commands ')
* Mon 23 Sep 2013 04:33:25 PM JST
command
* Mon 23 Sep 2013 04:33:53 PM JST
        for mem in membercmds(self):
            if not _isclass(getattr(self, mem)):
                strs.append(fmt.format(mem, type(getattr(self, mem))))

* Mon 23 Sep 2013 04:34:14 PM JST
not 
* Mon 23 Sep 2013 04:39:40 PM JST
Class
* Mon 23 Sep 2013 04:43:10 PM JST
not 
* Mon 23 Sep 2013 04:53:07 PM JST
                
* Mon 23 Sep 2013 04:53:38 PM JST
                
* Mon 23 Sep 2013 04:53:41 PM JST
                
* Mon 23 Sep 2013 04:53:43 PM JST
                
* Mon 23 Sep 2013 04:59:09 PM JST
inputtoggle
* Mon 23 Sep 2013 04:59:37 PM JST
power       : 'getstatus', 'isactive', 'off', 'on'
inputtoggle : 'getstatus', 'toggle'
inputtv     : 'getstatus', 'tv'
input       : 'getstatus', 'input'
channel     : 'BS', 'CS', 'CT', 'down', 'up'
input4      : 'auto', 'd_plug', 'getstatus', 'video_plug'
avposition  : 'avmemory', 'dynamic', 'game', 'getstatus', 'movie', 'pc', 'standard', 'static_dynamic', 'toggle'
volume      : 'getstatus', 'setvolume'
horizon     : 'getstatus'
vertical    : 'getstatus'
clock       : 'getstatus'
clockphese  : 'getstatus'
display     : 'cinema', 'dot_by_dot', 'full', 'full1', 'full2', 'getstatus', 'normal', 'toggle', 'underscan', 'wide169', 'wide43'
mute        : 'getstatus', 'off', 'on', 'toggle'
audio       : 'getstatus', 'toggle'
offtimer    : 'getstatus', 'h1', 'h1min30', 'h2', 'h2min30', 'min30', 'reset'

* Mon 23 Sep 2013 05:00:32 PM JST
CT
* Mon 23 Sep 2013 05:00:32 PM JST
channel.CT
* Mon 23 Sep 2013 05:00:41 PM JST
input4
* Mon 23 Sep 2013 05:00:47 PM JST
avposition
* Mon 23 Sep 2013 05:00:58 PM JST
volume
* Mon 23 Sep 2013 05:01:05 PM JST
horizon
* Mon 23 Sep 2013 05:01:12 PM JST
vertical
* Mon 23 Sep 2013 05:01:17 PM JST
clock
* Mon 23 Sep 2013 05:01:44 PM JST
clockphese
* Mon 23 Sep 2013 05:01:55 PM JST
clockphese
* Mon 23 Sep 2013 05:02:01 PM JST
mute
* Mon 23 Sep 2013 05:02:17 PM JST
mute
* Mon 23 Sep 2013 05:02:24 PM JST
audio
* Mon 23 Sep 2013 05:04:26 PM JST
    def getstatus(self):
        """SUMMARY

        @Return:
        """
        self._sock.send(self._cmds.get('check'))
        return self._sock.recv(1024)


* Mon 23 Sep 2013 05:04:31 PM JST
_ConnectAbstract
* Mon 23 Sep 2013 05:05:36 PM JST
_ConnectAbstract
* Mon 23 Sep 2013 05:05:43 PM JST
_ConnectAbstract
* Mon 23 Sep 2013 05:05:47 PM JST
_ConnectAbstract
* Mon 23 Sep 2013 05:06:15 PM JST
_ConnectAbstract
* Mon 23 Sep 2013 05:06:27 PM JST
_ConnectAbstract
* Mon 23 Sep 2013 05:06:41 PM JST
_ConnectAbstract
* Mon 23 Sep 2013 05:06:48 PM JST
_ConnectAbstract
* Mon 23 Sep 2013 05:07:07 PM JST
_ConnectAbstract
* Mon 23 Sep 2013 05:07:14 PM JST
_ConnectAbstract
* Mon 23 Sep 2013 05:07:29 PM JST
_ConnectAbstract
* Mon 23 Sep 2013 05:18:27 PM JST
    
* Mon 23 Sep 2013 05:22:52 PM JST
print(
* Mon 23 Sep 2013 05:25:13 PM JST
True
* Mon 23 Sep 2013 05:25:21 PM JST
self.getstatus()
* Mon 23 Sep 2013 05:25:33 PM JST
        if '2\r' == status:
            return False

* Mon 23 Sep 2013 05:25:42 PM JST
False
* Mon 23 Sep 2013 05:26:25 PM JST
False
* Mon 23 Sep 2013 05:26:25 PM JST
return False
* Mon 23 Sep 2013 05:29:04 PM JST
        self.power = _POWR(sock=self._sock)
        self.inputtoggle = _ITGD(sock=self._sock)
        self.inputtv = _ITVD(sock=self._sock)
        self.input = _IAVD(sock=self._sock)
        self.inputdegital = _IDEG(sock=self._sock)
        # self.channelBS = _CBSD(sock=self._sock)
        # self.channelCS = _CCSD(sock=self._sock)
        # self.channelTB = _CTBD(sock=self._sock)
        self.channel = _Channel(sock=self._sock)
        self.input4 = _INP4(sock=self._sock)
        self.avposition = _AVMD(sock=self._sock)
        self.volume = _VOLM(sock=self._sock)
        self.horizon = _HPOS(sock=self._sock)
        self.vertical = _VPOS(sock=self._sock)
        self.clock = _CLCK(sock=self._sock)
        self.clockphese = _PHSE(sock=self._sock)
        self.display = _WIDE(sock=self._sock)
        self.mute = _MUTE(sock=self._sock)
        self.audio = _ACHA(sock=self._sock)
        self.offtimer = _OFTM(sock=self._sock)
        self._loaded_cmd = True

* Mon 23 Sep 2013 05:34:25 PM JST
        self.power = _POWR(sock=self._sock)
        self.inputtoggle = _ITGD(sock=self._sock)
        self.inputtv = _ITVD(sock=self._sock)
        self.input = _IAVD(sock=self._sock)
        self.inputdegital = _IDEG(sock=self._sock)
        # self.channelBS = _CBSD(sock=self._sock)
        # self.channelCS = _CCSD(sock=self._sock)
        # self.channelTB = _CTBD(sock=self._sock)
        self.channel = _Channel(sock=self._sock)
        self.input4 = _INP4(sock=self._sock)
        self.avposition = _AVMD(sock=self._sock)
        self.volume = _VOLM(sock=self._sock)
        self.horizon = _HPOS(sock=self._sock)
        self.vertical = _VPOS(sock=self._sock)
        self.clock = _CLCK(sock=self._sock)
        self.clockphese = _PHSE(sock=self._sock)
        self.display = _WIDE(sock=self._sock)
        self.mute = _MUTE(sock=self._sock)
        self.audio = _ACHA(sock=self._sock)
        self.offtimer = _OFTM(sock=self._sock)
        self._loaded_cmd = True

* Mon 23 Sep 2013 05:35:06 PM JST

* Mon 23 Sep 2013 05:35:06 PM JST

* Mon 23 Sep 2013 05:35:06 PM JST
    # self.channelBS = _CBSD(sock=self._sock)

* Mon 23 Sep 2013 05:35:06 PM JST
    # self.channelBS = _CBSD(sock=self._sock)

* Mon 23 Sep 2013 05:35:06 PM JST
    # self.channelBS = _CBSD(sock=self._sock)
    # self.channelCS = _CCSD(sock=self._sock)

* Mon 23 Sep 2013 05:35:06 PM JST
    # self.channelBS = _CBSD(sock=self._sock)
    # self.channelCS = _CCSD(sock=self._sock)

* Mon 23 Sep 2013 05:35:06 PM JST
    # self.channelBS = _CBSD(sock=self._sock)
    # self.channelCS = _CCSD(sock=self._sock)
    # self.channelTB = _CTBD(sock=self._sock)

* Mon 23 Sep 2013 05:35:15 PM JST
self.
* Mon 23 Sep 2013 05:35:16 PM JST
self.
* Mon 23 Sep 2013 05:35:16 PM JST
self.
* Mon 23 Sep 2013 05:35:16 PM JST
self.
* Mon 23 Sep 2013 05:35:17 PM JST
self.
* Mon 23 Sep 2013 05:35:17 PM JST
self.
* Mon 23 Sep 2013 05:35:17 PM JST
self.
* Mon 23 Sep 2013 05:35:17 PM JST
self.
* Mon 23 Sep 2013 05:35:17 PM JST
self.
* Mon 23 Sep 2013 05:35:17 PM JST
self.
* Mon 23 Sep 2013 05:35:17 PM JST
self.
* Mon 23 Sep 2013 05:35:17 PM JST
self.
* Mon 23 Sep 2013 05:35:17 PM JST
self.
* Mon 23 Sep 2013 05:35:17 PM JST
self.
* Mon 23 Sep 2013 05:35:17 PM JST
self.
* Mon 23 Sep 2013 05:35:17 PM JST
self.
* Mon 23 Sep 2013 05:35:17 PM JST
self.
* Mon 23 Sep 2013 05:35:17 PM JST
self.
* Mon 23 Sep 2013 05:35:27 PM JST
True
* Mon 23 Sep 2013 05:35:27 PM JST
_OFTM(sock=self._sock)
* Mon 23 Sep 2013 05:35:27 PM JST
_ACHA(sock=self._sock)
* Mon 23 Sep 2013 05:35:27 PM JST
_MUTE(sock=self._sock)
* Mon 23 Sep 2013 05:35:27 PM JST
_WIDE(sock=self._sock)
* Mon 23 Sep 2013 05:35:27 PM JST
_PHSE(sock=self._sock)
* Mon 23 Sep 2013 05:35:27 PM JST
_CLCK(sock=self._sock)
* Mon 23 Sep 2013 05:35:27 PM JST
_VPOS(sock=self._sock)
* Mon 23 Sep 2013 05:35:27 PM JST
_HPOS(sock=self._sock)
* Mon 23 Sep 2013 05:35:27 PM JST
_VOLM(sock=self._sock)
* Mon 23 Sep 2013 05:35:27 PM JST
_AVMD(sock=self._sock)
* Mon 23 Sep 2013 05:35:27 PM JST
_INP4(sock=self._sock)
* Mon 23 Sep 2013 05:35:27 PM JST
_Channel(sock=self._sock)
* Mon 23 Sep 2013 05:35:27 PM JST
_IDEG(sock=self._sock)
* Mon 23 Sep 2013 05:35:28 PM JST
_IAVD(sock=self._sock)
* Mon 23 Sep 2013 05:35:28 PM JST
_ITVD(sock=self._sock)
* Mon 23 Sep 2013 05:35:28 PM JST
_ITGD(sock=self._sock)
* Mon 23 Sep 2013 05:35:28 PM JST
_POWR(sock=self._sock)
* Mon 23 Sep 2013 05:35:32 PM JST

* Mon 23 Sep 2013 05:35:32 PM JST

* Mon 23 Sep 2013 05:35:32 PM JST
    _loaded_cmd = None

* Mon 23 Sep 2013 05:38:40 PM JST
'ERR\r'
* Mon 23 Sep 2013 05:39:44 PM JST
r'
* Mon 23 Sep 2013 05:41:00 PM JST
getstatus
* Mon 23 Sep 2013 05:41:40 PM JST
self._send(self._cmds.get('format').format(num))
* Mon 23 Sep 2013 05:45:14 PM JST

* Mon 23 Sep 2013 05:45:14 PM JST

* Mon 23 Sep 2013 05:45:14 PM JST
        print(repr(recv))

* Mon 23 Sep 2013 05:49:42 PM JST
    def volumeup(self):
        r"""SUMMARY
        
        @Return:
        """
        currvol = int(self.getstatus().strip())
        newvol = currvol + 1
        if self.setvolume(newvol):
            return newvol
        else:
            return None

* Mon 23 Sep 2013 05:51:20 PM JST
newvol
* Mon 23 Sep 2013 05:51:26 PM JST
self.getstatus().strip()
* Mon 23 Sep 2013 05:56:09 PM JST
0 <= num <= 100
* Mon 23 Sep 2013 05:56:21 PM JST
num
* Mon 23 Sep 2013 05:56:30 PM JST

* Mon 23 Sep 2013 05:56:30 PM JST

* Mon 23 Sep 2013 05:56:30 PM JST
        if newvol == 101:

* Mon 23 Sep 2013 05:56:31 PM JST

* Mon 23 Sep 2013 05:56:31 PM JST

* Mon 23 Sep 2013 05:56:31 PM JST
        if newvol <= 0:

* Mon 23 Sep 2013 05:56:33 PM JST
        if newvol <= 0:

* Mon 23 Sep 2013 05:56:33 PM JST
        if newvol <= 0:
            print('bottom to limit {}'.format(newvol))

* Mon 23 Sep 2013 05:56:33 PM JST
        if newvol <= 0:
            print('bottom to limit {}'.format(newvol))

* Mon 23 Sep 2013 05:56:33 PM JST
        if newvol <= 0:
            print('bottom to limit {}'.format(newvol))
            return None

* Mon 23 Sep 2013 05:57:02 PM JST
        currvol = int(self.getstatus().strip())
        newvol = currvol + 1
        if self.setvolume(newvol):
            return newvol
        else:
            return None

* Mon 23 Sep 2013 06:07:54 PM JST
self.
* Mon 23 Sep 2013 06:09:50 PM JST
self.__str__()
* Mon 23 Sep 2013 06:10:23 PM JST
str(self) + '\n' + self.__str__()
* Mon 23 Sep 2013 06:29:01 PM JST
win
* Mon 23 Sep 2013 06:30:11 PM JST
        win = self._display.get_input_focus().focus
        if win.get_wm_name() is None and win.get_wm_class() is None:
            win = win.query_tree().parent
        return win

* Mon 23 Sep 2013 06:30:58 PM JST
_
* Mon 23 Sep 2013 06:30:59 PM JST
self._
* Mon 23 Sep 2013 06:32:20 PM JST
        return (self._root.get_full_property(self._display.intern_atom(
            '_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value)

* Mon 23 Sep 2013 06:33:33 PM JST
_
* Mon 23 Sep 2013 06:33:33 PM JST
self._
* Mon 23 Sep 2013 06:33:38 PM JST
_
* Mon 23 Sep 2013 06:33:38 PM JST
self._
* Mon 23 Sep 2013 06:35:29 PM JST
    def get_pid(self, win):
        r"""SUMMARY

        @Arguments:
        - `win`:

        @Return:
        """
        pid_reply = win.get_property(self._display.intern_atom('_NET_WM_PID'),
                                     X.AnyPropertyType, 0, 10)
        return int(pid_reply.value.tolist()[0])

* Mon 23 Sep 2013 06:35:43 PM JST
self, 
* Mon 23 Sep 2013 06:35:48 PM JST
_
* Mon 23 Sep 2013 06:35:49 PM JST
self._
* Mon 23 Sep 2013 08:39:41 PM JST
title
* Mon 23 Sep 2013 08:39:47 PM JST
Comix
* Mon 23 Sep 2013 08:39:51 PM JST
klass
* Mon 23 Sep 2013 08:40:17 PM JST
regexp
* Mon 23 Sep 2013 08:40:44 PM JST
getwindowsclass2()
* Mon 23 Sep 2013 08:41:05 PM JST
Google-chrome
* Mon 23 Sep 2013 08:55:17 PM JST
~/.pylib/myxlib/
* Mon 23 Sep 2013 09:52:30 PM JST
Popen
* Mon 23 Sep 2013 09:52:30 PM JST
sbp.Popen
* Mon 23 Sep 2013 09:57:04 PM JST
        if not passwd.endswith('\n'):
            passwd += '\n'

* Mon 23 Sep 2013 10:32:11 PM JST

* Mon 23 Sep 2013 10:32:11 PM JST

* Mon 23 Sep 2013 10:32:11 PM JST
    def __init__(self, ):

* Mon 23 Sep 2013 10:32:11 PM JST
    def __init__(self, ):

* Mon 23 Sep 2013 10:32:11 PM JST
    def __init__(self, ):
        r"""

* Mon 23 Sep 2013 10:32:13 PM JST

* Mon 23 Sep 2013 10:32:13 PM JST

* Mon 23 Sep 2013 10:32:13 PM JST
        """

* Mon 23 Sep 2013 10:32:45 PM JST
def determine_target_window(title=None, klass=None, pid=None,
                            activewin=None, regexp=None):
    r"""Determine target window by title, class, pid, active window or regexp title.

    @Arguments:
    - `title`:
    - `klass`:
    - `pid`:
    - `activewin`:
    - `regexp`:

    @Return: Window object or None.
    """
    display =  Xlib.display.Display()
    # active window
    if activewin is not None:
        return getactivewindow()

    if not (title or klass or pid or activewin or regexp):
        return None

    # parse other windows
    windowIDs = display.screen().root.get_full_property(
        display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
    for id_ in windowIDs:
        win = display.create_resource_object('window', id_)
        if win is None:
            continue
        if title is not None and title == win.get_wm_name():
            return display, win
        if klass is not None and klass == win.get_wm_class():
            return display, win
        # not inplimented pid
        if ((regexp is not None) and
            (_re.search(regexp, win.get_wm_name()) is not None)):
            return display, win
    # not match
    return None

* Mon 23 Sep 2013 10:33:11 PM JST
class GatherWindow(_Display):
    r"""
    """


* Mon 23 Sep 2013 10:33:43 PM JST

* Mon 23 Sep 2013 10:33:43 PM JST

* Mon 23 Sep 2013 10:33:43 PM JST
        display = Xlib.display.Display()

* Mon 23 Sep 2013 10:33:43 PM JST
        display = Xlib.display.Display()

* Mon 23 Sep 2013 10:33:43 PM JST
        display = Xlib.display.Display()
        root = display.screen().root

* Mon 23 Sep 2013 10:34:44 PM JST
_display, 
* Mon 23 Sep 2013 10:34:45 PM JST
self._display, 
* Mon 23 Sep 2013 10:35:04 PM JST
display,
* Mon 23 Sep 2013 10:35:25 PM JST
display=
* Mon 23 Sep 2013 10:36:00 PM JST
def get_pid(display, win):
    r"""SUMMARY

    @Arguments:
    - `win`:

    @Return:
    """
    pid_reply = win.get_property(display.intern_atom('_NET_WM_PID'),
                                 X.AnyPropertyType, 0, 10)
    return int(pid_reply.value.tolist()[0])


* Mon 23 Sep 2013 10:36:12 PM JST
display,
* Mon 23 Sep 2013 10:36:39 PM JST
_display, 
* Mon 23 Sep 2013 10:36:40 PM JST
self._display, 
* Mon 23 Sep 2013 10:37:44 PM JST
display
* Mon 23 Sep 2013 10:38:06 PM JST
root
* Mon 23 Sep 2013 10:38:06 PM JST
display, root
* Mon 23 Sep 2013 10:38:50 PM JST
_root
* Mon 23 Sep 2013 10:38:50 PM JST
self._root
* Mon 23 Sep 2013 10:38:50 PM JST
_display, self._root
* Mon 23 Sep 2013 10:38:51 PM JST
self._display, self._root
* Mon 23 Sep 2013 10:38:57 PM JST
_display
* Mon 23 Sep 2013 10:38:57 PM JST
self._display
* Mon 23 Sep 2013 10:41:53 PM JST
def winexists(**args):
    r"""SUMMARY

    @Arguments:
    - `**args`:

    @Return:
    """
    display, win = determine_target_window(title=args.get('title'),
                                  klass=args.get('klass'),
                                  pid=args.get('pid'),
                                  activewin=args.get('activewin'),
                                  regexp=args.get('regexp'))
    if win is not None:
        return True
    return False


* Mon 23 Sep 2013 10:42:44 PM JST
win
* Mon 23 Sep 2013 10:43:23 PM JST
args
* Mon 23 Sep 2013 10:43:43 PM JST
self, title=None, klass=None, pid=None,
                         active=None, regexp=None
* Mon 23 Sep 2013 10:43:50 PM JST
                         
* Mon 23 Sep 2013 10:46:26 PM JST
                                   
* Mon 23 Sep 2013 10:47:55 PM JST
    def existswin(self, title=None, klass=None, pid=None, active=None,
                  regexp=None):
        r"""SUMMARY

        @Arguments:
        - `**args`:

        @Return:
        """
        return self.get_target_win(title=title, klass=klass, pid=None,
                                   active=None, regexp=regexp)


* Mon 23 Sep 2013 10:51:06 PM JST
determine
* Mon 23 Sep 2013 10:51:14 PM JST
determine
* Mon 23 Sep 2013 10:51:24 PM JST
determine
* Mon 23 Sep 2013 10:52:10 PM JST
iswin
* Mon 23 Sep 2013 10:52:19 PM JST
determine
* Mon 23 Sep 2013 10:53:50 PM JST
    windowIDs = root.get_full_property(display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
    for id_ in windowIDs:
        win = display.create_resource_object('window', id_)
        yield win.get_wm_name()

* Mon 23 Sep 2013 10:55:28 PM JST
win = display.create_resource_object('window', id_)
* Mon 23 Sep 2013 10:55:43 PM JST
win = 
* Mon 23 Sep 2013 10:55:55 PM JST
SUMMARY
* Mon 23 Sep 2013 10:57:23 PM JST
    def get_win_names(self):
        r"""SUMMARY
        
        @Return:
        """
        for win in self.get_wins:
            if win is not None:
                yield win.get_wm_name()

* Mon 23 Sep 2013 11:02:10 PM JST

* Mon 23 Sep 2013 11:02:10 PM JST

* Mon 23 Sep 2013 11:02:10 PM JST
# TODO: (Atami) [2013/09/23]

* Mon 23 Sep 2013 11:02:10 PM JST
# TODO: (Atami) [2013/09/23]

* Mon 23 Sep 2013 11:02:10 PM JST
# TODO: (Atami) [2013/09/23]
#

* Mon 23 Sep 2013 11:02:18 PM JST
class GatherWindow(_Display):
    r"""
    """

    def existswin(self, title=None, klass=None, pid=None, active=None,
                  regexp=None):
        r"""SUMMARY

        @Arguments:
        - `**args`:

        @Return:
        """
        return self.get_target_win(title=title, klass=klass, pid=None,
                                   active=None, regexp=regexp)

    def get_target_win(self, title=None, klass=None, pid=None,
                        active=None, regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return: if exists window object, and not exists return None.
        """
        # prevent
        if not (title or klass or pid or active or regexp):
            return None
        # active window
        if active is not None:
            return self.get_active_win().id
        # parse other windows
        for id_ in self.get_win_ids():
            win = self._display.create_resource_object('window', id_)
            if win is None:
                continue
            if self.confirm_win(win=win, title=title, klass=klass,
                                  pid=pid, regexp=regexp):
                return win
        # not matched
        return None

    def confirm_win(self, win, title=None, klass=None, pid=None, regexp=None):
        r"""SUMMARY

        @Arguments:

        - `win`:
        - `title`:
        - `klass`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        if win is None:
            return False
        # title or klass or pid or regexp
        if ((title is not None and title == win.get_wm_name()) or
            (klass is not None and klass == win.get_wm_class()) or
            (pid is not None and pid == self.get_win_pid(win)) or
            (regexp is not None and
             (_re.search(regexp, win.get_wm_name()) is not None))):
            return True
        return False

    def get_win_pid(self, win):
        r"""SUMMARY

        @Arguments:
        - `win`:

        @Return:
        """
        pid_reply = win.get_property(self._display.intern_atom('_NET_WM_PID'),
                                     X.AnyPropertyType, 0, 10)
        return int(pid_reply.value.tolist()[0])

    def get_active_win(self):
        r"""SUMMARY

        @Return:
        """
        win = self._display.get_input_focus().focus
        if win.get_wm_name() is None and win.get_wm_class() is None:
            win = win.query_tree().parent
        return win

    def get_win_ids(self):
        r"""SUMMARY

        @Return:
        """
        return (self._root.get_full_property(self._display.intern_atom(
        '_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value)

    def get_wins(self):
        r"""Generator

        @Return:
        """
        for id_ in self.get_win_ids():
            yield self._display.create_resource_object('window', id_)

    def get_win_names(self):
        r"""SUMMARY

        @Return:
        """
        for win in self.get_wins:
            if win is not None:
                yield win.get_wm_name()

    def get_win_classes(self):
        r"""SUMMARY

        @Return:
        """
        for win in self.get_wins:
            if win is not None:
                yield win.get_wm_class()


* Mon 23 Sep 2013 11:03:32 PM JST

* Mon 23 Sep 2013 11:03:32 PM JST

* Mon 23 Sep 2013 11:03:32 PM JST
        return self.

* Mon 23 Sep 2013 11:05:31 PM JST
    def get_win_ids(self):
        r"""SUMMARY

        @Return:
        """
        return (self._root.get_full_property(self._display.intern_atom(
            '_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value)


* Mon 23 Sep 2013 11:57:51 PM JST
class GatherWindow(_Display):
    r"""
    """

    def existswin(self, title=None, klass=None, pid=None, active=None,
                  regexp=None):
        r"""SUMMARY

        @Arguments:
        - `**args`:

        @Return:
        """
        return self.get_target_win(title=title, klass=klass, pid=None,
                                   active=None, regexp=regexp)

    def get_win_ids(self):
        r"""SUMMARY

        @Return:
        """
        return (self._root.get_full_property(self._display.intern_atom(
            '_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value)

    def get_target_win(self, title=None, klass=None, pid=None,
                        active=None, regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return: if exists window object, and not exists return None.
        """
        # prevent
        if not (title or klass or pid or active or regexp):
            return None
        # active window
        if active is not None:
            return self.get_active_win().id
        # parse other windows
        for id_ in self.get_win_ids():
            win = self._display.create_resource_object('window', id_)
            if win is None:
                continue
            if self.confirm_win(win=win, title=title, klass=klass,
                                  pid=pid, regexp=regexp):
                return win
        # not matched
        return None

    def confirm_win(self, win, title=None, klass=None, pid=None, regexp=None):
        r"""SUMMARY

        @Arguments:

        - `win`:
        - `title`:
        - `klass`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        if win is None:
            return False
        # title or klass or pid or regexp
        if ((title is not None and title == win.get_wm_name()) or
            (klass is not None and klass == win.get_wm_class()) or
            (pid is not None and pid == self.get_win_pid(win)) or
            (regexp is not None and
             (_re.search(regexp, win.get_wm_name()) is not None))):
            return True
        return False

    def get_win_pid(self, win):
        r"""SUMMARY

        @Arguments:
        - `win`:

        @Return:
        """
        pid_reply = win.get_property(self._display.intern_atom('_NET_WM_PID'),
                                     X.AnyPropertyType, 0, 10)
        return int(pid_reply.value.tolist()[0])

    def get_active_win(self):
        r"""SUMMARY

        @Return:
        """
        self._get_active_win()

    def get_wins(self):
        r"""Generator

        @Return:
        """
        for id_ in self.get_win_ids():
            yield self._display.create_resource_object('window', id_)

    def get_win_names(self):
        r"""SUMMARY

        @Return:
        """
        for win in self.get_wins:
            if win is not None:
                yield win.get_wm_name()

    def get_win_classes(self):
        r"""SUMMARY

        @Return:
        """
        for win in self.get_wins:
            if win is not None:
                yield win.get_wm_class()


* Tue 24 Sep 2013 12:25:52 AM JST
dir(
* Tue 24 Sep 2013 12:26:13 AM JST
get_geometry
* Tue 24 Sep 2013 12:36:37 AM JST
pass
* Tue 24 Sep 2013 01:34:06 AM JST
dic.update(
* Tue 24 Sep 2013 01:34:40 AM JST
get_geometry()
* Tue 24 Sep 2013 01:42:01 AM JST
pass
* Tue 24 Sep 2013 01:42:36 AM JST
_window
* Tue 24 Sep 2013 01:42:36 AM JST
self._window
* Tue 24 Sep 2013 01:42:51 AM JST
_window
* Tue 24 Sep 2013 01:44:55 AM JST
                          
* Tue 24 Sep 2013 01:46:33 AM JST
get_geometry
* Tue 24 Sep 2013 01:58:35 AM JST
.format(self.id, self.name, self.klass, self.x, self.y, self.height, self.width)
* Tue 24 Sep 2013 02:03:58 AM JST

* Tue 24 Sep 2013 02:03:58 AM JST

* Tue 24 Sep 2013 02:03:58 AM JST
        fmt = 

* Tue 24 Sep 2013 02:05:23 AM JST
'\n{0:<7}: {1}'
* Tue 24 Sep 2013 02:05:46 AM JST
        
* Tue 24 Sep 2013 02:05:47 AM JST
id
* Tue 24 Sep 2013 02:05:51 AM JST
id
* Tue 24 Sep 2013 02:05:53 AM JST
        
* Tue 24 Sep 2013 02:05:55 AM JST
name
* Tue 24 Sep 2013 02:05:58 AM JST
name
* Tue 24 Sep 2013 02:06:03 AM JST
        
* Tue 24 Sep 2013 02:06:04 AM JST
klass
* Tue 24 Sep 2013 02:06:08 AM JST
klass
* Tue 24 Sep 2013 02:06:11 AM JST
        
* Tue 24 Sep 2013 02:06:16 AM JST
        
* Tue 24 Sep 2013 02:06:27 AM JST
        
* Tue 24 Sep 2013 02:06:28 AM JST
height
* Tue 24 Sep 2013 02:06:33 AM JST
height
* Tue 24 Sep 2013 02:06:37 AM JST
        
* Tue 24 Sep 2013 02:06:38 AM JST
width
* Tue 24 Sep 2013 02:06:44 AM JST
width
* Tue 24 Sep 2013 02:06:44 AM JST
width        str_.append(fmt.format('width', self.))

* Tue 24 Sep 2013 02:08:58 AM JST
ww._window.get_geometory()
* Tue 24 Sep 2013 02:14:10 AM JST
_window
* Tue 24 Sep 2013 02:14:11 AM JST
ww._window
* Tue 24 Sep 2013 02:15:13 AM JST
w = g.existswin(title='Comix')
* Tue 24 Sep 2013 02:30:09 AM JST
for VAR in COLLECTION:
* Tue 24 Sep 2013 02:39:42 AM JST
        if not (title or klass or pid or active or regexp):
            return None

* Tue 24 Sep 2013 02:40:00 AM JST
if not 
* Tue 24 Sep 2013 02:40:04 AM JST

* Tue 24 Sep 2013 02:40:04 AM JST

* Tue 24 Sep 2013 02:40:04 AM JST
            return None

* Tue 24 Sep 2013 02:40:14 AM JST

* Tue 24 Sep 2013 02:40:14 AM JST

* Tue 24 Sep 2013 02:40:14 AM JST
        if not (title is None ):

* Tue 24 Sep 2013 02:40:23 AM JST
active
* Tue 24 Sep 2013 02:40:23 AM JST
or active
* Tue 24 Sep 2013 02:44:07 AM JST
and
* Tue 24 Sep 2013 02:44:08 AM JST
0 and
* Tue 24 Sep 2013 02:44:08 AM JST
wait != 0 and
* Tue 24 Sep 2013 02:47:50 AM JST
        assert type(sec) is types.IntType
        assert title or klass or pid or regexp

        wait = sec * 2
        count = 0
        while 1:
            if self.existswin(title=title, klass=klass, pid=pid, regexp=regexp):
                return True
            sleep(0.5)
            if wait != 0:
                count += 0.5
                if wait <= count:
                    return False

* Tue 24 Sep 2013 02:54:50 AM JST
if win is None
* Tue 24 Sep 2013 02:54:51 AM JST
:
* Tue 24 Sep 2013 02:54:53 AM JST
win = 
* Tue 24 Sep 2013 03:01:14 AM JST
        assert type(sec) is types.IntType
        assert title or klass or pid or regexp

        wait = sec * 2
        count = 0
        while 1:
            if self.existswin(title=title, klass=klass, pid=pid, regexp=regexp):
                return True
            sleep(0.5)
            if wait != 0:
                count += 0.5
                if wait <= count:
                    return False

* Tue 24 Sep 2013 03:01:49 AM JST
existswin
* Tue 24 Sep 2013 03:02:41 AM JST
    def winwaitactive(self, sec, title=None, klass=None, pid=None, regexp=None):
        r"""SUMMARY
        
        @Arguments:
        
        - `title`:
        - `klass`:
        - `pid`:
        - `regexp`:
        
        @Return:
        """
        assert type(sec) is types.IntType
        assert title or klass or pid or regexp

        wait = sec * 2
        count = 0
        while 1:
            if self.winactive(title=title, klass=klass, pid=pid, regexp=regexp):
                return True
            sleep(0.5)
            if wait != 0:
                count += 0.5
                if wait <= count:
                    return False

* Tue 24 Sep 2013 03:03:37 AM JST
sleep(10); 
* Tue 24 Sep 2013 03:04:05 AM JST
None
* Tue 24 Sep 2013 03:18:57 AM JST
get_active_win
* Tue 24 Sep 2013 03:21:04 AM JST
WindowManager(self.get_active_win().id)
* Tue 24 Sep 2013 03:21:41 AM JST
get_geometry()
* Tue 24 Sep 2013 03:24:43 AM JST
reset_maximize
* Tue 24 Sep 2013 03:24:50 AM JST
reset_fullscreen
* Tue 24 Sep 2013 03:24:57 AM JST
reset_shade
* Tue 24 Sep 2013 03:25:19 AM JST
reset_above
* Tue 24 Sep 2013 03:25:25 AM JST
reset_below
* Tue 24 Sep 2013 03:42:51 AM JST
X.RevertToNone, X.CurrentTime
* Tue 24 Sep 2013 03:44:36 AM JST
X.RevertToNone, X.CurrentTime
* Tue 24 Sep 2013 03:45:33 AM JST
        self._win.set_input_focus(X.RevertToNone, X.CurrentTime)
        self._win.configure(stack_mode=X.Above)

* Tue 24 Sep 2013 03:46:59 AM JST
_display
* Tue 24 Sep 2013 03:57:50 AM JST
        self._window.set_input_focus(X.RevertToNone, X.CurrentTime)
        self._window.configure(stack_mode=X.Above)
        self._sync()

* Tue 24 Sep 2013 03:57:54 AM JST
Above
* Tue 24 Sep 2013 04:02:04 AM JST

* Tue 24 Sep 2013 04:02:04 AM JST

* Tue 24 Sep 2013 04:02:05 AM JST
        (save-excursion

* Tue 24 Sep 2013 04:03:12 AM JST

* Tue 24 Sep 2013 04:03:12 AM JST

* Tue 24 Sep 2013 04:03:12 AM JST
        (progn

* Tue 24 Sep 2013 04:03:27 AM JST

* Tue 24 Sep 2013 04:03:28 AM JST

* Tue 24 Sep 2013 04:03:28 AM JST
      ;; (forward-line -1)

* Tue 24 Sep 2013 04:03:30 AM JST
      
* Tue 24 Sep 2013 04:05:40 AM JST

* Tue 24 Sep 2013 04:05:40 AM JST

* Tue 24 Sep 2013 04:05:40 AM JST
        # TODO: (Atami) [2013/09/24]

* Tue 24 Sep 2013 04:06:10 AM JST
(defun annotation-anotated-this-line-p ()
  "anotated-this-line-p"
  (save-excursion
    (end-of-line)
    (re-search-backward (annotation-make-re)
                        (save-excursion
                          (beginning-of-line) (point)) 'noerror)
    (let ((face (what-face-at-point)))
      (if (or (eq 'font-lock-comment-face face)
              (member 'font-lock-comment-face face))
          (point)
        nil))))
* Tue 24 Sep 2013 04:09:53 AM JST
predicate
* Tue 24 Sep 2013 04:16:59 AM JST
(defvar annotation-list '("TODO" "FIXME" "BUG" "WARNING" "KLUDGE"))
(defvar annotation-format " %s: (%s) [%s]")
(defvar annotation-timestamp-format "%Y/%m/%d")

(global-set-key "\C-\M-o" 'annotation)
(autoload 'll-debug-open-fresh-line "ll-debug")
(defun annotation ()
  "Insert Annotation tag from `annotation-list'."
  (interactive)
  (let ((p (annotation-line-p)))
    (if p
        (save-excursion
        (goto-char p)
          (let* ((bounds (bounds-of-thing-at-point 'word))
                 (str (match-string 0))
                 (n (which-in-list str annotation-list)))
            (delete-region (car bounds) (cdr bounds))
            (insert (nth (if (eq (1+ n) (length annotation-list))
                             0
                           (1+ n))
                         annotation-list))))
      (ll-debug-open-fresh-line)
      (insert (concat (replace-regexp-in-string " " "" comment-start)
                      (format annotation-format
                              (car annotation-list)
                              user-full-name
                              (format-time-string annotation-timestamp-format)
                              )))
      (forward-line)
      (indent-according-to-mode))))

(defun annotation-line-p ()
  "Predicate in annotation line."
  (save-excursion
    (end-of-line)
    (re-search-backward (annotation-make-re)
                        (save-excursion
                          (beginning-of-line) (point)) 'noerror)
    (let ((face (what-face-at-point)))
      (if (or (eq 'font-lock-comment-face face)
              (member 'font-lock-comment-face face))
          (point)
        nil))))

(defun annotation-make-re ()
  "Annotation REGEXP."
  (let ((re "\\(?:")
        notfirst)
    (dolist (el annotation-list)
      (if notfirst
          (setq re (concat re "\\|" el))
        (setq notfirst t)
        (setq re (concat re el)))
      )
    (concat re "\\)")))

(defun which-in-list (target list)
  "Return nth of list.
TARGET: (str)
LIST: list"
  (let ((n 0)
        (len (length list))
        done)
    (while (and (not done)
                (> len n))
      (if (string= target (nth n list))
          (setq done t)
        (setq n (1+ n))))
    (if (> len n)
        n nil)))

* Tue 24 Sep 2013 04:17:47 AM JST

* Tue 24 Sep 2013 04:17:47 AM JST

* Tue 24 Sep 2013 04:17:47 AM JST
(autoload 'll-debug-open-fresh-line "ll-debug")

* Tue 24 Sep 2013 04:18:00 AM JST

* Tue 24 Sep 2013 04:18:00 AM JST

* Tue 24 Sep 2013 04:18:00 AM JST
(require 'll-debug nil 'noerror)

* Tue 24 Sep 2013 04:18:29 AM JST
(global-set-key "\C-\M-o" 'annotation)
* Tue 24 Sep 2013 04:19:04 AM JST
key 
* Tue 24 Sep 2013 04:19:04 AM JST
set-key 
* Tue 24 Sep 2013 04:19:05 AM JST
global-set-key 
* Tue 24 Sep 2013 04:19:46 AM JST
annotation
* Tue 24 Sep 2013 04:19:58 AM JST
annotation
* Tue 24 Sep 2013 04:19:59 AM JST
annotation-line-p
* Tue 24 Sep 2013 04:20:08 AM JST
annotation-make-re
* Tue 24 Sep 2013 04:20:20 AM JST
which
* Tue 24 Sep 2013 04:20:21 AM JST
which-in-list
* Tue 24 Sep 2013 04:20:47 AM JST
annotation
* Tue 24 Sep 2013 04:20:48 AM JST
annotation-list
* Tue 24 Sep 2013 04:20:57 AM JST
annotation-format
* Tue 24 Sep 2013 04:21:08 AM JST
annotation-timestamp-format
* Tue 24 Sep 2013 04:35:53 AM JST

* Tue 24 Sep 2013 04:35:53 AM JST

* Tue 24 Sep 2013 04:35:53 AM JST
    def __init__(self, ):

* Tue 24 Sep 2013 04:35:53 AM JST
    def __init__(self, ):

* Tue 24 Sep 2013 04:35:53 AM JST
    def __init__(self, ):
        r"""

* Tue 24 Sep 2013 04:35:53 AM JST
    def __init__(self, ):
        r"""

* Tue 24 Sep 2013 04:35:53 AM JST
    def __init__(self, ):
        r"""
        """

* Tue 24 Sep 2013 04:36:03 AM JST
    def _get_active_win(self):
        r"""SUMMARY

        @Return:
        """
        win = self._display.get_input_focus().focus
        if win.get_wm_name() is None and win.get_wm_class() is None:
            win = win.query_tree().parent
        return win

* Tue 24 Sep 2013 04:37:28 AM JST
    def activate(self):
        r"""SUMMARY

        @Return:
        """
        self._window.set_input_focus(X.RevertToNone, X.CurrentTime)
        self._window.configure(stack_mode=X.Above)
        self._sync()

    def deactive(self):
        r"""SUMMARY

        @Return:
        """
        self._window.set_input_focus(X.RevertToNone, X.CurrentTime)
        self._window.configure(stack_mode=X.Below)
        self._sync()


* Tue 24 Sep 2013 04:41:25 AM JST
_window
* Tue 24 Sep 2013 04:41:27 AM JST
w
* Tue 24 Sep 2013 04:41:28 AM JST
self.w
* Tue 24 Sep 2013 04:41:33 AM JST
_window
* Tue 24 Sep 2013 04:41:33 AM JST
self._window
* Tue 24 Sep 2013 04:41:39 AM JST
Above
* Tue 24 Sep 2013 04:42:00 AM JST
    def _sync(self):
        r"""SUMMARY

        @Return:
        """
        self._display.sync()


* Tue 24 Sep 2013 04:42:37 AM JST
True
* Tue 24 Sep 2013 04:42:38 AM JST
above=True
* Tue 24 Sep 2013 04:42:45 AM JST
self.
* Tue 24 Sep 2013 04:43:30 AM JST

* Tue 24 Sep 2013 04:43:30 AM JST

* Tue 24 Sep 2013 04:43:30 AM JST
        self._window.set_input_focus(X.RevertToNone, X.CurrentTime)

* Tue 24 Sep 2013 04:43:30 AM JST
        self._window.set_input_focus(X.RevertToNone, X.CurrentTime)

* Tue 24 Sep 2013 04:43:30 AM JST
        self._window.set_input_focus(X.RevertToNone, X.CurrentTime)
        self._window.configure(stack_mode=X.Below)

* Tue 24 Sep 2013 04:43:30 AM JST
        self._window.set_input_focus(X.RevertToNone, X.CurrentTime)
        self._window.configure(stack_mode=X.Below)

* Tue 24 Sep 2013 04:43:30 AM JST
        self._window.set_input_focus(X.RevertToNone, X.CurrentTime)
        self._window.configure(stack_mode=X.Below)
        self._sync()

* Tue 24 Sep 2013 04:44:17 AM JST
    def activate(self, win):
        r"""SUMMARY
        
        @Arguments:
        
        - `above`:
        
        @Return:
        """
        self._activate(win, above=True)

    def deactivate(self, win):
        r"""SUMMARY

        @Return:
        """
        self._activate(win, above=False)

* Tue 24 Sep 2013 04:44:54 AM JST
OVERRIDE
* Tue 24 Sep 2013 04:45:15 AM JST
Override ActiveWindow
* Tue 24 Sep 2013 04:45:23 AM JST
win
* Tue 24 Sep 2013 06:02:09 AM JST
    def get_target_win(self, title=None, klass=None, pid=None,
                        active=None, regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return: if exists window object, and not exists return None.
        """
        # prevent
        if not (title or klass or pid or active or regexp):
            return None

        # active window
        if active is not None:
            return self.get_active_win().id
        # parse other windows
        for id_ in self.get_win_ids():
            win = self._display.create_resource_object('window', id_)
            if win is None:
                continue
            if self.confirm_win(win=win, title=title, klass=klass,
                                  pid=pid, regexp=regexp):
                return WindowManager(win.id)
        # not matched
        return None

    def confirm_win(self, win, title=None, klass=None, pid=None, regexp=None):
        r"""SUMMARY

        @Arguments:

        - `win`:
        - `title`:
        - `klass`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        if win is None:
            return False
        # title or klass or pid or regexp
        if ((title is not None and title == win.get_wm_name()) or
            (klass is not None and klass == win.get_wm_class()) or
            (pid is not None and pid == self.get_win_pid(win)) or
            (regexp is not None and
             (_re.search(regexp, win.get_wm_name()) is not None))):
            return True
        return False

* Tue 24 Sep 2013 06:02:27 AM JST
self, 
* Tue 24 Sep 2013 06:02:29 AM JST
                    
* Tue 24 Sep 2013 06:02:31 AM JST
None, 
* Tue 24 Sep 2013 06:02:32 AM JST
active=None, 
* Tue 24 Sep 2013 06:02:36 AM JST
active
* Tue 24 Sep 2013 06:03:12 AM JST
_
* Tue 24 Sep 2013 06:03:13 AM JST
self._
* Tue 24 Sep 2013 06:03:31 AM JST
    def get_win_ids(self):
        r"""SUMMARY

        @Return:
        """
        return (self._root.get_full_property(self._display.intern_atom(
            '_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value)

* Tue 24 Sep 2013 06:03:51 AM JST
self
* Tue 24 Sep 2013 06:04:18 AM JST
display
* Tue 24 Sep 2013 06:04:21 AM JST
_
* Tue 24 Sep 2013 06:04:22 AM JST
self._
* Tue 24 Sep 2013 06:04:25 AM JST
_
* Tue 24 Sep 2013 06:04:25 AM JST
self._
* Tue 24 Sep 2013 06:04:27 AM JST
.root
* Tue 24 Sep 2013 06:04:30 AM JST
root
* Tue 24 Sep 2013 06:05:41 AM JST
self.
* Tue 24 Sep 2013 06:06:28 AM JST
other 
* Tue 24 Sep 2013 06:06:46 AM JST
self.
* Tue 24 Sep 2013 06:06:57 AM JST
                              
* Tue 24 Sep 2013 06:09:14 AM JST
self, 
* Tue 24 Sep 2013 06:09:25 AM JST
self.
* Tue 24 Sep 2013 06:09:43 AM JST
    def get_win_pid(self, win):
        r"""SUMMARY

        @Arguments:
        - `win`:

        @Return:
        """
        pid_reply = win.get_property(self._display.intern_atom('_NET_WM_PID'),
                                     X.AnyPropertyType, 0, 10)
        return int(pid_reply.value.tolist()[0])

* Tue 24 Sep 2013 06:09:57 AM JST
self, 
* Tue 24 Sep 2013 06:10:02 AM JST
_
* Tue 24 Sep 2013 06:10:02 AM JST
self._
* Tue 24 Sep 2013 06:14:06 AM JST
    def existswin(self, title=None, klass=None, pid=None, active=None,
                  regexp=None):
        r"""SUMMARY

        @Arguments:
        - `**args`:

        @Return:
        """
        return self.get_target_win(title=title, klass=klass, pid=None,
                                   active=None, regexp=regexp)


* Tue 24 Sep 2013 06:14:24 AM JST
None,
* Tue 24 Sep 2013 06:14:24 AM JST
active=None,
* Tue 24 Sep 2013 06:14:26 AM JST
              
* Tue 24 Sep 2013 06:14:29 AM JST
self, 
* Tue 24 Sep 2013 06:14:37 AM JST
None, 
* Tue 24 Sep 2013 06:14:37 AM JST
active=None, 
* Tue 24 Sep 2013 06:14:40 AM JST
self.
* Tue 24 Sep 2013 06:14:43 AM JST
                               
* Tue 24 Sep 2013 06:15:19 AM JST
def get_win_ids():
    r"""SUMMARY

    @Return:
    """
    display = Xlib.display.Display()
    root = display.screen().root
    return (root.get_full_property(
        display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value)


* Tue 24 Sep 2013 06:19:03 AM JST
    def get_active_win(self):
        r"""SUMMARY

        @Return:
        """
        self._get_active_win()

* Tue 24 Sep 2013 06:19:31 AM JST
self
* Tue 24 Sep 2013 06:20:19 AM JST
self
* Tue 24 Sep 2013 06:20:29 AM JST
._get_active_win()
* Tue 24 Sep 2013 06:20:32 AM JST
active
* Tue 24 Sep 2013 06:20:34 AM JST
active = 
* Tue 24 Sep 2013 06:20:37 AM JST
return 
* Tue 24 Sep 2013 06:21:36 AM JST
    def get_wins(self):
        r"""Generator

        @Return:
        """
        for id_ in self.get_win_ids():
            yield self._display.create_resource_object('window', id_)

* Tue 24 Sep 2013 06:21:58 AM JST
get
* Tue 24 Sep 2013 06:22:02 AM JST
self
* Tue 24 Sep 2013 06:22:06 AM JST
self.
* Tue 24 Sep 2013 06:24:08 AM JST
    def get_win_names(self):
        r"""SUMMARY

        @Return:
        """
        for win in self.get_wins:
            if win is not None:
                yield win.get_wm_name()

* Tue 24 Sep 2013 06:24:24 AM JST
self
* Tue 24 Sep 2013 06:24:26 AM JST
self.
* Tue 24 Sep 2013 06:24:28 AM JST
get
* Tue 24 Sep 2013 06:24:56 AM JST

* Tue 24 Sep 2013 06:24:56 AM JST

* Tue 24 Sep 2013 06:24:56 AM JST
            yield win.get_wm_name()

* Tue 24 Sep 2013 06:25:23 AM JST
            
* Tue 24 Sep 2013 06:25:32 AM JST
    def get_win_classes(self):
        r"""SUMMARY

        @Return:
        """
        for win in self.get_wins:
            if win is not None:
                yield win.get_wm_class()


* Tue 24 Sep 2013 06:25:50 AM JST
win
* Tue 24 Sep 2013 06:26:14 AM JST
self
* Tue 24 Sep 2013 06:26:18 AM JST
yield win.get_wm_class()
* Tue 24 Sep 2013 06:26:58 AM JST
class
* Tue 24 Sep 2013 06:27:07 AM JST
self.
* Tue 24 Sep 2013 06:27:12 AM JST
get
* Tue 24 Sep 2013 06:31:54 AM JST
    def winwait(self, sec=0, title=None, klass=None, pid=None, regexp=None):
        r"""SUMMARY

        @Arguments:

        - `sec`:
        - `title`:
        - `klass`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        assert type(sec) is types.IntType
        assert title or klass or pid or regexp

        wait = sec * 2
        count = 0
        while 1:
            if self.existswin(title=title, klass=klass, pid=pid, regexp=regexp):
                return True
            sleep(0.5)
            if wait != 0:
                count += 0.5
                if wait <= count:
                    return False

* Tue 24 Sep 2013 06:32:14 AM JST
self, 
* Tue 24 Sep 2013 06:32:45 AM JST
self.
* Tue 24 Sep 2013 06:35:05 AM JST
infinity loop
* Tue 24 Sep 2013 06:35:09 AM JST
to 
* Tue 24 Sep 2013 06:36:02 AM JST
    def winwaitclose(self, sec=0, title=None, klass=None, pid=None, regexp=None):
        r"""SUMMARY

        @Arguments:

        - `sec`:
        - `title`:
        - `klass`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        assert type(sec) is types.IntType
        assert title or klass or pid or regexp

        wait = sec * 2
        count = 0
        while 1:
            if not self.existswin(title=title, klass=klass,
                                  pid=pid, regexp=regexp):
                return True
            sleep(0.5)
            if wait != 0:
                count += 0.5
                if wait <= count:
                    return False


* Tue 24 Sep 2013 06:36:23 AM JST
self, 
* Tue 24 Sep 2013 06:36:27 AM JST
self.
* Tue 24 Sep 2013 06:36:30 AM JST
                              
* Tue 24 Sep 2013 06:38:56 AM JST
not
* Tue 24 Sep 2013 06:41:21 AM JST
    def winactive(self, title=None, klass=None, pid=None, regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        return self.get_target_win(
            title=title, klass=klass, pid=pid, regexp=regexp).isactive()

* Tue 24 Sep 2013 06:41:57 AM JST
self, 
* Tue 24 Sep 2013 06:42:19 AM JST
self.
* Tue 24 Sep 2013 06:42:26 AM JST
        
* Tue 24 Sep 2013 06:42:36 AM JST
        
* Tue 24 Sep 2013 06:42:40 AM JST
get_target_win(title=title, klass=klass, pid=pid, regexp=regexp).isactive()
* Tue 24 Sep 2013 06:42:51 AM JST
.isactive()
* Tue 24 Sep 2013 06:44:34 AM JST
    def winwaitactive(self, sec, title=None, klass=None, pid=None, regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        assert type(sec) is types.IntType
        assert title or klass or pid or regexp

        wait = sec * 2
        count = 0
        while 1:
            if self.winactive(title=title, klass=klass, pid=pid, regexp=regexp):
                return True
            sleep(0.5)
            if wait != 0:
                count += 0.5
                if wait <= count:
                    return False

* Tue 24 Sep 2013 06:44:56 AM JST
self, 
* Tue 24 Sep 2013 06:45:09 AM JST
self.
* Tue 24 Sep 2013 06:46:03 AM JST
# infinity loop if sec is 0
* Tue 24 Sep 2013 06:47:20 AM JST
    def winwaitnotactive(self, sec=0, title=None, klass=None, pid=None, regexp=None):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        assert type(sec) is types.IntType
        assert title or klass or pid or regexp

        wait = sec * 2
        count = 0
        while 1:
            if not self.winactive(title=title, klass=klass, pid=pid, regexp=regexp):
                return True
            sleep(0.5)
            if wait != 0:
                count += 0.5
                if wait <= count:
                    return False

* Tue 24 Sep 2013 06:47:46 AM JST
self, 
* Tue 24 Sep 2013 06:47:53 AM JST
self.
* Tue 24 Sep 2013 06:47:55 AM JST
not 
* Tue 24 Sep 2013 06:49:41 AM JST
    def wingetactivetitle(self):
        r"""SUMMARY

        @Return:
        """
        return self.wingetactiveinfo().name

* Tue 24 Sep 2013 06:49:55 AM JST
self
* Tue 24 Sep 2013 06:50:00 AM JST
self.
* Tue 24 Sep 2013 06:50:19 AM JST
    def wingetactiveinfo(self):
        r"""SUMMARY

        @Return:
        """
        return WindowManager(self.get_active_win().id).info()

* Tue 24 Sep 2013 06:50:38 AM JST
self
* Tue 24 Sep 2013 06:50:41 AM JST
self.
* Tue 24 Sep 2013 06:53:18 AM JST
    
* Tue 24 Sep 2013 06:54:06 AM JST
    
* Tue 24 Sep 2013 06:54:42 AM JST

* Tue 24 Sep 2013 06:55:05 AM JST

* Tue 24 Sep 2013 06:55:20 AM JST

* Tue 24 Sep 2013 06:56:16 AM JST
    
* Tue 24 Sep 2013 06:56:22 AM JST
ipython
* Tue 24 Sep 2013 06:56:22 AM JST
line-ipython
* Tue 24 Sep 2013 06:56:29 AM JST
    
* Tue 24 Sep 2013 06:56:47 AM JST
    
* Tue 24 Sep 2013 06:56:48 AM JST
ipython
* Tue 24 Sep 2013 06:56:48 AM JST
class-ipython
* Tue 24 Sep 2013 06:57:07 AM JST
    
* Tue 24 Sep 2013 06:59:13 AM JST

* Tue 24 Sep 2013 06:59:13 AM JST

* Tue 24 Sep 2013 06:59:13 AM JST
        # self.reset_hide() # not implementated

* Tue 24 Sep 2013 07:12:06 AM JST
from time import sleep
import re as _re
import Xlib
import Xlib.display

from Xlib import X
from Xlib.protocol.event import ClientMessage
import types


__revision__ = "$Revision$"
__version__ = "0.1.0"

__all__ = [ '' ]


# def getwindowlist():
#     r"""SUMMARY

#     @Return:
#     """
#     display = Xlib.display.Display()
#     screen = display.screen()
#     root = screen.root
#     tree = root.query_tree()
#     wins = tree.children
#     for win in wins:
#         yield win.get_wm_name()


# def getwindows():
#     r"""SUMMARY

#     @Return:
#     """
#     return Xlib.display.Display().screen().root.query_tree().children

# def getwindowsname():
#     r"""SUMMARY

#     @Return:
#     """
#     for win in getwindows():
#         name = win.get_wm_name()
#         if name is not None:
#             yield name

# def getwindowsclass():
#     r"""SUMMARY

#     @Return:
#     """
#     for win in getwindows():
#         klass = win.get_wm_class()

#         if klass is not None:
#             yield klass

# def getwindowbyclass(classname):
#     r"""SUMMARY

#     @Arguments:
#     - `classname`:

#     @Return:
#     """
#     for win in getwindows():
#         klass = win.get_wm_class()

#         if klass is not None and klass == classname:
#             return win

# def getwindowbyname(windowname):
#     r"""SUMMARY

#     @Arguments:
#     - `windowname`:

#     @Return:
#     """
#     for win in getwindows():
#         name = win.get_wm_name()
#         if name is not None and name == windowname:
#             return win

# def getwindowbyname2(windowname):
#     r"""SUMMARY

#     @Arguments:
#     - `windowname`:

#     @Return:
#     """
#     display =  Xlib.display.Display()
#     root = display.screen().root
#     windowIDs = root.get_full_property(display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
#     for id_ in windowIDs:
#         win = display.create_resource_object('window', id_)
#         if windowname == win.get_wm_name():
#             return win
#     return None

# def getwindowsname2():
#     r"""SUMMARY

#     @Arguments:
#     - `windowname`:

#     @Return:
#     """
#     display =  Xlib.display.Display()
#     root = display.screen().root
#     windowIDs = root.get_full_property(display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
#     for id_ in windowIDs:
#         win = display.create_resource_object('window', id_)
#         yield win.get_wm_name()

# def getwindowsclass2():
#     r"""SUMMARY

#     @Arguments:
#     - `windowname`:

#     @Return:
#     """
#     display =  Xlib.display.Display()
#     root = display.screen().root
#     windowIDs = root.get_full_property(display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
#     for id_ in windowIDs:
#         win = display.create_resource_object('window', id_)
#         yield win.get_wm_class()

# def getwindowsnameclass():
#     r"""SUMMARY

#     @Arguments:
#     - `windowname`:

#     @Return:
#     """
#     display =  Xlib.display.Display()
#     root = display.screen().root
#     windowIDs = root.get_full_property(display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
#     for id_ in windowIDs:
#         win = display.create_resource_object('window', id_)
#         yield (win.get_wm_name(), win.get_wm_class())



# def winnamemoveresize(name, **args):
#     r"""SUMMARY

#     @Arguments:
#     - `** args`:

#     @Return:
#     """
#     display =  Xlib.display.Display()
#     w = getwindowbyname2(name)
#     if w is not None:
#         win = display.create_resource_object('window', w.id)
#         win.configure(**args)
#         display.sync()


# def winmove(**args):
#     r"""SUMMARY

#     @Arguments:
#     - `**args`:

#     @Return:
#     """
#     # display = Xlib.display.Display()
#     display, win = determine_target_window(title=args.get('title'),
#                                   klass=args.get('klass'),
#                                   pid=args.get('pid'),
#                                   activewin=args.get('activewin'),
#                                   regexp=args.get('regexp'))
#     if win is not None:
#         win.configure(**args)
#         display.sync()


# def determine_target_window(title=None, klass=None, pid=None,
#                             activewin=None, regexp=None):
#     r"""Determine target window by title, class, pid, active window or regexp title.

#     @Arguments:
#     - `title`:
#     - `klass`:
#     - `pid`:
#     - `activewin`:
#     - `regexp`:

#     @Return: Window object or None.
#     """
#     display =  Xlib.display.Display()
#     # active window
#     if activewin is not None:
#         return getactivewindow()

#     if not (title or klass or pid or activewin or regexp):
#         return None

#     # parse other windows
#     windowIDs = display.screen().root.get_full_property(
#         display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value
#     for id_ in windowIDs:
#         win = display.create_resource_object('window', id_)
#         if win is None:
#             continue
#         if title is not None and title == win.get_wm_name():
#             return display, win
#         if klass is not None and klass == win.get_wm_class():
#             return display, win
#         # not inplimented pid
#         if ((regexp is not None) and
#             (_re.search(regexp, win.get_wm_name()) is not None)):
#             return display, win
#     # not match
#     return None


class _Display(object):
    r"""
    """

    def __init__(self, display=None):
        r"""

        Arguments:
        - `display`:
        """
        self._display = (display or Xlib.display.Display())
        self._root = self._display.screen().root

    def _reload_display(self):
        r"""SUMMARY

        @Return:
        """
        old = self._display
        self._display = Xlib.display.Display()
        return (not (hash(old) == hash(self._display)))

    def _reload_root(self):
        r"""SUMMARY

        @Return:
        """
        self._reload_display()
        old = self._root
        self._root = self._display.screen().root
        return (not (hash(old) == hash(self._root)))

    def _sync(self):
        r"""SUMMARY

        @Return:
        """
        self._display.sync()


class ActiveWindow(_Display):
    r"""
    """
    def _get_active_win(self):
        r"""SUMMARY

        @Return:
        """
        win = self._display.get_input_focus().focus
        if win.get_wm_name() is None and win.get_wm_class() is None:
            win = win.query_tree().parent
        return win

    def _activate(self, win, above=True):
        r"""SUMMARY

        @Return:
        """
        if above is True:
            mode = X.Above
        else:
            mode = X.Below
        win.set_input_focus(X.RevertToNone, X.CurrentTime)
        win.configure(stack_mode=mode)
        self._sync()

    def activate(self, win):
        r"""SUMMARY

        @Arguments:

        - `above`:

        @Return:
        """
        self._activate(win, above=True)

    def deactivate(self, win):
        r"""SUMMARY

        @Return:
        """
        self._activate(win, above=False)


class WindowManager(ActiveWindow):
    r"""
    """

    def __init__(self, id_):
        r"""

        Arguments:
        - `window`:
        """
        super(WindowManager, self).__init__(display=None)
        self._NET_WM_STATE = self._display.intern_atom('_NET_WM_STATE')
        self._id = id_
        self._window = self._display.create_resource_object('window', self._id)
        if self._window is None:
            raise StandardError('not exists')

    def _send_event(self, event, event_mask=0, propagate=0,
                    onerror=None, sender='root'):
        r"""SUMMARY

        @Arguments:

        - `event`:
        - `event_mask`:
        - `propagate`:

        @Return:
        """
        if 'root' == sender:
            self._root.send_event(
                event, event_mask=event_mask, propagate=propagate)
        elif 'window' == sender:
            self._window.send_event(
                event, event_mask=event_mask, propagate=propagate)
        self._sync()

    def activate(self, win):
        r"""SUMMARY

        Override ActiveWindow

        @Arguments:

        - `above`:

        @Return:
        """
        self._activate(self._window, above=True)

    def deactivate(self):
        r"""SUMMARY

        Override ActiveWindow
        @Return:
        """
        self._activate(self._window, above=False)

    def isactive(self):
        r"""SUMMARY

        @Return: boolean
        """
        activewin = self._get_active_win()
        if activewin is None:
            return False
        return self._id == activewin.id

    def get_pid(self):
        r"""SUMMARY

        @Arguments:
        - `win`:

        @Return:
        """
        pid_reply = self._window.get_property(
            self._display.intern_atom('_NET_WM_PID'), X.AnyPropertyType, 0, 10)
        return int(pid_reply.value.tolist()[0])

    def move(self, **args):
        r"""SUMMARY

        @Arguments:

        - `** args`:

        @Return:
        """
        self._window.configure(**args)
        self._sync()

    def _state_cmd(self, data):
        r"""SUMMARY

        @Arguments:

        - `data`:

        @Return:
        """
        assert data[0] in [0, 1, 2]
        event = ClientMessage(window=self._window,
                              client_type = self._NET_WM_STATE,
                              data=(32, (data)))
        self._send_event(event,
                         event_mask=X.SubstructureRedirectMask, sender='root')

    def _maximize(self, action):
        r"""SUMMARY

        @Arguments:

        - `action`: 0 == remove, 1 == add, 2 == toggle

        @Return:
        """
        max_vert = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_VERT')
        max_horz = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_HORZ')
        self._state_cmd(data=[action, max_vert, max_horz, 0, 0])

    def maximize(self):
        r"""SUMMARY

        @Return:
        """
        self._maximize(action=1)

    def reset_maximize(self):
        r"""SUMMARY

        @Return:
        """
        self._maximize(action=0)

    def toggle_maximize(self):
        r"""SUMMARY

        @Return:
        """
        self._maximize(action=2)

    def _fullscreen(self, action):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        atom = self._display.intern_atom('_NET_WM_STATE_FULLSCREEN')
        self._state_cmd(data=[action, atom, 0, 0, 0])

    def fullscreen(self):
        r"""SUMMARY

        @Return:
        """
        self._fullscreen(action=1)

    def reset_fullscreen(self):
        r"""SUMMARY

        @Return:
        """
        self._fullscreen(action=0)

    def toggle_fullscreen(self):
        r"""SUMMARY

        @Return:
        """
        self._fullscreen(action=2)

    def _shade(self, action):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        atom = self._display.intern_atom('_NET_WM_STATE_SHADED')
        self._state_cmd(data=[action, atom, 0, 0, 0])

    def shade(self):
        r"""SUMMARY

        @Return:
        """
        self._shade(action=1)

    def reset_shade(self):
        r"""SUMMARY

        @Return:
        """
        self._shade(action=0)

    def toggle_shade(self):
        r"""SUMMARY

        @Return:
        """
        self._shade(action=2)

    def _hide(self):
        r"""SUMMARY

        @Return:
        """
        # TODO: (Atami) [2013/09/23]
        # not implemented
        pass

    def _above(self, action):
        r"""SUMMARY

        @Arguments:

        - `action`:

        @Return:
        """
        atom = self._display.intern_atom('_NET_WM_STATE_ABOVE')
        self._state_cmd(data=[action, atom, 0, 0, 0])

    def above(self):
        r"""SUMMARY

        @Return:
        """
        self._above(action=1)

    def reset_above(self):
        r"""SUMMARY

        @Return:
        """
        self._above(action=0)

    def toggle_above(self):
        r"""SUMMARY

        @Return:
        """
        self._above(action=2)

    def _below(self, action):
        r"""SUMMARY

        @Arguments:

        - `action`:

        @Return:
        """
        atom = self._display.intern_atom('_NET_WM_STATE_BELOW')
        self._state_cmd(data=[action, atom, 0, 0, 0])

    def below(self):
        r"""SUMMARY

        @Return:
        """
        self._below(action=1)

    def reset_below(self):
        r"""SUMMARY

        @Return:
        """
        self._below(action=0)

    def toggle_below(self):
        r"""SUMMARY

        @Return:
        """
        self._below(action=2)

    def kill(self):
        r"""Force close window.

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return:
        """
        type_ = self._display.intern_atom('WM_PROTOCOLS', True)
        atom = self._display.intern_atom('WM_DELETE_WINDOW')
        event = ClientMessage(window=self._window,
                              client_type=type_,
                              data=(32, [atom, X.CurrentTime, 0, 0, 0]))
        self._send_event(event=event, event_mask=0, sender='window')

    def close(self):
        r"""Close window.

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return:
        """
        type_ = self._display.intern_atom('_NET_CLOSE_WINDOW')
        event = ClientMessage(window=self._window,
                              client_type=type_,
                              data=(32, [X.CurrentTime, 0, 0, 0, 0]))
        self._send_event(event=event, event_mask=X.SubstructureRedirectMask,
                         sender='root')

    def info(self):
        r"""SUMMARY

        @Return:
        """
        w = self._window
        geo = self.get_geometry()
        return WindowInfo(id=w.id, name=w.get_wm_name(), klass=w.get_wm_class(),
                          x=geo.x, y=geo.y, height=geo.height, width=geo.width)

    def get_title(self):
        r"""SUMMARY

        @Return:
        """
        return self.info().name

    def get_class(self):
        r"""SUMMARY

        @Return:
        """
        return self.info().klass

    def get_geometry(self):
        r"""SUMMARY

        @Return:
        """
        return self._window.get_geometry()

    def minimize(self):
        r"""SUMMARY

        @Return:
        """
        # TODO: (Atami) [2013/09/24]
        # not implementated
        pass

    def minimizeall(self):
        r"""SUMMARY

        @Return:
        """
        # TODO: (Atami) [2013/09/24]
        # not implementated
        pass

    def minimize_reset_all(self):
        r"""SUMMARY

        @Return:
        """
        # TODO: (Atami) [2013/09/24]
        # not implementated
        pass

    def resetall(self):
        r"""SUMMARY

        @Return:
        """
        self.reset_maximize()
        self.reset_fullscreen()
        self.reset_shade()
        self.reset_above()
        self.reset_below()
        # TODO: (Atami) [2013/09/24]
        # self.reset_hide() # not implementated


class WindowInfo(object):
    r"""
    """

    def __init__(self, **args):
        r"""
        """
        self._args = args
        self.id = args.get('id')
        self.name = args.get('name')
        self.klass = args.get('klass')
        self.x = args.get('x')
        self.y = args.get('y')
        self.height = args.get('height')
        self.width = args.get('width')

    def __repr__(self):
        r"""SUMMARY

        @Return:
        """
        fmt = '\n{0:<7}: {1}'
        str_ = ['WindowInfo']
        str_.append(fmt.format('id', self.id))
        str_.append(fmt.format('name', self.name))
        str_.append(fmt.format('klass', self.klass))
        str_.append(fmt.format('x', self.x))
        str_.append(fmt.format('y', self.y))
        str_.append(fmt.format('height', self.height))
        str_.append(fmt.format('width', self.width))
        return ''.join(str_)


def existswin(title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:
    - `**args`:

    @Return:
    """
    return get_target_win(title=title, klass=klass, pid=pid, regexp=regexp)


def get_target_win(title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:

    - `title`:
    - `klass`:
    - `pid`:
    - `active`:
    - `regexp`:

    @Return: if exists window object, and not exists return None.
    """
    # prevent
    if not (title or klass or pid or regexp):
        return None

    # parse windows
    display = Xlib.display.Display()
    for id_ in get_win_ids():
        win = display.create_resource_object('window', id_)
        if win is None:
            continue
        if confirm_win(win=win, title=title, klass=klass,
                       pid=pid, regexp=regexp):
            return WindowManager(win.id)
    # not matched
    return None


def get_win_ids():
    r"""SUMMARY

    @Return:
    """
    display = Xlib.display.Display()
    root = display.screen().root
    return (root.get_full_property(
        display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value)


def confirm_win(win, title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:

    - `win`:
    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    if win is None:
        return False
    # title or klass or pid or regexp
    if ((title is not None and title == win.get_wm_name()) or
        (klass is not None and klass == win.get_wm_class()) or
        (pid is not None and pid == get_win_pid(win)) or
        (regexp is not None and
         (_re.search(regexp, win.get_wm_name()) is not None))):
        return True
    return False


def get_win_pid(win):
    r"""SUMMARY

    @Arguments:
    - `win`:

    @Return:
    """
    display = Xlib.display.Display()
    pid_reply = win.get_property(display.intern_atom('_NET_WM_PID'),
                                 X.AnyPropertyType, 0, 10)
    return int(pid_reply.value.tolist()[0])


def get_active_win():
    r"""SUMMARY

    @Return:
    """
    return ActiveWindow()._get_active_win()


def iter_wins():
    r"""Generator

    @Return:
    """
    for id_ in get_win_ids():
        yield WindowManager(id_)


def get_win_names():
    r"""SUMMARY

    @Return:
    """
    names = []
    for win in iter_wins():
        if win is not None:
            names.append(win.info().name)
    return names


def get_win_classes():
    r"""SUMMARY

    @Return:
    """
    classes = []
    for win in iter_wins():
        if win is not None:
            classes.append(win.info().klass)
    return classes


def winwait(sec=0, title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:

    - `sec`:
    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    assert type(sec) is types.IntType
    assert title or klass or pid or regexp

    wait = sec * 2
    count = 0
    while 1:
        if existswin(title=title, klass=klass, pid=pid, regexp=regexp) is True:
            return True
        sleep(0.5)
        # infinity loop if sec is 0
        if wait == 0:
            continue
        count += 0.5
        if wait <= count:
            return False


def winwaitclose(sec=0, title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:

    - `sec`:
    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    assert type(sec) is types.IntType
    assert title or klass or pid or regexp

    wait = sec * 2
    count = 0
    while 1:
        if existswin(title=title, klass=klass, pid=pid, regexp=regexp) is False:
            return True
        sleep(0.5)
        # infinity loop if sec is 0
        if wait == 0:
            count += 0.5
        if wait <= count:
            return False


def winactive(title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:

    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    win = get_target_win(title=title, klass=klass, pid=pid, regexp=regexp)
    return win.isactive()


def winwaitactive(sec, title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:

    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    assert type(sec) is types.IntType
    assert title or klass or pid or regexp

    wait = sec * 2
    count = 0
    while 1:
        if winactive(title=title, klass=klass, pid=pid, regexp=regexp) is True:
            return True
        sleep(0.5)
        # infinity loop if sec is 0
        if wait == 0:
            continue
        count += 0.5
        if wait <= count:
            return False


def winwaitnotactive(sec=0, title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:

    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    assert type(sec) is types.IntType
    assert title or klass or pid or regexp

    wait = sec * 2
    count = 0
    while 1:
        if winactive(title=title, klass=klass, pid=pid, regexp=regexp) is False:
            return True
        sleep(0.5)
        if wait == 0:
            continue
        count += 0.5
        if wait <= count:
            return False


def wingetactiveinfo():
    r"""SUMMARY

    @Return:
    """
    return WindowManager(get_active_win().id).info()


def wingetactivetitle():
    r"""SUMMARY

    @Return:
    """
    return wingetactiveinfo().name

* Tue 24 Sep 2013 07:21:00 AM JST
win
* Tue 24 Sep 2013 07:21:09 AM JST
win
* Tue 24 Sep 2013 07:21:25 AM JST
win
* Tue 24 Sep 2013 07:21:53 AM JST
def win
* Tue 24 Sep 2013 07:22:05 AM JST
win_
* Tue 24 Sep 2013 07:22:15 AM JST
win
* Tue 24 Sep 2013 07:24:06 AM JST
            
* Tue 24 Sep 2013 07:36:06 AM JST
'"sec" is not int type. We got {}'.format(str(type(sec)))
* Tue 24 Sep 2013 07:37:54 AM JST
type
* Tue 24 Sep 2013 07:38:59 AM JST

* Tue 24 Sep 2013 07:39:00 AM JST

* Tue 24 Sep 2013 07:39:00 AM JST
    assert type(sec) is types.IntType

* Tue 24 Sep 2013 07:39:07 AM JST
    if type(sec) is not types.IntType:
        msg = '"sec" is not int type. Must be int. We got {}'.format(
            str(type(sec)))
        raise ValueError(msg)

* Tue 24 Sep 2013 08:02:43 AM JST
get_active_
* Tue 24 Sep 2013 08:02:54 AM JST
get_active_
* Tue 24 Sep 2013 08:07:04 AM JST
get_active_
* Tue 24 Sep 2013 08:09:00 AM JST
def info():
    r"""SUMMARY

    @Return:
    """
    return WindowManager(getactive().id).info()


def title():
    r"""SUMMARY

    @Return:
    """
    return info().name

def klass():
    r"""SUMMARY

    @Return:
    """
    return info().klass

* Tue 24 Sep 2013 08:11:26 AM JST

* Tue 24 Sep 2013 08:11:26 AM JST

* Tue 24 Sep 2013 08:11:26 AM JST
@property

* Tue 24 Sep 2013 08:13:10 AM JST

* Tue 24 Sep 2013 08:13:10 AM JST

* Tue 24 Sep 2013 08:13:10 AM JST
import types

* Tue 24 Sep 2013 08:14:06 AM JST
import active
* Tue 24 Sep 2013 08:14:35 AM JST
from .active 
* Tue 24 Sep 2013 08:16:11 AM JST
def getactive():
    r"""SUMMARY

    @Return:
    """
    return ActiveWindow()._get_active_win()


* Tue 24 Sep 2013 08:16:35 AM JST
getactive, 
* Tue 24 Sep 2013 08:18:34 AM JST
class ActiveWindow(_Display):
    r"""
    """
    def _get_active_win(self):
        r"""SUMMARY

        @Return:
        """
        win = self._display.get_input_focus().focus
        if win.get_wm_name() is None and win.get_wm_class() is None:
            win = win.query_tree().parent
        return win

    def _activate(self, win, above=True):
        r"""SUMMARY

        @Return:
        """
        if above is True:
            mode = X.Above
        else:
            mode = X.Below
        win.set_input_focus(X.RevertToNone, X.CurrentTime)
        win.configure(stack_mode=mode)
        self._sync()

    def activate(self, win):
        r"""SUMMARY

        @Arguments:

        - `above`:

        @Return:
        """
        self._activate(win, above=True)

    def deactivate(self, win):
        r"""SUMMARY

        @Return:
        """
        self._activate(win, above=False)


* Tue 24 Sep 2013 08:19:26 AM JST
ActiveWindow, 
* Tue 24 Sep 2013 08:30:06 AM JST
    
* Tue 24 Sep 2013 08:32:29 AM JST
active
* Tue 24 Sep 2013 08:32:30 AM JST
import 
* Tue 24 Sep 2013 08:35:29 AM JST
class _Display(object):
    r"""
    """

    def __init__(self, display=None):
        r"""

        Arguments:
        - `display`:
        """
        self._display = (display or Xlib.display.Display())
        self._root = self._display.screen().root

    def _reload_display(self):
        r"""SUMMARY

        @Return:
        """
        old = self._display
        self._display = Xlib.display.Display()
        return (not (hash(old) == hash(self._display)))

    def _reload_root(self):
        r"""SUMMARY

        @Return:
        """
        self._reload_display()
        old = self._root
        self._root = self._display.screen().root
        return (not (hash(old) == hash(self._root)))

    def _sync(self):
        r"""SUMMARY

        @Return:
        """
        self._display.sync()


* Tue 24 Sep 2013 08:36:47 AM JST

* Tue 24 Sep 2013 08:36:47 AM JST

* Tue 24 Sep 2013 08:36:47 AM JST
import Xlib.display as _Xlib.display

* Tue 24 Sep 2013 08:37:36 AM JST
display.
* Tue 24 Sep 2013 08:37:37 AM JST
Xlib.display.
* Tue 24 Sep 2013 08:39:19 AM JST
_Display
* Tue 24 Sep 2013 08:41:08 AM JST
class WindowManager(active.ActiveWindow):
    r"""
    """

    def __init__(self, id_):
        r"""

        Arguments:
        - `window`:
        """
        super(WindowManager, self).__init__(display=None)
        self._NET_WM_STATE = self._display.intern_atom('_NET_WM_STATE')
        self._id = id_
        self._window = self._display.create_resource_object('window', self._id)
        if self._window is None:
            raise StandardError('not exists')

    def _send_event(self, event, event_mask=0, propagate=0,
                    onerror=None, sender='root'):
        r"""SUMMARY

        @Arguments:

        - `event`:
        - `event_mask`:
        - `propagate`:

        @Return:
        """
        if 'root' == sender:
            self._root.send_event(
                event, event_mask=event_mask, propagate=propagate)
        elif 'window' == sender:
            self._window.send_event(
                event, event_mask=event_mask, propagate=propagate)
        self._sync()

    def activate(self, win):
        r"""SUMMARY

        Override ActiveWindow

        @Arguments:

        - `above`:

        @Return:
        """
        self._activate(self._window, above=True)

    def deactivate(self):
        r"""SUMMARY

        Override ActiveWindow
        @Return:
        """
        self._activate(self._window, above=False)

    def isactive(self):
        r"""SUMMARY

        @Return: boolean
        """
        activewin = self._get_active_win()
        if activewin is None:
            return False
        return self._id == activewin.id

    def get_pid(self):
        r"""SUMMARY

        @Arguments:
        - `win`:

        @Return:
        """
        pid_reply = self._window.get_property(
            self._display.intern_atom('_NET_WM_PID'), X.AnyPropertyType, 0, 10)
        return int(pid_reply.value.tolist()[0])

    def move(self, **args):
        r"""SUMMARY

        @Arguments:

        - `** args`:

        @Return:
        """
        self._window.configure(**args)
        self._sync()

    def _state_cmd(self, data):
        r"""SUMMARY

        @Arguments:

        - `data`:

        @Return:
        """
        assert data[0] in [0, 1, 2]
        event = ClientMessage(window=self._window,
                              client_type = self._NET_WM_STATE,
                              data=(32, (data)))
        self._send_event(event,
                         event_mask=X.SubstructureRedirectMask, sender='root')

    def _maximize(self, action):
        r"""SUMMARY

        @Arguments:

        - `action`: 0 == remove, 1 == add, 2 == toggle

        @Return:
        """
        max_vert = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_VERT')
        max_horz = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_HORZ')
        self._state_cmd(data=[action, max_vert, max_horz, 0, 0])

    def maximize(self):
        r"""SUMMARY

        @Return:
        """
        self._maximize(action=1)

    def reset_maximize(self):
        r"""SUMMARY

        @Return:
        """
        self._maximize(action=0)

    def toggle_maximize(self):
        r"""SUMMARY

        @Return:
        """
        self._maximize(action=2)

    def _fullscreen(self, action):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        atom = self._display.intern_atom('_NET_WM_STATE_FULLSCREEN')
        self._state_cmd(data=[action, atom, 0, 0, 0])

    def fullscreen(self):
        r"""SUMMARY

        @Return:
        """
        self._fullscreen(action=1)

    def reset_fullscreen(self):
        r"""SUMMARY

        @Return:
        """
        self._fullscreen(action=0)

    def toggle_fullscreen(self):
        r"""SUMMARY

        @Return:
        """
        self._fullscreen(action=2)

    def _shade(self, action):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        atom = self._display.intern_atom('_NET_WM_STATE_SHADED')
        self._state_cmd(data=[action, atom, 0, 0, 0])

    def shade(self):
        r"""SUMMARY

        @Return:
        """
        self._shade(action=1)

    def reset_shade(self):
        r"""SUMMARY

        @Return:
        """
        self._shade(action=0)

    def toggle_shade(self):
        r"""SUMMARY

        @Return:
        """
        self._shade(action=2)

    def _hide(self):
        r"""SUMMARY

        @Return:
        """
        # TODO: (Atami) [2013/09/23]
        # not implemented
        pass

    def _above(self, action):
        r"""SUMMARY

        @Arguments:

        - `action`:

        @Return:
        """
        atom = self._display.intern_atom('_NET_WM_STATE_ABOVE')
        self._state_cmd(data=[action, atom, 0, 0, 0])

    def above(self):
        r"""SUMMARY

        @Return:
        """
        self._above(action=1)

    def reset_above(self):
        r"""SUMMARY

        @Return:
        """
        self._above(action=0)

    def toggle_above(self):
        r"""SUMMARY

        @Return:
        """
        self._above(action=2)

    def _below(self, action):
        r"""SUMMARY

        @Arguments:

        - `action`:

        @Return:
        """
        atom = self._display.intern_atom('_NET_WM_STATE_BELOW')
        self._state_cmd(data=[action, atom, 0, 0, 0])

    def below(self):
        r"""SUMMARY

        @Return:
        """
        self._below(action=1)

    def reset_below(self):
        r"""SUMMARY

        @Return:
        """
        self._below(action=0)

    def toggle_below(self):
        r"""SUMMARY

        @Return:
        """
        self._below(action=2)

    def kill(self):
        r"""Force close window.

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return:
        """
        type_ = self._display.intern_atom('WM_PROTOCOLS', True)
        atom = self._display.intern_atom('WM_DELETE_WINDOW')
        event = ClientMessage(window=self._window,
                              client_type=type_,
                              data=(32, [atom, X.CurrentTime, 0, 0, 0]))
        self._send_event(event=event, event_mask=0, sender='window')

    def close(self):
        r"""Close window.

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return:
        """
        type_ = self._display.intern_atom('_NET_CLOSE_WINDOW')
        event = ClientMessage(window=self._window,
                              client_type=type_,
                              data=(32, [X.CurrentTime, 0, 0, 0, 0]))
        self._send_event(event=event, event_mask=X.SubstructureRedirectMask,
                         sender='root')

    def info(self):
        r"""SUMMARY

        @Return:
        """
        w = self._window
        geo = self.get_geometry()
        return WindowInfo(id=w.id, name=w.get_wm_name(), klass=w.get_wm_class(),
                          x=geo.x, y=geo.y, height=geo.height, width=geo.width)

    def get_title(self):
        r"""SUMMARY

        @Return:
        """
        return self.info().name

    def get_class(self):
        r"""SUMMARY

        @Return:
        """
        return self.info().klass

    def get_geometry(self):
        r"""SUMMARY

        @Return:
        """
        return self._window.get_geometry()

    def minimize(self):
        r"""SUMMARY

        @Return:
        """
        # TODO: (Atami) [2013/09/24]
        # not implementated
        pass

    def minimizeall(self):
        r"""SUMMARY

        @Return:
        """
        # TODO: (Atami) [2013/09/24]
        # not implementated
        pass

    def minimize_reset_all(self):
        r"""SUMMARY

        @Return:
        """
        # TODO: (Atami) [2013/09/24]
        # not implementated
        pass

    def resetall(self):
        r"""SUMMARY

        @Return:
        """
        self.reset_maximize()
        self.reset_fullscreen()
        self.reset_shade()
        self.reset_above()
        self.reset_below()
        # TODO: (Atami) [2013/09/24]
        # self.reset_hide() # not implementated

* Tue 24 Sep 2013 08:41:48 AM JST
active.
* Tue 24 Sep 2013 08:42:03 AM JST
from Xlib.protocol.event import ClientMessage
* Tue 24 Sep 2013 08:44:10 AM JST

* Tue 24 Sep 2013 08:44:10 AM JST

* Tue 24 Sep 2013 08:44:10 AM JST
from Xlib.protocol.event import ClientMessage

* Tue 24 Sep 2013 08:44:12 AM JST

* Tue 24 Sep 2013 08:44:12 AM JST

* Tue 24 Sep 2013 08:44:12 AM JST
from wm import active

* Tue 24 Sep 2013 08:44:34 AM JST
class WindowInfo(object):
    r"""
    """

    def __init__(self, **args):
        r"""
        """
        self._args = args
        self.id = args.get('id')
        self.name = args.get('name')
        self.klass = args.get('klass')
        self.x = args.get('x')
        self.y = args.get('y')
        self.height = args.get('height')
        self.width = args.get('width')

    def __repr__(self):
        r"""SUMMARY

        @Return:
        """
        fmt = '\n{0:<7}: {1}'
        str_ = ['WindowInfo']
        str_.append(fmt.format('id', self.id))
        str_.append(fmt.format('name', self.name))
        str_.append(fmt.format('klass', self.klass))
        str_.append(fmt.format('x', self.x))
        str_.append(fmt.format('y', self.y))
        str_.append(fmt.format('height', self.height))
        str_.append(fmt.format('width', self.width))
        return ''.join(str_)


* Tue 24 Sep 2013 08:46:40 AM JST
def exists(title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:
    - `**args`:

    @Return:
    """
    return gettarget(title=title, klass=klass, pid=pid, regexp=regexp)


def gettarget(title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:

    - `title`:
    - `klass`:
    - `pid`:
    - `active`:
    - `regexp`:

    @Return: if exists window object, and not exists return None.
    """
    # prevent
    if not (title or klass or pid or regexp):
        return None

    # parse windows
    display = Xlib.display.Display()
    for id_ in getids():
        win = display.create_resource_object('window', id_)
        if win is None:
            continue
        if confirm(win=win, title=title, klass=klass,
                       pid=pid, regexp=regexp):
            return WindowManager(win.id)
    # not matched
    return None


def getids():
    r"""SUMMARY

    @Return:
    """
    display = Xlib.display.Display()
    root = display.screen().root
    return (root.get_full_property(
        display.intern_atom('_NET_CLIENT_LIST'), Xlib.X.AnyPropertyType).value)


def confirm(win, title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:

    - `win`:
    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    if win is None:
        return False
    # title or klass or pid or regexp
    if ((title is not None and title == win.get_wm_name()) or
        (klass is not None and klass == win.get_wm_class()) or
        (pid is not None and pid == getpid(win)) or
        (regexp is not None and
         (_re.search(regexp, win.get_wm_name()) is not None))):
        return True
    return False


def getpid(win):
    r"""SUMMARY

    @Arguments:
    - `win`:

    @Return:
    """
    display = Xlib.display.Display()
    pid_reply = win.get_property(display.intern_atom('_NET_WM_PID'),
                                 X.AnyPropertyType, 0, 10)
    return int(pid_reply.value.tolist()[0])


def iter_wins():
    r"""Generator

    @Return:
    """
    for id_ in getids():
        yield WindowManager(id_)


def getnames():
    r"""SUMMARY

    @Return:
    """
    names = []
    for win in iter_wins():
        if win is not None:
            names.append(win.info().name)
    return names


def getclasses():
    r"""SUMMARY

    @Return:
    """
    classes = []
    for win in iter_wins():
        if win is not None:
            classes.append(win.info().klass)
    return classes


def wait(sec=0, title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:

    - `sec`:
    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    if type(sec) is not types.IntType:
        msg = '"sec" is not int type. Must be int. We got {}'.format(
            str(type(sec)))
        raise ValueError(msg)

    assert title or klass or pid or regexp

    wait = sec * 2
    count = 0
    while 1:
        if exists(title=title, klass=klass, pid=pid, regexp=regexp) is True:
            return True
        sleep(0.5)
        # infinity loop if sec is 0
        if wait == 0:
            continue
        count += 0.5
        if wait <= count:
            return False


def waitclose(sec=0, title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:

    - `sec`:
    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    if type(sec) is not types.IntType:
        msg = '"sec" is not int type. Must be int. We got {}'.format(
            str(type(sec)))
        raise ValueError(msg)

    assert title or klass or pid or regexp

    wait = sec * 2
    count = 0
    while 1:
        if exists(title=title, klass=klass, pid=pid, regexp=regexp) is False:
            return True
        sleep(0.5)
        # infinity loop if sec is 0
        if wait == 0:
            count += 0.5
        if wait <= count:
            return False


def isactive(title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:

    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    win = gettarget(title=title, klass=klass, pid=pid, regexp=regexp)
    return win.isactive()


def waitactive(sec, title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:

    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    if type(sec) is not types.IntType:
        msg = '"sec" is not int type. Must be int. We got {}'.format(
            str(type(sec)))
        raise ValueError(msg)

    assert title or klass or pid or regexp

    wait = sec * 2
    count = 0
    while 1:
        if isactive(title=title, klass=klass, pid=pid, regexp=regexp) is True:
            return True
        sleep(0.5)
        # infinity loop if sec is 0
        if wait == 0:
            continue
        count += 0.5
        if wait <= count:
            return False


def waitdeactive(sec=0, title=None, klass=None, pid=None, regexp=None):
    r"""SUMMARY

    @Arguments:

    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    if type(sec) is not types.IntType:
        msg = '"sec" is not int type. Must be int. We got {}'.format(
            str(type(sec)))
        raise ValueError(msg)

    assert title or klass or pid or regexp

    wait = sec * 2
    count = 0
    while 1:
        if isactive(title=title, klass=klass, pid=pid, regexp=regexp) is False:
            return True
        sleep(0.5)
        if wait == 0:
            continue
        count += 0.5
        if wait <= count:
            return False


* Tue 24 Sep 2013 08:47:29 AM JST

* Tue 24 Sep 2013 08:47:29 AM JST

* Tue 24 Sep 2013 08:47:29 AM JST
from time import sleep

* Tue 24 Sep 2013 08:47:31 AM JST
from time import sleep

* Tue 24 Sep 2013 08:47:31 AM JST
from time import sleep
import types

* Tue 24 Sep 2013 08:47:37 AM JST

* Tue 24 Sep 2013 08:47:37 AM JST

* Tue 24 Sep 2013 08:47:37 AM JST
from time import sleep

* Tue 24 Sep 2013 08:48:34 AM JST
_XDisplay
* Tue 24 Sep 2013 08:50:33 AM JST
Xlib.
* Tue 24 Sep 2013 08:50:42 AM JST

* Tue 24 Sep 2013 08:50:42 AM JST

* Tue 24 Sep 2013 08:50:42 AM JST
import re as _re

* Tue 24 Sep 2013 08:50:51 AM JST

* Tue 24 Sep 2013 08:50:51 AM JST

* Tue 24 Sep 2013 08:50:51 AM JST
import re as _re

* Tue 24 Sep 2013 08:51:55 AM JST
__all__ = [ '' ]
* Tue 24 Sep 2013 08:52:44 AM JST

* Tue 24 Sep 2013 08:52:44 AM JST

* Tue 24 Sep 2013 08:52:44 AM JST
import Xlib

* Tue 24 Sep 2013 08:52:44 AM JST
import Xlib

* Tue 24 Sep 2013 08:52:44 AM JST
import Xlib
import Xlib.display

* Tue 24 Sep 2013 08:52:45 AM JST

* Tue 24 Sep 2013 08:52:45 AM JST

* Tue 24 Sep 2013 08:52:45 AM JST
from Xlib import X

* Tue 24 Sep 2013 08:55:13 AM JST
wm
* Tue 24 Sep 2013 08:55:16 AM JST
wm
* Tue 24 Sep 2013 08:56:11 AM JST
ActiveWindow
* Tue 24 Sep 2013 08:57:30 AM JST

* Tue 24 Sep 2013 08:57:30 AM JST

* Tue 24 Sep 2013 08:57:30 AM JST
__all__ = ['ActiveWindow', 'get', 'info', 'title', 'klass']

* Tue 24 Sep 2013 09:05:39 AM JST
ActiveWindow as _ActiveWindow
* Tue 24 Sep 2013 09:05:41 AM JST
active
* Tue 24 Sep 2013 09:07:34 AM JST
class ActiveWindow(_Display):
    r"""
    """
    def _get_active_win(self):
        r"""SUMMARY

        @Return:
        """
        win = self._display.get_input_focus().focus
        if win.get_wm_name() is None and win.get_wm_class() is None:
            win = win.query_tree().parent
        return win

    def _activate(self, win, above=True):
        r"""SUMMARY

        @Return:
        """
        if above is True:
            mode = _X.Above
        else:
            mode = _X.Below
        win.set_input_focus(_X.RevertToNone, _X.CurrentTime)
        win.configure(stack_mode=mode)
        self._sync()

    def activate(self, win):
        r"""SUMMARY

        @Arguments:

        - `above`:

        @Return:
        """
        self._activate(win, above=True)

    def deactivate(self, win):
        r"""SUMMARY

        @Return:
        """
        self._activate(win, above=False)

* Tue 24 Sep 2013 09:07:52 AM JST

* Tue 24 Sep 2013 09:07:52 AM JST

* Tue 24 Sep 2013 09:07:52 AM JST
from wm.display import _Display

* Tue 24 Sep 2013 09:08:26 AM JST
ActiveWindow', 
* Tue 24 Sep 2013 09:09:17 AM JST
active.
* Tue 24 Sep 2013 09:19:11 AM JST
active
* Tue 24 Sep 2013 09:19:12 AM JST
as active
* Tue 24 Sep 2013 09:23:11 AM JST
class ActiveWindow(_Display):
    r"""
    """
    def _get_active_win(self):
        r"""SUMMARY

        @Return:
        """
        win = self._display.get_input_focus().focus
        if win.get_wm_name() is None and win.get_wm_class() is None:
            win = win.query_tree().parent
        return win

    def _activate(self, win, above=True):
        r"""SUMMARY

        @Return:
        """
        if above is True:
            mode = _X.Above
        else:
            mode = _X.Below
        win.set_input_focus(_X.RevertToNone, _X.CurrentTime)
        win.configure(stack_mode=mode)
        self._sync()

    def activate(self, win):
        r"""SUMMARY

        @Arguments:

        - `above`:

        @Return:
        """
        self._activate(win, above=True)

    def deactivate(self, win):
        r"""SUMMARY

        @Return:
        """
        self._activate(win, above=False)


* Tue 24 Sep 2013 09:23:28 AM JST
ActiveWindow
* Tue 24 Sep 2013 09:23:52 AM JST

* Tue 24 Sep 2013 09:23:52 AM JST

* Tue 24 Sep 2013 09:23:52 AM JST
from wm._display import _Display

* Tue 24 Sep 2013 09:24:55 AM JST
active
* Tue 24 Sep 2013 09:24:57 AM JST
ActiveWindow
* Tue 24 Sep 2013 04:17:27 PM JST
'_NET_FRAME_EXTENTS'
* Tue 24 Sep 2013 04:34:00 PM JST
    def __repr__(self):
        r"""SUMMARY

        @Return:
        """
        fmt = '\n{0:<7}: {1}'
        str_ = ['WindowInfo']
        str_.append(fmt.format('id', self.id))
        str_.append(fmt.format('name', self.name))
        str_.append(fmt.format('klass', self.klass))
        str_.append(fmt.format('x', self.x))
        str_.append(fmt.format('y', self.y))
        str_.append(fmt.format('height', self.height))
        str_.append(fmt.format('width', self.width))
        return ''.join(str_)

* Tue 24 Sep 2013 04:34:08 PM JST
WindowInfo
* Tue 24 Sep 2013 04:34:12 PM JST

* Tue 24 Sep 2013 04:34:13 PM JST

* Tue 24 Sep 2013 04:34:13 PM JST
        str_.append(fmt.format('id', self.id))

* Tue 24 Sep 2013 04:34:13 PM JST
        str_.append(fmt.format('id', self.id))

* Tue 24 Sep 2013 04:34:13 PM JST
        str_.append(fmt.format('id', self.id))
        str_.append(fmt.format('name', self.name))

* Tue 24 Sep 2013 04:34:13 PM JST
        str_.append(fmt.format('id', self.id))
        str_.append(fmt.format('name', self.name))

* Tue 24 Sep 2013 04:34:13 PM JST
        str_.append(fmt.format('id', self.id))
        str_.append(fmt.format('name', self.name))
        str_.append(fmt.format('klass', self.klass))

* Tue 24 Sep 2013 04:36:11 PM JST
self._window.get_geometry()
* Tue 24 Sep 2013 04:37:31 PM JST
y
* Tue 24 Sep 2013 04:37:32 PM JST
x, y
* Tue 24 Sep 2013 04:40:05 PM JST
print()
* Tue 24 Sep 2013 04:42:21 PM JST
WindowManager
* Tue 24 Sep 2013 04:43:39 PM JST
super(WindowManager, self)
* Tue 24 Sep 2013 04:46:07 PM JST
None
* Tue 24 Sep 2013 04:47:52 PM JST

* Tue 24 Sep 2013 04:47:52 PM JST

* Tue 24 Sep 2013 04:47:53 PM JST
        print('DEBUG-1-_core.py')

* Tue 24 Sep 2013 04:54:55 PM JST
    def get_geometry(self):
        r"""SUMMARY

        @Return:
        """
        geo = self._window.get_geometry()
        translated = self._window.translate_coords(self._root, geo.x, geo.y)
        return Geometry(x=-translated.x, y=-translated.y,
                        height=geo.height, width=geo.width)


* Tue 24 Sep 2013 04:55:27 PM JST
    def info(self):
        r"""SUMMARY

        @Return:
        """
        w = self._window
        geo = self.get_geometry()
        return WindowInfo(id=w.id, name=w.get_wm_name(), klass=w.get_wm_class(),
                          x=geo.x, y=geo.y, height=geo.height, width=geo.width)

    def get_title(self):
        r"""SUMMARY

        @Return:
        """
        return self.info().name

    def get_class(self):
        r"""SUMMARY

        @Return:
        """
        return self.info().klass


* Tue 24 Sep 2013 05:23:00 PM JST
    @property
    def x(self):
        r"""SUMMARY

        @Return:
        """
        return self.get_geometry().x

    @property
    def y(self):
        r"""SUMMARY

        @Return:
        """
        return self.get_geometry().y

    @property
    def height(self):
        r"""SUMMARY

        @Return:
        """
        return self.get_geometry().height

    @property
    def width(self):
        r"""SUMMARY

        @Return:
        """
        return self.get_geometry().width

* Tue 24 Sep 2013 05:23:12 PM JST
    def get_geometry(self):
        r"""SUMMARY

        @Return:
        """
        geo = self._window.get_geometry()
        translated = self._window.translate_coords(self._root, geo.x, geo.y)
        return Geometry(x=-translated.x, y=-translated.y,
                        height=geo.height, width=geo.width)

* Tue 24 Sep 2013 05:25:31 PM JST
object
* Tue 24 Sep 2013 05:25:45 PM JST
Geometry(
* Tue 24 Sep 2013 05:26:58 PM JST
height
* Tue 24 Sep 2013 05:27:08 PM JST
width
* Tue 24 Sep 2013 05:29:59 PM JST
self
* Tue 24 Sep 2013 05:30:13 PM JST
y
* Tue 24 Sep 2013 05:30:13 PM JST
self.y
* Tue 24 Sep 2013 05:30:21 PM JST
height
* Tue 24 Sep 2013 05:30:21 PM JST
self.height
* Tue 24 Sep 2013 05:30:33 PM JST
width
* Tue 24 Sep 2013 05:30:33 PM JST
self.width
* Tue 24 Sep 2013 05:46:46 PM JST
    def __eq__(self, other):
        r"""SUMMARY
        
        @Arguments:
        
        - `other`:
        
        @Return:
        """


* Tue 24 Sep 2013 06:02:19 PM JST
class ActiveWindow(_Display):
    r"""
    """
    def __init__(self, display=None):
        r"""SUMMARY

        @Arguments:

        - `display`:

        @Return:
        """
        _Display.__init__(self, display=display)

    def _get_active_win(self):
        r"""SUMMARY

        @Return:
        """
        win = self._display.get_input_focus().focus
        if win.get_wm_name() is None and win.get_wm_class() is None:
            win = win.query_tree().parent
        return win

    def _activate(self, win, above=True):
        r"""SUMMARY

        @Return:
        """
        if above is True:
            mode = _X.Above
        else:
            mode = _X.Below
        win.set_input_focus(_X.RevertToNone, _X.CurrentTime)
        win.configure(stack_mode=mode)
        self._sync()

    def activate(self, win):
        r"""SUMMARY

        @Arguments:

        - `above`:

        @Return:
        """
        self._activate(win, above=True)

    def deactivate(self, win):
        r"""SUMMARY

        @Return:
        """
        self._activate(win, above=False)


* Tue 24 Sep 2013 06:02:52 PM JST
_Display
* Tue 24 Sep 2013 06:03:46 PM JST
        if above is True:
            mode = _X.Above
        else:
            mode = _X.Below
        win.set_input_focus(_X.RevertToNone, _X.CurrentTime)
        win.configure(stack_mode=mode)
        self._sync()

* Tue 24 Sep 2013 06:04:58 PM JST
win
* Tue 24 Sep 2013 06:05:33 PM JST
_window,
* Tue 24 Sep 2013 06:05:34 PM JST
self._window,
* Tue 24 Sep 2013 06:05:37 PM JST
self.
* Tue 24 Sep 2013 06:05:57 PM JST

* Tue 24 Sep 2013 06:05:57 PM JST

* Tue 24 Sep 2013 06:05:57 PM JST
        self._activate(self._window, above=True)

* Tue 24 Sep 2013 06:11:47 PM JST
_Display
* Tue 24 Sep 2013 06:16:50 PM JST
_
* Tue 24 Sep 2013 06:28:51 PM JST
    def _get_active_win(self):
        r"""SUMMARY

        @Return:
        """
        win = self._display.get_input_focus().focus
        if win.get_wm_name() is None and win.get_wm_class() is None:
            win = win.query_tree().parent
        return win

* Tue 24 Sep 2013 06:29:03 PM JST
self
* Tue 24 Sep 2013 06:29:08 PM JST
_
* Tue 24 Sep 2013 06:29:09 PM JST
self._
* Tue 24 Sep 2013 06:30:03 PM JST
self.
* Tue 24 Sep 2013 06:31:14 PM JST
WindowManager, 
* Tue 24 Sep 2013 06:31:18 PM JST
WindowManager(
* Tue 24 Sep 2013 06:31:27 PM JST
WindowManager(
* Tue 24 Sep 2013 06:35:25 PM JST
id
* Tue 24 Sep 2013 06:35:28 PM JST
id
* Tue 24 Sep 2013 06:35:28 PM JST
_get_active_win().id
* Tue 24 Sep 2013 06:40:42 PM JST
class ActiveWindow(_Display, WindowManager):
    r"""
    """

    def __init__(self, display=None):
        r"""SUMMARY

        @Arguments:

        - `display`:

        @Return:
        """
        _Display.__init__(self, display=display)
        win = _get_active_win()
        WindowManager.__init__(self, id_=win.id, display=self._display)


* Tue 24 Sep 2013 06:40:53 PM JST
ActiveWindow
* Tue 24 Sep 2013 10:23:17 PM JST
    display = _XDisplay()
    win = display.get_input_focus().focus
    if win.get_wm_name() is None and win.get_wm_class() is None:
        win = win.query_tree().parent

* Tue 24 Sep 2013 10:23:19 PM JST
    display = _XDisplay()
    win = display.get_input_focus().focus
    if win.get_wm_name() is None and win.get_wm_class() is None:
        win = win.query_tree().parent
    return win

* Tue 24 Sep 2013 10:23:32 PM JST
name
* Tue 24 Sep 2013 10:23:48 PM JST
klass
* Tue 24 Sep 2013 10:23:49 PM JST
info().klass
* Tue 24 Sep 2013 10:24:22 PM JST

* Tue 24 Sep 2013 10:24:22 PM JST

* Tue 24 Sep 2013 10:24:22 PM JST
        win = _get_active_win()

* Tue 24 Sep 2013 10:24:26 PM JST
win
* Tue 24 Sep 2013 10:25:32 PM JST

* Tue 24 Sep 2013 10:25:32 PM JST

* Tue 24 Sep 2013 10:25:32 PM JST
        ActiveWindow.__init__(self, display=display)

* Tue 24 Sep 2013 10:27:08 PM JST
    def get_geometry(self):
        r"""SUMMARY

        @Return:
        """
        geo = self._window.get_geometry()
        translated = self._window.translate_coords(self._root, geo.x, geo.y)
        return Geometry(x=-translated.x, y=-translated.y,
                        height=geo.height, width=geo.width)


* Tue 24 Sep 2013 10:27:27 PM JST
get_
* Tue 24 Sep 2013 10:27:41 PM JST
get_
* Tue 24 Sep 2013 10:29:04 PM JST
active
* Tue 24 Sep 2013 10:29:05 PM JST
_get_active_win
* Tue 24 Sep 2013 10:29:21 PM JST
_get_active_win()
* Tue 24 Sep 2013 10:30:42 PM JST
get_
* Tue 24 Sep 2013 10:34:04 PM JST

* Tue 24 Sep 2013 10:34:04 PM JST

* Tue 24 Sep 2013 10:34:04 PM JST
        _Display.__init__(self, display=display)

* Tue 24 Sep 2013 10:34:19 PM JST
_
* Tue 24 Sep 2013 10:34:20 PM JST
self._
* Tue 24 Sep 2013 10:36:30 PM JST
_Display, 
* Tue 24 Sep 2013 10:36:35 PM JST

* Tue 24 Sep 2013 10:36:35 PM JST

* Tue 24 Sep 2013 10:36:35 PM JST
from wm._display import _Display

* Tue 24 Sep 2013 10:37:40 PM JST
class ActiveWindow(WindowManager):
    r"""
    """

    def __init__(self, display=None):
        r"""SUMMARY

        @Arguments:

        - `display`:

        @Return:
        """
        WindowManager.__init__(self, id_=get().id, display=display)


* Tue 24 Sep 2013 10:38:27 PM JST

* Tue 24 Sep 2013 10:38:27 PM JST

* Tue 24 Sep 2013 10:38:27 PM JST
from wm._core import WindowManager

* Tue 24 Sep 2013 10:40:19 PM JST
def get():
    r"""SUMMARY

    @Return:
    """
    display = _XDisplay()
    win = display.get_input_focus().focus
    if win.get_wm_name() is None and win.get_wm_class() is None:
        win = win.query_tree().parent
    return win


def info():
    r"""SUMMARY

    @Return:
    """
    pass
    # return ActiveWindow()WindowManager(get().id).info()


def title():
    r"""SUMMARY

    @Return:
    """
    return get().get_wm_name()


def klass():
    r"""SUMMARY

    @Return:
    """
    return get().get_wm_class()


* Tue 24 Sep 2013 10:45:10 PM JST
None, 
* Tue 24 Sep 2013 10:45:10 PM JST
id_=None, 
* Tue 24 Sep 2013 10:46:30 PM JST
    win = display.get_input_focus().focus
    if win.get_wm_name() is None and win.get_wm_class() is None:
        win = win.query_tree().parent

* Tue 24 Sep 2013 10:46:57 PM JST
get()
* Tue 24 Sep 2013 10:46:58 PM JST
active.get()
* Tue 24 Sep 2013 10:48:13 PM JST
get()
* Tue 24 Sep 2013 10:48:14 PM JST
active.get()
* Tue 24 Sep 2013 10:49:57 PM JST

* Tue 24 Sep 2013 10:49:57 PM JST

* Tue 24 Sep 2013 10:49:57 PM JST
from wm import active

* Tue 24 Sep 2013 10:49:59 PM JST

* Tue 24 Sep 2013 10:49:59 PM JST

* Tue 24 Sep 2013 10:49:59 PM JST
from Xlib.display import Display as _XDisplay

* Tue 24 Sep 2013 10:51:31 PM JST
#     display = _XDisplay()

* Tue 24 Sep 2013 10:51:38 PM JST
#     
* Tue 24 Sep 2013 10:51:48 PM JST

* Tue 24 Sep 2013 10:51:48 PM JST

* Tue 24 Sep 2013 10:51:48 PM JST
        _Display.__init__(self, display=display)

* Tue 24 Sep 2013 10:51:52 PM JST
_
* Tue 24 Sep 2013 10:51:53 PM JST
self._
* Tue 24 Sep 2013 10:52:01 PM JST
_
* Tue 24 Sep 2013 10:52:02 PM JST
self._
* Tue 24 Sep 2013 10:52:53 PM JST
_Display, 
* Tue 24 Sep 2013 10:55:34 PM JST
# def getactive():
#     r"""SUMMARY

#     @Return:
#     """
#     display = _XDisplay()
#     win = display.get_input_focus().focus
#     if win.get_wm_name() is None and win.get_wm_class() is None:
#         win = win.query_tree().parent
#     return ActiveWindow(win)


# def info():
#     r"""SUMMARY

#     @Return:
#     """
#     pass
#     # return ActiveWindow()WindowManager(get().id).info()


# def title():
#     r"""SUMMARY

#     @Return:
#     """
#     return getactive().get_wm_name()


# def klass():
#     r"""SUMMARY

#     @Return:
#     """
#     return getactive().get_wm_class()

* Tue 24 Sep 2013 10:55:56 PM JST
getactive
* Tue 24 Sep 2013 10:56:28 PM JST
getactive
* Tue 24 Sep 2013 10:56:35 PM JST
get_wm_name()
* Tue 24 Sep 2013 10:56:45 PM JST
getactive
* Tue 24 Sep 2013 10:56:53 PM JST
get_wm_class()
* Tue 24 Sep 2013 10:57:11 PM JST
def title():
    r"""SUMMARY

    @Return:
    """
    return ActiveWindow().name


def klass():
    r"""SUMMARY

    @Return:
    """
    return ActiveWindow().klass


* Tue 24 Sep 2013 10:57:30 PM JST
ActiveWindow().klass
* Tue 24 Sep 2013 10:58:16 PM JST
    @property
    def pid(self):
        r"""SUMMARY

        @Arguments:
        - `win`:

        @Return:
        """
        pid_reply = self._window.get_property(
            self._display.intern_atom('_NET_WM_PID'), _X.AnyPropertyType, 0, 10)
        return int(pid_reply.value.tolist()[0])


* Tue 24 Sep 2013 11:07:40 PM JST
return self.id == other.id
* Tue 24 Sep 2013 11:07:48 PM JST
id
* Tue 24 Sep 2013 11:19:19 PM JST
display
* Tue 24 Sep 2013 11:20:52 PM JST
    @property
    def x(self):
        r"""SUMMARY

        @Return:
        """
        return self.get_geometry().get('x', 0)

    @property
    def y(self):
        r"""SUMMARY

        @Return:
        """
        return self.get_geometry().get('y', 0)

    @property
    def height(self):
        r"""SUMMARY

        @Return:
        """
        return self.get_geometry().get('height', 0)

    @property
    def width(self):
        r"""SUMMARY

        @Return:
        """
        return self.get_geometry().get('width', 0)

    def get_geometry(self):
        r"""SUMMARY

        @Return:
        """
        geo = self._window.get_geometry()
        translated = self._window.translate_coords(self._root, geo.x, geo.y)
        return {'x': -translated.x,
                'y': -translated.y,
                'height': geo.height,
                'width': geo.width, }

* Tue 24 Sep 2013 11:27:30 PM JST
info()
* Tue 24 Sep 2013 11:27:50 PM JST
info()
* Tue 24 Sep 2013 11:28:50 PM JST
    @property
    def id(self):
        r"""SUMMARY

        @Return:
        """
        return self._window.id


* Tue 24 Sep 2013 11:37:02 PM JST
active
* Tue 24 Sep 2013 11:37:02 PM JST
wm.active
* Tue 24 Sep 2013 11:58:38 PM JST
    def __repr__(self):
        r"""SUMMARY

        @Return:
        """
        fmt = '\n{0:<7}: {1}'
        str_ = ['WindowInfo']
        str_.append(fmt.format('id', self.id))
        str_.append(fmt.format('name', self.name))
        str_.append(fmt.format('klass', self.klass))
        str_.append(fmt.format('x', self.x))
        str_.append(fmt.format('y', self.y))
        str_.append(fmt.format('height', self.height))
        str_.append(fmt.format('width', self.width))
        return ''.join(str_)

* Tue 24 Sep 2013 11:59:16 PM JST
name
* Tue 24 Sep 2013 11:59:18 PM JST
name
* Wed 25 Sep 2013 12:01:25 AM JST
        
* Wed 25 Sep 2013 12:01:32 AM JST

* Wed 25 Sep 2013 12:01:32 AM JST

* Wed 25 Sep 2013 12:01:32 AM JST
        str_.append(fmt.format('pid', self.pid))

* Wed 25 Sep 2013 12:01:55 AM JST
        
* Wed 25 Sep 2013 12:02:18 AM JST
width
* Wed 25 Sep 2013 12:10:19 AM JST
                              
* Wed 25 Sep 2013 12:10:36 AM JST
                              
* Wed 25 Sep 2013 12:18:45 AM JST
reset_
* Wed 25 Sep 2013 12:22:21 AM JST
    @property
    def title(self):
        r"""SUMMARY

        @Return:
        """
        return self._window.get_wm_name()

    @property
    def klass(self):
        r"""SUMMARY

        @Return:
        """
        return self._window.get_wm_class()

    @property
    def pid(self):
        r"""SUMMARY

        @Arguments:
        - `win`:

        @Return:
        """
        pid_reply = self._window.get_property(
            self._display.intern_atom('_NET_WM_PID'), _X.AnyPropertyType, 0, 10)
        return int(pid_reply.value.tolist()[0])

* Wed 25 Sep 2013 12:23:23 AM JST
    def activate(self, above=True):
        r"""SUMMARY

        Override ActiveWindow

        @Arguments:

        - `above`:

        @Return:
        """
        if above is True:
            mode = _X.Above
        else:
            mode = _X.Below
        self._window.set_input_focus(_X.RevertToNone, _X.CurrentTime)
        self._window.configure(stack_mode=mode)
        self._sync()

    def deactivate(self):
        r"""SUMMARY

        Override ActiveWindow
        @Return:
        """
        self.activate(above=False)

    def isactive(self):
        r"""SUMMARY

        @Return: boolean
        """
        activewin = ActiveWindow(display=self._display)
        if activewin is None:
            return False
        return self.id == activewin.id


* Wed 25 Sep 2013 12:25:54 AM JST
    def move(self, **args):
        r"""SUMMARY

        @Arguments:

        - `** args`:

        @Return:
        """
        self._window.configure(**args)
        self._sync()


* Wed 25 Sep 2013 12:26:40 AM JST
    def _maximize(self, action):
        r"""SUMMARY

        @Arguments:

        - `action`: 0 == remove, 1 == add, 2 == toggle

        @Return:
        """
        max_vert = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_VERT')
        max_horz = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_HORZ')
        self._state_cmd(data=[action, max_vert, max_horz, 0, 0])

    def maximize(self):
        r"""SUMMARY

        @Return:
        """
        self._maximize(action=1)

    def reset_maximize(self):
        r"""SUMMARY

        @Return:
        """
        self._maximize(action=0)

    def toggle_maximize(self):
        r"""SUMMARY

        @Return:
        """
        self._maximize(action=2)


* Wed 25 Sep 2013 12:27:27 AM JST
    def maximize(self):
        r"""SUMMARY

        @Return:
        """
        self._maximize(action=1)


* Wed 25 Sep 2013 12:28:10 AM JST
    def _fullscreen(self, action):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        atom = self._display.intern_atom('_NET_WM_STATE_FULLSCREEN')
        self._state_cmd(data=[action, atom, 0, 0, 0])

    def fullscreen(self):
        r"""SUMMARY

        @Return:
        """
        self._fullscreen(action=1)

    def reset_fullscreen(self):
        r"""SUMMARY

        @Return:
        """
        self._fullscreen(action=0)

    def toggle_fullscreen(self):
        r"""SUMMARY

        @Return:
        """
        self._fullscreen(action=2)


* Wed 25 Sep 2013 12:28:38 AM JST
    def fullscreen(self):
        r"""SUMMARY

        @Return:
        """
        self._fullscreen(action=1)


* Wed 25 Sep 2013 12:29:17 AM JST
    def _shade(self, action):
        r"""SUMMARY

        @Arguments:

        - `title`:
        - `klass`:
        - `active`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        atom = self._display.intern_atom('_NET_WM_STATE_SHADED')
        self._state_cmd(data=[action, atom, 0, 0, 0])

    def shade(self):
        r"""SUMMARY

        @Return:
        """
        self._shade(action=1)

    def reset_shade(self):
        r"""SUMMARY

        @Return:
        """
        self._shade(action=0)

    def toggle_shade(self):
        r"""SUMMARY

        @Return:
        """
        self._shade(action=2)


* Wed 25 Sep 2013 12:29:52 AM JST
    def reset_shade(self):
        r"""SUMMARY

        @Return:
        """
        self._shade(action=0)


* Wed 25 Sep 2013 12:30:47 AM JST
    def _above(self, action):
        r"""SUMMARY

        @Arguments:

        - `action`:

        @Return:
        """
        atom = self._display.intern_atom('_NET_WM_STATE_ABOVE')
        self._state_cmd(data=[action, atom, 0, 0, 0])

    def above(self):
        r"""SUMMARY

        @Return:
        """
        self._above(action=1)

    def reset_above(self):
        r"""SUMMARY

        @Return:
        """
        self._above(action=0)

    def toggle_above(self):
        r"""SUMMARY

        @Return:
        """
        self._above(action=2)


* Wed 25 Sep 2013 12:32:05 AM JST
    def _below(self, action):
        r"""SUMMARY

        @Arguments:

        - `action`:

        @Return:
        """
        atom = self._display.intern_atom('_NET_WM_STATE_BELOW')
        self._state_cmd(data=[action, atom, 0, 0, 0])

    def below(self):
        r"""SUMMARY

        @Return:
        """
        self._below(action=1)

    def reset_below(self):
        r"""SUMMARY

        @Return:
        """
        self._below(action=0)

    def toggle_below(self):
        r"""SUMMARY

        @Return:
        """
        self._below(action=2)


* Wed 25 Sep 2013 12:32:28 AM JST
    def below(self):
        r"""SUMMARY

        @Return:
        """
        self._below(action=1)


* Wed 25 Sep 2013 12:32:35 AM JST
    def above(self):
        r"""SUMMARY

        @Return:
        """
        self._above(action=1)


* Wed 25 Sep 2013 12:33:18 AM JST
    def minimize(self):
        r"""SUMMARY

        @Return:
        """
        # TODO: (Atami) [2013/09/24]
        # not implementated
        pass

    def minimizeall(self):
        r"""SUMMARY

        @Return:
        """
        # TODO: (Atami) [2013/09/24]
        # not implementated
        pass

    def reset_minimize_all(self):
        r"""SUMMARY

        @Return:
        """
        # TODO: (Atami) [2013/09/24]
        # not implementated
        pass


* Wed 25 Sep 2013 12:34:29 AM JST
    
* Wed 25 Sep 2013 12:36:41 AM JST
    def kill(self):
        r"""Force close window.

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return:
        """
        type_ = self._display.intern_atom('WM_PROTOCOLS', True)
        atom = self._display.intern_atom('WM_DELETE_WINDOW')
        event = _ClientMessage(window=self._window, client_type=type_,
                               data=(32, [atom, _X.CurrentTime, 0, 0, 0]))
        self._send_event(event=event, event_mask=0, sender='window')

    def close(self):
        r"""Close window.

        @Arguments:

        - `title`:
        - `klass`:
        - `pid`:
        - `active`:
        - `regexp`:

        @Return:
        """
        type_ = self._display.intern_atom('_NET_CLOSE_WINDOW')
        event = _ClientMessage(window=self._window, client_type=type_,
                               data=(32, [_X.CurrentTime, 0, 0, 0, 0]))
        self._send_event(event=event, event_mask=_X.SubstructureRedirectMask,
                         sender='root')


* Wed 25 Sep 2013 12:38:56 AM JST
                              
* Wed 25 Sep 2013 12:42:59 AM JST

* Wed 25 Sep 2013 12:42:59 AM JST

* Wed 25 Sep 2013 12:42:59 AM JST
# from wm import active

* Wed 25 Sep 2013 01:01:36 AM JST
WindowManager(win.id)
* Wed 25 Sep 2013 01:01:52 AM JST
WindowManager(id_)
* Wed 25 Sep 2013 01:03:37 AM JST
WindowManager(win.id)
* Wed 25 Sep 2013 01:03:39 AM JST

* Wed 25 Sep 2013 01:03:39 AM JST

* Wed 25 Sep 2013 01:03:39 AM JST
            wm = 

* Wed 25 Sep 2013 01:03:45 AM JST
WindowManager(id_)
* Wed 25 Sep 2013 01:03:48 AM JST

* Wed 25 Sep 2013 01:03:48 AM JST

* Wed 25 Sep 2013 01:03:48 AM JST
        wm = 

* Wed 25 Sep 2013 01:24:58 AM JST
            
* Wed 25 Sep 2013 01:40:01 AM JST
    def _state_cmd(self, data):
        r"""SUMMARY

        @Arguments:

        - `data`:

        @Return:
        """
        assert data[0] in [0, 1, 2]
        event = _ClientMessage(window=self._window,
                              client_type=self._NET_WM_STATE,
                              data=(32, (data)))
        self._send_event(
            event, event_mask=_X.SubstructureRedirectMask, sender='root')


* Wed 25 Sep 2013 01:40:27 AM JST
_WMBelow,
* Wed 25 Sep 2013 01:40:27 AM JST
_WMAbove, _WMBelow,
* Wed 25 Sep 2013 01:40:29 AM JST
_WMShade, _WMAbove, _WMBelow,
* Wed 25 Sep 2013 01:40:30 AM JST
_WMFullscreen,
* Wed 25 Sep 2013 01:40:31 AM JST
_WMMinimize, _WMFullscreen,
* Wed 25 Sep 2013 01:40:35 AM JST
_WMMaximize, _WMMinimize, _WMFullscreen,
* Wed 25 Sep 2013 01:40:36 AM JST
                    _WMMaximize, _WMMinimize, _WMFullscreen,
* Wed 25 Sep 2013 01:44:32 AM JST
200)
* Wed 25 Sep 2013 01:44:33 AM JST
y=200)
* Wed 25 Sep 2013 01:57:06 AM JST
/usr/share/pyshared
* Wed 25 Sep 2013 02:05:32 AM JST
format(
* Wed 25 Sep 2013 02:05:32 AM JST
WindowInfo {}'.format(
* Wed 25 Sep 2013 02:55:22 AM JST

* Wed 25 Sep 2013 02:55:24 AM JST
noecho
* Wed 25 Sep 2013 03:03:25 AM JST
str(w).split('\n')
* Wed 25 Sep 2013 03:04:11 AM JST
num
* Wed 25 Sep 2013 03:13:10 AM JST

* Wed 25 Sep 2013 03:13:10 AM JST

* Wed 25 Sep 2013 03:13:10 AM JST
from

* Wed 25 Sep 2013 03:26:25 AM JST
# for cursor point to beggining of line
* Wed 25 Sep 2013 03:27:54 AM JST
def winstatmonitor(win):
    r"""SUMMARY

    @Arguments:
    - `win`:

    @Return:
    """
    # assert
    stdscr = _curses.initscr()
    _curses.noecho()
    _curses.cbreak()

    try:
        while 1:
            for num, str_ in enumerate(str(win).split('\n'), start=0):
                stdscr.addstr(num, 0, str_ + ' ' * 20)
            # for cursor point to beggining of line
            stdscr.addstr(num + 1, 0, '')
            stdscr.refresh()
            _sleep(1)
    except KeyboardInterrupt:
        pass

    finally:
        _curses.echo()
        _curses.nocbreak()
        _curses.endwin()

* Wed 25 Sep 2013 03:28:36 AM JST
        def winstatmonitor(win):
    r"""SUMMARY

    @Arguments:
    - `win`:

    @Return:
    """
    # assert

* Wed 25 Sep 2013 03:31:09 AM JST
                                           
* Wed 25 Sep 2013 03:36:01 AM JST
BadWindow
* Wed 25 Sep 2013 03:36:03 AM JST
error
* Wed 25 Sep 2013 03:38:52 AM JST
            _curses.echo()
            _curses.nocbreak()
            _curses.endwin()


* Wed 25 Sep 2013 03:41:16 AM JST

* Wed 25 Sep 2013 03:41:16 AM JST

* Wed 25 Sep 2013 03:41:16 AM JST
            _curses.echo()

* Wed 25 Sep 2013 03:41:16 AM JST
            _curses.echo()

* Wed 25 Sep 2013 03:41:16 AM JST
            _curses.echo()
            _curses.nocbreak()

* Wed 25 Sep 2013 03:41:16 AM JST
            _curses.echo()
            _curses.nocbreak()

* Wed 25 Sep 2013 03:41:16 AM JST
            _curses.echo()
            _curses.nocbreak()
            _curses.endwin()

* Wed 25 Sep 2013 03:41:28 AM JST
print(
* Wed 25 Sep 2013 03:41:53 AM JST

* Wed 25 Sep 2013 03:41:53 AM JST

* Wed 25 Sep 2013 03:41:53 AM JST
            pass

* Wed 25 Sep 2013 03:42:13 AM JST
pass
* Wed 25 Sep 2013 03:43:08 AM JST
winstat
* Wed 25 Sep 2013 03:44:29 AM JST
        onerror = ''
        stdscr = _curses.initscr()
        _curses.noecho()
        _curses.cbreak()

        try:
            while 1:
                for num, str_ in enumerate(self.__repr__().split('\n'), start=0):
                    stdscr.addstr(num, 0, str_ + ' ' * 20)
                # for cursor point to beggining of line
                stdscr.addstr(num + 1, 0, '')
                stdscr.refresh()
                _sleep(1)
        except error.BadWindow:
            onerror = 'Not exists or closed Window'

        except KeyboardInterrupt:
            onerror = 'Keyboard Interrupted'

        finally:
            _curses.echo()
            _curses.nocbreak()
            _curses.endwin()
            print(onerror)

* Wed 25 Sep 2013 03:49:06 AM JST

* Wed 25 Sep 2013 03:49:06 AM JST

* Wed 25 Sep 2013 03:49:06 AM JST
    mlen = 20

* Wed 25 Sep 2013 03:55:41 AM JST
mlen = max(len(str_), mlen)
* Wed 25 Sep 2013 03:57:38 AM JST
def activemonitor(idle=0.5):
    r"""SUMMARY

    @Arguments:
    - `win`:

    @Return:
    """
    onerror = ''
    stdscr = _curses.initscr()
    _curses.noecho()
    _curses.cbreak()

    try:
        maxlen = 20
        while 1:
            win = ActiveWindow()
            for num, str_ in enumerate(str(win).split('\n'), start=0):
                maxlen = max(len(str_), maxlen)
                stdscr.addstr(num, 0, str_ + ' ' * maxlen)
            # for cursor point to beggining of line
            stdscr.addstr(num + 1, 0, '')
            stdscr.refresh()
            _sleep(idle)
    except error.BadWindow:
        onerror = 'Not exists or closed Window'

    except KeyboardInterrupt:
        onerror = 'Keyboard Interrupted'

    finally:
        _curses.echo()
        _curses.nocbreak()
        _curses.endwin()
        print(onerror)

* Wed 25 Sep 2013 03:57:57 AM JST

* Wed 25 Sep 2013 03:57:57 AM JST

* Wed 25 Sep 2013 03:57:57 AM JST
import curses as _curses

* Wed 25 Sep 2013 03:58:08 AM JST

* Wed 25 Sep 2013 03:58:08 AM JST

* Wed 25 Sep 2013 03:58:08 AM JST
from Xlib import error

* Wed 25 Sep 2013 03:58:16 AM JST

* Wed 25 Sep 2013 03:58:16 AM JST

* Wed 25 Sep 2013 03:58:17 AM JST
# from Xlib.display import Display as _XDisplay

* Wed 25 Sep 2013 03:58:18 AM JST

* Wed 25 Sep 2013 03:58:18 AM JST

* Wed 25 Sep 2013 03:58:18 AM JST
# from Xlib import X as _X

* Wed 25 Sep 2013 03:58:25 AM JST

* Wed 25 Sep 2013 03:58:25 AM JST

* Wed 25 Sep 2013 03:58:25 AM JST
from wm.active import ActiveWindow

* Wed 25 Sep 2013 03:58:29 AM JST
activemonitor'
* Wed 25 Sep 2013 03:59:06 AM JST
from time import sleep as _sleep
* Wed 25 Sep 2013 03:59:56 AM JST
active
* Wed 25 Sep 2013 03:59:58 AM JST
active
* Wed 25 Sep 2013 04:18:31 AM JST
onerror = 'Not exists or closed Window'
* Wed 25 Sep 2013 04:56:09 AM JST
ac._window.get_property(ac._display.intern_atom('_NET_WM_WINDOW_TYPE', ))
* Wed 25 Sep 2013 05:04:16 AM JST
_XDisplay()
* Wed 25 Sep 2013 05:09:38 AM JST
    # List of window types
    TYPE_DESKTOP = XObject.atom('_NET_WM_WINDOW_TYPE_DESKTOP')
    TYPE_DOCK = XObject.atom('_NET_WM_WINDOW_TYPE_DOCK')
    TYPE_TOOLBAR = XObject.atom('_NET_WM_WINDOW_TYPE_TOOLBAR')
    TYPE_MENU = XObject.atom('_NET_WM_WINDOW_TYPE_MENU')
    TYPE_UTILITY = XObject.atom('_NET_WM_WINDOW_TYPE_UTILITY')
    TYPE_SPLASH = XObject.atom('_NET_WM_WINDOW_TYPE_SPLASH')
    TYPE_DIALOG = XObject.atom('_NET_WM_WINDOW_TYPE_DIALOG')
    TYPE_NORMAL = XObject.atom('_NET_WM_WINDOW_TYPE_NORMAL')

* Wed 25 Sep 2013 05:09:46 AM JST
XObject
* Wed 25 Sep 2013 05:15:33 AM JST
pass
* Wed 25 Sep 2013 05:21:52 AM JST
        str_.append(f)
* Wed 25 Sep 2013 05:23:32 AM JST
max()
* Wed 25 Sep 2013 05:27:11 AM JST

* Wed 25 Sep 2013 05:27:11 AM JST

* Wed 25 Sep 2013 05:27:11 AM JST
        fmt = '\n{0:<9}: {1}'

* Wed 25 Sep 2013 05:31:03 AM JST

* Wed 25 Sep 2013 05:31:03 AM JST

* Wed 25 Sep 2013 05:31:03 AM JST
        str_ = [str(self.__class__)]

* Wed 25 Sep 2013 05:31:21 AM JST

* Wed 25 Sep 2013 05:31:21 AM JST

* Wed 25 Sep 2013 05:31:21 AM JST
        str_ = [str(self.__class__)]

* Wed 25 Sep 2013 05:38:47 AM JST

* Wed 25 Sep 2013 05:38:47 AM JST

* Wed 25 Sep 2013 05:38:47 AM JST
        print(leftlen)

* Wed 25 Sep 2013 05:38:48 AM JST

* Wed 25 Sep 2013 05:38:48 AM JST

* Wed 25 Sep 2013 05:38:48 AM JST
        print(fmt)

* Wed 25 Sep 2013 05:39:59 AM JST
window 
* Wed 25 Sep 2013 05:57:59 AM JST
_NET_WM_ALLOWED_ACTIONS
* Wed 25 Sep 2013 02:03:31 PM JST
get_screen
* Wed 25 Sep 2013 02:27:06 PM JST
screen_count
* Wed 25 Sep 2013 02:41:41 PM JST
display_extension_methods
* Wed 25 Sep 2013 03:34:08 PM JST
def iter_wins():
    r"""Generator

    @Return:
    """
    for id_ in getids():
        yield WindowManager(id_)


* Wed 25 Sep 2013 03:39:35 PM JST
def getids():
    r"""SUMMARY

    @Return:
    """
    display = _XDisplay()
    root = display.screen().root
    return (root.get_full_property(
        display.intern_atom('_NET_CLIENT_LIST'), _X.AnyPropertyType).value)


* Wed 25 Sep 2013 03:40:58 PM JST
assert
* Wed 25 Sep 2013 03:43:16 PM JST
    if title or klass or pid or regexp:
        msg = 'Must assign to title, klass, pid or regexp.'
        raise ValueError(msg)


* Wed 25 Sep 2013 03:45:01 PM JST
getwin(title=title, klass=klass, pid=pid, regexp=regexp)
* Wed 25 Sep 2013 03:45:46 PM JST

* Wed 25 Sep 2013 03:45:46 PM JST

* Wed 25 Sep 2013 03:45:46 PM JST
    assert title or klass or pid or regexp

* Wed 25 Sep 2013 03:46:19 PM JST
    
* Wed 25 Sep 2013 03:47:08 PM JST

* Wed 25 Sep 2013 03:47:08 PM JST

* Wed 25 Sep 2013 03:47:08 PM JST
    assert title or klass or pid or regexp

* Wed 25 Sep 2013 03:49:06 PM JST
    name_list += ['【天気】'.decode('UTF-8'), 'Japan News', 'Foreign News']
    for folder in name_list:
        for url in ChromeBMParse(folder):
            openchrome('"{}"'.format(url))
        if not folder in ['Summer', 'Winter', 'Foreign News']:
            if not yesnodialog('Prompt', 'Please Enter OK will next: '):
                sys.exit(1)

* Wed 25 Sep 2013 03:51:17 PM JST
from mygoogle.chrome import ChromeBMParse
* Wed 25 Sep 2013 03:55:29 PM JST
fmt = '{}'
* Wed 25 Sep 2013 03:56:00 PM JST
from MODULE import 
* Wed 25 Sep 2013 03:56:33 PM JST

* Wed 25 Sep 2013 03:56:33 PM JST

* Wed 25 Sep 2013 03:56:33 PM JST
        openchrome('"{}"'.format(url))

* Wed 25 Sep 2013 04:03:34 PM JST
'【天気】'.decode('UTF-8')
* Wed 25 Sep 2013 04:03:38 PM JST

* Wed 25 Sep 2013 04:03:38 PM JST

* Wed 25 Sep 2013 04:03:38 PM JST
for folder in name_list:

* Wed 25 Sep 2013 04:10:07 PM JST
name
* Wed 25 Sep 2013 04:21:01 PM JST

* Wed 25 Sep 2013 04:21:01 PM JST

* Wed 25 Sep 2013 04:21:02 PM JST
    print(s.pid)

* Wed 25 Sep 2013 04:21:06 PM JST
    print(s.pid)

* Wed 25 Sep 2013 04:21:06 PM JST
    print(s.pid)
    wait = wm.waitwin(sec=180, pid=s.pid)

* Wed 25 Sep 2013 04:21:11 PM JST
    print(s.pid)
    wait = wm.waitwin(sec=180, pid=s.pid)

* Wed 25 Sep 2013 04:21:11 PM JST
    print(s.pid)
    wait = wm.waitwin(sec=180, pid=s.pid)
    if wait:

* Wed 25 Sep 2013 04:21:14 PM JST
    print(s.pid)
    wait = wm.waitwin(sec=180, pid=s.pid)
    if wait:

* Wed 25 Sep 2013 04:21:14 PM JST
    print(s.pid)
    wait = wm.waitwin(sec=180, pid=s.pid)
    if wait:
        print('DEBUG-1-2013-09-25-154907.junk.py')

* Wed 25 Sep 2013 04:21:14 PM JST
    print(s.pid)
    wait = wm.waitwin(sec=180, pid=s.pid)
    if wait:
        print('DEBUG-1-2013-09-25-154907.junk.py')

* Wed 25 Sep 2013 04:21:14 PM JST
    print(s.pid)
    wait = wm.waitwin(sec=180, pid=s.pid)
    if wait:
        print('DEBUG-1-2013-09-25-154907.junk.py')
        w = wm.winget(pid=s.pid)

* Wed 25 Sep 2013 04:21:14 PM JST
    print(s.pid)
    wait = wm.waitwin(sec=180, pid=s.pid)
    if wait:
        print('DEBUG-1-2013-09-25-154907.junk.py')
        w = wm.winget(pid=s.pid)

* Wed 25 Sep 2013 04:21:15 PM JST
    print(s.pid)
    wait = wm.waitwin(sec=180, pid=s.pid)
    if wait:
        print('DEBUG-1-2013-09-25-154907.junk.py')
        w = wm.winget(pid=s.pid)
        w.move(x=1280, y=0)

* Wed 25 Sep 2013 04:23:32 PM JST
    for w in wm.iter_wins():
        if w.klass[1] == 'Google-chrome':
            idlist.append(w.id)


* Wed 25 Sep 2013 04:24:16 PM JST
for w in wm.iter_wins():
    if w.klass[1] == 'Google-chrome':

* Wed 25 Sep 2013 04:25:45 PM JST
    for w in wm.iter_wins():
        if w.klass[1] == 'Google-chrome':
            if not w.id in idlist:
                idlist.append(w.id)
            w.move(x=1280, y=0)
* Wed 25 Sep 2013 04:30:31 PM JST
sleep(10)
* Wed 25 Sep 2013 04:32:37 PM JST
sleep
* Wed 25 Sep 2013 04:32:43 PM JST
not 
* Wed 25 Sep 2013 04:37:18 PM JST
ChromeBMParse('【天気】'.decode('UTF-8'))
* Wed 25 Sep 2013 04:38:05 PM JST
chromewinids()
* Wed 25 Sep 2013 04:39:30 PM JST
and 
* Wed 25 Sep 2013 04:39:30 PM JST
afterids and 
* Wed 25 Sep 2013 04:39:31 PM JST
beforeids != afterids and 
* Wed 25 Sep 2013 04:42:44 PM JST

* Wed 25 Sep 2013 04:42:44 PM JST

* Wed 25 Sep 2013 04:42:44 PM JST
    pass

* Wed 25 Sep 2013 04:42:49 PM JST
beforeids = chromewinids()
for count, url in enumerate(ChromeBMParse('【天気】'.decode('UTF-8')), start=1):
    s = sbp.Popen([CMD.get('google-chrome'), '--new-window', url])

while 1:
    afterids = chromewinids()
    if count <= len(afterids) - len(beforeids):
        break
    sleep(1)

for w in wm.iter_wins():
    if w.klass[1] == 'Google-chrome':
        if not w.id in beforeids:
            beforeids.append(w.id)
        w.move(x=1280, y=0)

* Wed 25 Sep 2013 05:09:03 PM JST
zip(keys, values)
* Wed 25 Sep 2013 05:12:33 PM JST

* Wed 25 Sep 2013 05:12:33 PM JST

* Wed 25 Sep 2013 05:12:33 PM JST
            pass

* Wed 25 Sep 2013 05:14:32 PM JST

* Wed 25 Sep 2013 05:14:32 PM JST

* Wed 25 Sep 2013 05:14:33 PM JST
        if not hasattr(activewin, 'id'):

* Wed 25 Sep 2013 05:14:33 PM JST
        if not hasattr(activewin, 'id'):

* Wed 25 Sep 2013 05:14:33 PM JST
        if not hasattr(activewin, 'id'):
            return False

* Wed 25 Sep 2013 05:15:15 PM JST

* Wed 25 Sep 2013 05:15:15 PM JST

* Wed 25 Sep 2013 05:15:15 PM JST
        return self.id == activewin.id

* Wed 25 Sep 2013 05:16:21 PM JST
print
* Wed 25 Sep 2013 05:18:36 PM JST

* Wed 25 Sep 2013 05:18:36 PM JST

* Wed 25 Sep 2013 05:18:36 PM JST
            print('DEBUG-4-_core.py')

* Wed 25 Sep 2013 05:18:38 PM JST

* Wed 25 Sep 2013 05:18:38 PM JST

* Wed 25 Sep 2013 05:18:38 PM JST
        print('DEBUG-3-_core.py')

* Wed 25 Sep 2013 05:18:54 PM JST

* Wed 25 Sep 2013 05:18:54 PM JST

* Wed 25 Sep 2013 05:18:54 PM JST
        print('DEBUG-1-_core.py')

* Wed 25 Sep 2013 05:18:55 PM JST

* Wed 25 Sep 2013 05:18:55 PM JST

* Wed 25 Sep 2013 05:18:55 PM JST
        print('DEBUG-2-_core.py')

* Wed 25 Sep 2013 05:39:18 PM JST
display.screen().root.get_geometry()
* Wed 25 Sep 2013 05:42:42 PM JST
'Google-chrome'
* Wed 25 Sep 2013 06:03:09 PM JST
x=1280, y=370, height=675, width=560
* Wed 25 Sep 2013 06:03:27 PM JST
x=1280, y=-100, height=575, width=560
* Wed 25 Sep 2013 06:04:25 PM JST
1840
* Wed 25 Sep 2013 06:04:57 PM JST

* Wed 25 Sep 2013 06:05:01 PM JST
1840
* Wed 25 Sep 2013 06:05:56 PM JST

* Wed 25 Sep 2013 06:06:01 PM JST
1840
* Wed 25 Sep 2013 06:06:07 PM JST
2400
* Wed 25 Sep 2013 06:06:17 PM JST
1840
* Wed 25 Sep 2013 06:06:21 PM JST

* Wed 25 Sep 2013 06:06:29 PM JST
2400
* Wed 25 Sep 2013 06:07:43 PM JST
x=1280, y=370, height=675, width=560
* Wed 25 Sep 2013 06:07:53 PM JST
height=
* Wed 25 Sep 2013 06:07:55 PM JST
width=
* Wed 25 Sep 2013 06:08:03 PM JST
1840, y=370, height=675, width=560
* Wed 25 Sep 2013 06:08:12 PM JST
height=
* Wed 25 Sep 2013 06:08:13 PM JST
width=
* Wed 25 Sep 2013 06:08:21 PM JST
2400, y=370, height=675, width=560
* Wed 25 Sep 2013 06:08:29 PM JST
y=
* Wed 25 Sep 2013 06:08:31 PM JST
height=
* Wed 25 Sep 2013 06:08:32 PM JST
width=
* Wed 25 Sep 2013 06:09:35 PM JST
x=1280, y=-100, height=575, width=560
* Wed 25 Sep 2013 06:09:42 PM JST
x=
* Wed 25 Sep 2013 06:09:44 PM JST
y=
* Wed 25 Sep 2013 06:09:46 PM JST
height=
* Wed 25 Sep 2013 06:09:48 PM JST
width=
* Wed 25 Sep 2013 06:10:14 PM JST
x=1840, y=-100, height=575, width=560
* Wed 25 Sep 2013 06:10:17 PM JST
        
* Wed 25 Sep 2013 06:10:20 PM JST
left
* Wed 25 Sep 2013 06:10:24 PM JST
1280
* Wed 25 Sep 2013 06:10:30 PM JST

* Wed 25 Sep 2013 06:10:33 PM JST
middle
* Wed 25 Sep 2013 06:10:38 PM JST
1840
* Wed 25 Sep 2013 06:14:53 PM JST
1280
* Wed 25 Sep 2013 06:19:06 PM JST
        
* Wed 25 Sep 2013 06:19:14 PM JST

* Wed 25 Sep 2013 06:19:14 PM JST

* Wed 25 Sep 2013 06:19:14 PM JST
        (1280, -100, 575, 560), # left up

* Wed 25 Sep 2013 06:19:23 PM JST

* Wed 25 Sep 2013 06:19:23 PM JST

* Wed 25 Sep 2013 06:19:23 PM JST
        (2400, -100, 575, 560), # right up

* Wed 25 Sep 2013 06:19:33 PM JST
0, 0, 675, 560
* Wed 25 Sep 2013 06:23:03 PM JST
_main
* Wed 25 Sep 2013 06:23:19 PM JST
name_list = []

def chromewinids():
    r"""SUMMARY

    @Return:
    """
    idlist = []
    for w in wm.iter_wins():
        if w.klass[1] == 'Google-chrome':
            idlist.append(w.id)
    return idlist

geos = [(0, 0, 675, 560),      # left display
        (1280, 370, 675, 560), # left down
        (1840, 370, 675, 560), # middle down
        (2400, 370, 675, 560), # right down
        (1840, -100, 575, 560), # middle up
        (2400, -100, 575, 560), # right up
        (1280, -100, 575, 560), # left up
        ]


* Wed 25 Sep 2013 06:23:32 PM JST
s = 
* Wed 25 Sep 2013 06:23:51 PM JST

* Wed 25 Sep 2013 06:23:51 PM JST

* Wed 25 Sep 2013 06:23:51 PM JST
    name_list = []

* Wed 25 Sep 2013 06:24:18 PM JST
def wether():

    def chromewinids():
        r"""SUMMARY

        @Return:
        """
        idlist = []
        for w in wm.iter_wins():
            if w.klass[1] == 'Google-chrome':
                idlist.append(w.id)
        return idlist

    geos = [(0, 0, 675, 560),      # left display
            (1280, 370, 675, 560), # left down
            (1840, 370, 675, 560), # middle down
            (2400, 370, 675, 560), # right down
            (1840, -100, 575, 560), # middle up
            (2400, -100, 575, 560), # right up
            (1280, -100, 575, 560), # left up
            ]

    beforeids = chromewinids()
    for count, url in enumerate(ChromeBMParse('【天気】'.decode('UTF-8')),
                                start=1):
        sbp.Popen([CMD.get('google-chrome'), '--new-window', url])

    while 1:
        afterids = chromewinids()
        if count <= len(afterids) - len(beforeids):
            break
        sleep(1)

    for win in wm.iter_wins():
        if win.klass[1] == 'Google-chrome':
            if not win.id in beforeids:
                beforeids.append(win.id)
                if not geos:
                    x, y, h, w = 0, 0, 675, 560
                else:
                    x, y, h, w = geos.pop(0)
                win.move(x=x, y=y, height=h, width=w)


* Wed 25 Sep 2013 06:24:48 PM JST
import subprocess as sbp


from mygoogle.chrome import ChromeBMParse
from ref import CMD
import wm

* Wed 25 Sep 2013 06:24:56 PM JST

* Wed 25 Sep 2013 06:24:56 PM JST

* Wed 25 Sep 2013 06:24:56 PM JST
import subprocess as sbp

* Wed 25 Sep 2013 06:25:03 PM JST
from confirm import yesnodialog
from mygoogle.chrome import ChromeBMParse
from mytemp.mypsutil import psexists

* Wed 25 Sep 2013 06:25:09 PM JST

* Wed 25 Sep 2013 06:25:09 PM JST

* Wed 25 Sep 2013 06:25:09 PM JST
from mygoogle.chrome import ChromeBMParse

* Wed 25 Sep 2013 06:25:15 PM JST

* Wed 25 Sep 2013 06:25:15 PM JST

* Wed 25 Sep 2013 06:25:15 PM JST
from ref import CMD

* Wed 25 Sep 2013 06:25:18 PM JST
from ref import CMD

* Wed 25 Sep 2013 06:25:18 PM JST
from ref import CMD
import wm

* Wed 25 Sep 2013 06:25:20 PM JST

* Wed 25 Sep 2013 06:25:20 PM JST

* Wed 25 Sep 2013 06:25:20 PM JST
from ref import CMD

* Wed 25 Sep 2013 06:25:26 PM JST

* Wed 25 Sep 2013 06:25:26 PM JST

* Wed 25 Sep 2013 06:25:26 PM JST
from mygoogle.chrome import ChromeBMParse

* Wed 25 Sep 2013 08:12:50 PM JST

* Wed 25 Sep 2013 08:12:50 PM JST

* Wed 25 Sep 2013 08:12:50 PM JST
    name_list = [season]

* Wed 25 Sep 2013 08:14:04 PM JST
Winter', 
* Wed 25 Sep 2013 08:14:04 PM JST
Summer', 'Winter', 
* Thu 26 Sep 2013 12:28:39 AM JST
    @classmethod
    def atom(cls, name):
        """Return atom with given name."""
        return cls.__DISPLAY.intern_atom(name)

* Thu 26 Sep 2013 12:30:09 AM JST
object
* Thu 26 Sep 2013 12:30:43 AM JST
'_NET_WM_WINDOW_TYPE'
* Thu 26 Sep 2013 12:32:15 AM JST
atom
* Thu 26 Sep 2013 12:32:32 AM JST
            
* Thu 26 Sep 2013 12:34:08 AM JST
__DISPLAY
* Thu 26 Sep 2013 12:38:09 AM JST
_Display,
* Thu 26 Sep 2013 12:38:16 AM JST
_Display
* Thu 26 Sep 2013 12:41:54 AM JST
            
* Thu 26 Sep 2013 12:42:40 AM JST
object
* Thu 26 Sep 2013 12:43:18 AM JST
'_NET_WM_STATE_MAXIMIZED_VERT'
* Thu 26 Sep 2013 12:43:22 AM JST
    
* Thu 26 Sep 2013 12:43:50 AM JST
max_vert
* Thu 26 Sep 2013 12:43:52 AM JST
max_horz
* Thu 26 Sep 2013 12:44:03 AM JST
max_horz
* Thu 26 Sep 2013 12:44:14 AM JST
max_horz
* Thu 26 Sep 2013 12:46:53 AM JST

* Thu 26 Sep 2013 12:46:53 AM JST

* Thu 26 Sep 2013 12:46:53 AM JST
        # max_vert = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_VERT')

* Thu 26 Sep 2013 12:46:53 AM JST
        # max_vert = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_VERT')

* Thu 26 Sep 2013 12:46:53 AM JST
        # max_vert = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_VERT')
        # max_horz = self._display.intern_atom('_NET_WM_STATE_MAXIMIZED_HORZ')

* Thu 26 Sep 2013 12:47:05 AM JST
[action, self._MAXIMIZED_VERT,
                              self._MAXIMIZED_HORZ, 0, 0]
* Thu 26 Sep 2013 12:47:07 AM JST
                              
* Thu 26 Sep 2013 12:47:25 AM JST
object
* Thu 26 Sep 2013 12:47:57 AM JST
'_NET_WM_STATE_FULLSCREEN'
* Thu 26 Sep 2013 12:48:27 AM JST
atom
* Thu 26 Sep 2013 12:59:12 AM JST

* Thu 26 Sep 2013 12:59:12 AM JST

* Thu 26 Sep 2013 12:59:12 AM JST
        # atom = self._display.intern_atom()

* Thu 26 Sep 2013 12:59:30 AM JST
STATE_
* Thu 26 Sep 2013 01:00:13 AM JST
                
* Thu 26 Sep 2013 01:00:27 AM JST
[action, self._STATE_MAXIMIZED_VERT, self._STATE_MAXIMIZED_HORZ,
                0, 0]
* Thu 26 Sep 2013 01:00:32 AM JST
                
* Thu 26 Sep 2013 01:00:40 AM JST

* Thu 26 Sep 2013 01:00:40 AM JST

* Thu 26 Sep 2013 01:00:40 AM JST
        data = 

* Thu 26 Sep 2013 01:02:17 AM JST
_X.Above
* Thu 26 Sep 2013 01:02:28 AM JST
above
* Thu 26 Sep 2013 01:02:35 AM JST
_X.Below
* Thu 26 Sep 2013 01:02:42 AM JST

* Thu 26 Sep 2013 01:02:42 AM JST

* Thu 26 Sep 2013 01:02:42 AM JST
        if above is True:

* Thu 26 Sep 2013 01:02:42 AM JST
        if above is True:

* Thu 26 Sep 2013 01:02:42 AM JST
        if above is True:
            mode = 

* Thu 26 Sep 2013 01:02:42 AM JST
        if above is True:
            mode = 

* Thu 26 Sep 2013 01:02:42 AM JST
        if above is True:
            mode = 
        else:

* Thu 26 Sep 2013 01:02:42 AM JST
        if above is True:
            mode = 
        else:

* Thu 26 Sep 2013 01:02:42 AM JST
        if above is True:
            mode = 
        else:
            mode = 

* Thu 26 Sep 2013 01:04:55 AM JST

* Thu 26 Sep 2013 01:04:55 AM JST

* Thu 26 Sep 2013 01:04:55 AM JST
        # atom = self._display.intern_atom('_NET_WM_WINDOW_TYPE')

* Thu 26 Sep 2013 01:06:31 AM JST
object
* Thu 26 Sep 2013 01:06:47 AM JST
'_NET_WM_STATE_SHADED'
* Thu 26 Sep 2013 01:06:55 AM JST
atom
* Thu 26 Sep 2013 01:07:29 AM JST
object
* Thu 26 Sep 2013 01:07:48 AM JST
'_NET_WM_STATE_ABOVE'
* Thu 26 Sep 2013 01:07:57 AM JST
atom
* Thu 26 Sep 2013 01:08:27 AM JST
'_NET_WM_STATE_BELOW'
* Thu 26 Sep 2013 01:08:52 AM JST
atom
* Thu 26 Sep 2013 01:19:37 AM JST
    _WINDOW_TYPE = _Display._atom('_NET_WM_WINDOW_TYPE')
    _WM_PID = _Display._atom('_NET_WM_PID')

* Thu 26 Sep 2013 01:19:45 AM JST
_Display
* Thu 26 Sep 2013 01:19:53 AM JST

* Thu 26 Sep 2013 01:19:53 AM JST

* Thu 26 Sep 2013 01:19:53 AM JST
    _WINDOW_TYPE = _Display._atom('_NET_WM_WINDOW_TYPE')

* Thu 26 Sep 2013 01:19:53 AM JST
    _WINDOW_TYPE = _Display._atom('_NET_WM_WINDOW_TYPE')

* Thu 26 Sep 2013 01:19:53 AM JST
    _WINDOW_TYPE = _Display._atom('_NET_WM_WINDOW_TYPE')
    _WM_PID = _Display._atom('_NET_WM_PID')

* Thu 26 Sep 2013 01:20:51 AM JST
object
* Thu 26 Sep 2013 01:21:01 AM JST
object
* Thu 26 Sep 2013 01:21:10 AM JST
    _STATE_MAXIMIZED_VERT = _Display._atom('_NET_WM_STATE_MAXIMIZED_VERT')
    _STATE_MAXIMIZED_HORZ = _Display._atom('_NET_WM_STATE_MAXIMIZED_HORZ')


* Thu 26 Sep 2013 01:21:36 AM JST
_Display
* Thu 26 Sep 2013 01:21:46 AM JST
object
* Thu 26 Sep 2013 01:21:53 AM JST
_Display
* Thu 26 Sep 2013 01:21:59 AM JST

* Thu 26 Sep 2013 01:21:59 AM JST

* Thu 26 Sep 2013 01:21:59 AM JST
    _STATE_FULLSCREEN = _Display._atom('_NET_WM_STATE_FULLSCREEN')

* Thu 26 Sep 2013 01:22:43 AM JST
_Display
* Thu 26 Sep 2013 01:22:46 AM JST

* Thu 26 Sep 2013 01:22:46 AM JST

* Thu 26 Sep 2013 01:22:46 AM JST
    _STATE_SHADED = _Display._atom('_NET_WM_STATE_SHADED')

* Thu 26 Sep 2013 01:23:08 AM JST
_Display
* Thu 26 Sep 2013 01:23:13 AM JST

* Thu 26 Sep 2013 01:23:13 AM JST

* Thu 26 Sep 2013 01:23:13 AM JST
    _STATE_ABOVE = _Display._atom('_NET_WM_STATE_ABOVE')

* Thu 26 Sep 2013 01:23:27 AM JST
_Display
* Thu 26 Sep 2013 01:23:30 AM JST

* Thu 26 Sep 2013 01:23:30 AM JST

* Thu 26 Sep 2013 01:23:30 AM JST
    _STATE_BELOW = _Display._atom('_NET_WM_STATE_BELOW')

* Thu 26 Sep 2013 01:23:48 AM JST
object
* Thu 26 Sep 2013 01:24:09 AM JST
        type_ = self._display.intern_atom('WM_PROTOCOLS', True)
        atom = self._display.intern_atom('WM_DELETE_WINDOW')

* Thu 26 Sep 2013 01:24:31 AM JST
'_NET_CLOSE_WINDOW'
* Thu 26 Sep 2013 01:26:57 AM JST
'WM_PROTOCOLS
* Thu 26 Sep 2013 01:27:09 AM JST
'WM_DELETE_WINDOW'
* Thu 26 Sep 2013 01:27:45 AM JST
'_NET_CLOSE_WINDOW'
* Thu 26 Sep 2013 01:28:42 AM JST
    # List of window types
    TYPE_DESKTOP = _WMInfo._display.intern_atom('_NET_WM_WINDOW_TYPE_DESKTOP')
    TYPE_DOCK = _WMInfo._display.intern_atom('_NET_WM_WINDOW_TYPE_DOCK')
    TYPE_TOOLBAR = _WMInfo._display.intern_atom('_NET_WM_WINDOW_TYPE_TOOLBAR')
    TYPE_MENU = _WMInfo._display.intern_atom('_NET_WM_WINDOW_TYPE_MENU')
    TYPE_UTILITY = _WMInfo._display.intern_atom('_NET_WM_WINDOW_TYPE_UTILITY')
    TYPE_SPLASH = _WMInfo._display.intern_atom('_NET_WM_WINDOW_TYPE_SPLASH')
    TYPE_DIALOG = _WMInfo._display.intern_atom('_NET_WM_WINDOW_TYPE_DIALOG')
    TYPE_NORMAL = _WMInfo._display.intern_atom('_NET_WM_WINDOW_TYPE_NORMAL')

    TYPES = {
        TYPE_DESKTOP: 'Desktop',
        TYPE_DOCK: 'Dock',
        TYPE_TOOLBAR: 'Toolbar',
        TYPE_MENU: 'Menu',
        TYPE_UTILITY: 'Utility',
        TYPE_SPLASH: 'Splash',
        TYPE_DIALOG: 'Dialog',
        TYPE_NORMAL: 'Nomal',
        }

* Thu 26 Sep 2013 01:28:59 AM JST

* Thu 26 Sep 2013 01:28:59 AM JST

* Thu 26 Sep 2013 01:28:59 AM JST
    # List of window types

* Thu 26 Sep 2013 01:29:53 AM JST
_WMInfo
* Thu 26 Sep 2013 01:31:24 AM JST
       
* Thu 26 Sep 2013 01:33:52 AM JST
    STATE_MODAL = XObject.atom('_NET_WM_STATE_MODAL')
    STATE_STICKY = XObject.atom('_NET_WM_STATE_STICKY')

* Thu 26 Sep 2013 01:34:04 AM JST
XObject
* Thu 26 Sep 2013 01:34:08 AM JST
XObject
* Thu 26 Sep 2013 01:34:43 AM JST
    STATE_SKIP_TASKBAR = XObject.atom('_NET_WM_STATE_SKIP_TASKBAR')
    STATE_SKIP_PAGER = XObject.atom('_NET_WM_STATE_SKIP_PAGER')

* Thu 26 Sep 2013 01:35:02 AM JST
XObject
* Thu 26 Sep 2013 01:35:07 AM JST
XObject
* Thu 26 Sep 2013 01:35:16 AM JST
STATE_HIDDEN = XObject.atom('_NET_WM_STATE_HIDDEN')
* Thu 26 Sep 2013 01:35:28 AM JST
XObject
* Thu 26 Sep 2013 01:35:36 AM JST
STATE_DEMANDS_ATTENTION = XObject.atom('_NET_WM_STATE_DEMANDS_ATTENTION')
* Thu 26 Sep 2013 01:35:41 AM JST
XObject
* Thu 26 Sep 2013 01:39:32 AM JST

* Thu 26 Sep 2013 01:39:32 AM JST

* Thu 26 Sep 2013 01:39:32 AM JST
    _WM_PID = _Display._atom('_NET_WM_PID')

* Thu 26 Sep 2013 01:40:57 AM JST
type_
* Thu 26 Sep 2013 01:41:14 AM JST
atom
* Thu 26 Sep 2013 01:41:48 AM JST
type_
* Thu 26 Sep 2013 01:43:01 AM JST
'_NET_WM_STATE'
* Thu 26 Sep 2013 01:44:23 AM JST

* Thu 26 Sep 2013 01:44:24 AM JST

* Thu 26 Sep 2013 01:44:24 AM JST
        keyval = zip(keys, values)

* Thu 26 Sep 2013 01:44:25 AM JST

* Thu 26 Sep 2013 01:44:25 AM JST

* Thu 26 Sep 2013 01:44:25 AM JST
        keyval = zip(keys, values)

* Thu 26 Sep 2013 01:44:50 AM JST

* Thu 26 Sep 2013 01:44:50 AM JST

* Thu 26 Sep 2013 01:44:50 AM JST
        self._WM_STATE = self._display.intern_atom('_NET_WM_STATE')

* Thu 26 Sep 2013 01:46:40 AM JST

* Thu 26 Sep 2013 01:46:40 AM JST

* Thu 26 Sep 2013 01:46:40 AM JST
        # type_ = self._display.intern_atom('_NET_CLOSE_WINDOW')

* Thu 26 Sep 2013 01:46:43 AM JST

* Thu 26 Sep 2013 01:46:43 AM JST

* Thu 26 Sep 2013 01:46:43 AM JST
        # type_ = self._display.intern_atom('WM_PROTOCOLS', True)

* Thu 26 Sep 2013 01:46:43 AM JST
        # type_ = self._display.intern_atom('WM_PROTOCOLS', True)

* Thu 26 Sep 2013 01:46:43 AM JST
        # type_ = self._display.intern_atom('WM_PROTOCOLS', True)
        # atom = self._display.intern_atom('WM_DELETE_WINDOW')

* Thu 26 Sep 2013 01:46:46 AM JST

* Thu 26 Sep 2013 01:46:46 AM JST

* Thu 26 Sep 2013 01:46:46 AM JST
        # atom = self._display.intern_atom('_NET_WM_STATE_BELOW')

* Thu 26 Sep 2013 01:46:48 AM JST

* Thu 26 Sep 2013 01:46:49 AM JST

* Thu 26 Sep 2013 01:46:49 AM JST
        # atom = self._display.intern_atom('_NET_WM_STATE_ABOVE')

* Thu 26 Sep 2013 01:49:54 AM JST
action
* Thu 26 Sep 2013 01:52:20 AM JST

* Thu 26 Sep 2013 01:52:20 AM JST

* Thu 26 Sep 2013 01:52:20 AM JST
        # atom = self._display.intern_atom()

* Thu 26 Sep 2013 02:00:30 AM JST

* Thu 26 Sep 2013 02:00:30 AM JST

* Thu 26 Sep 2013 02:00:30 AM JST
        # str_ = []

* Thu 26 Sep 2013 02:01:22 AM JST

* Thu 26 Sep 2013 02:01:22 AM JST

* Thu 26 Sep 2013 02:01:22 AM JST
        if display is None:

* Thu 26 Sep 2013 02:21:34 AM JST
w._window.get_property
* Thu 26 Sep 2013 02:24:10 AM JST
'_NET_WM_WINDOW_TYPE'
* Thu 26 Sep 2013 02:26:40 AM JST
_X.AnyPropertyType,
* Thu 26 Sep 2013 02:26:40 AM JST
                                              _X.AnyPropertyType,
* Thu 26 Sep 2013 02:26:46 AM JST
                                              
* Thu 26 Sep 2013 02:27:08 AM JST
AnyPropertyType, 
* Thu 26 Sep 2013 02:27:13 AM JST
                
* Thu 26 Sep 2013 02:28:44 AM JST
'_NET_WM_STATE'
* Thu 26 Sep 2013 02:33:26 AM JST
_STATE_MAXIMIZED_VERT
* Thu 26 Sep 2013 02:35:09 AM JST

* Thu 26 Sep 2013 02:35:09 AM JST

* Thu 26 Sep 2013 02:35:09 AM JST
        return False

* Thu 26 Sep 2013 02:37:03 AM JST
    def ismaximize(self):
        r"""SUMMARY

        @Return:
        """
        try:
            props = self._window.get_full_property(self._WM_STATE, 0).value.tolist()
            if (self._STATE_MAXIMIZED_VERT in props and
                self._STATE_MAXIMIZED_HORZ in props):
                return True
            return False
        except AttributeError:
            return False

* Thu 26 Sep 2013 02:37:32 AM JST
_WM_STATE
* Thu 26 Sep 2013 02:38:10 AM JST
self._STATE_MAXIMIZED_HORZ in props
* Thu 26 Sep 2013 02:38:11 AM JST
                self._STATE_MAXIMIZED_HORZ in props
* Thu 26 Sep 2013 02:39:44 AM JST
        try:
            props = self._window.get_full_property(self._WM_STATE, 0).value.tolist()
            if self._STATE_SHADED in props:
                return True
            return False
        except AttributeError:
            return False

* Thu 26 Sep 2013 02:43:02 AM JST
_NET_WM_ALLOWED_ACTIONS
* Thu 26 Sep 2013 02:44:52 AM JST
_NET_DESKTOP_LAYOUT
* Thu 26 Sep 2013 02:57:03 AM JST
'_NET_CURRENT_DESKTOP'
* Thu 26 Sep 2013 03:38:12 AM JST
'_NET_FRAME_EXTENTS'
* Thu 26 Sep 2013 03:46:21 AM JST
_AtomHolder
* Thu 26 Sep 2013 03:46:30 AM JST
_WMState
* Thu 26 Sep 2013 03:47:03 AM JST
class _WMState(_WMMaximize, _WMFullscreen, _WMShade, _WMAbove, _WMBelow):
    r"""
    """

    def _state_cmd(self, data):
        r"""SUMMARY

        @Arguments:

        - `data`:

        @Return:
        """
        assert data[0] in [0, 1, 2]
        event = _ClientMessage(window=self._window,
                              client_type=self._WM_STATE,
                              data=(32, (data)))
        self._send_event(
            event, event_mask=_X.SubstructureRedirectMask, sender='root')



* Thu 26 Sep 2013 03:47:41 AM JST
_AtomHolder
* Thu 26 Sep 2013 03:47:56 AM JST
_AtomHolder
* Thu 26 Sep 2013 03:48:13 AM JST
_AtomHolder
* Thu 26 Sep 2013 03:48:32 AM JST
_AtomHolder
* Thu 26 Sep 2013 03:48:41 AM JST
_WMBelow
* Thu 26 Sep 2013 03:48:41 AM JST
_WMAbove, _WMBelow
* Thu 26 Sep 2013 03:48:41 AM JST
_WMShade, _WMAbove, _WMBelow
* Thu 26 Sep 2013 03:48:41 AM JST
_WMFullscreen, _WMShade, _WMAbove, _WMBelow
* Thu 26 Sep 2013 03:48:42 AM JST
_WMMaximize, _WMFullscreen, _WMShade, _WMAbove, _WMBelow
* Thu 26 Sep 2013 03:49:18 AM JST
self._window.get_full_property(self._WM_STATE, 0).value.tolist()
* Thu 26 Sep 2013 03:50:17 AM JST
_window.get_full_property(self._WM_STATE, 0).value.tolist()
* Thu 26 Sep 2013 03:51:14 AM JST
    def isshade(self):
        r"""SUMMARY

        @Return:
        """
        try:
            props = self._window.get_full_property(self._WM_STATE, 0).value.tolist()
            if self._STATE_SHADED in props:
                return True
            return False
        except AttributeError:
            return False

* Thu 26 Sep 2013 03:51:25 AM JST
window.get_full_property(self._WM_STATE, 0).value.tolist()
* Thu 26 Sep 2013 03:51:43 AM JST
    def isfullscreen(self):
        r"""SUMMARY

        @Return:
        """
        try:
            props = self._get_state()
            if self._STATE_SHADED in props:
                return True
            return False
        except AttributeError:
            return False


* Thu 26 Sep 2013 03:52:00 AM JST
self._STATE_FULLSCREEN
* Thu 26 Sep 2013 03:52:32 AM JST
    def ismaximize(self):
        r"""SUMMARY

        @Return:
        """
        try:
            props = self._get_state()
            if (self._STATE_MAXIMIZED_VERT in props and
                self._STATE_MAXIMIZED_HORZ in props):
                return True
            return False
        except AttributeError:
            return False


* Thu 26 Sep 2013 03:52:52 AM JST
window.get_full_property(self._WM_STATE, 0).value.tolist()
* Thu 26 Sep 2013 03:53:19 AM JST
window.get_full_property(self._WM_STATE, 0).value.tolist()
* Thu 26 Sep 2013 03:53:30 AM JST
    def isabove(self):
        r"""SUMMARY

        @Return:
        """
        try:
            props = self._get_state()
            if self._STATE_ABOVE in props:
                return True
            return False
        except AttributeError:
            return False


* Thu 26 Sep 2013 03:53:36 AM JST
    def isshade(self):
        r"""SUMMARY

        @Return:
        """
        try:
            props = self._get_state()
            if self._STATE_SHADED in props:
                return True
            return False
        except AttributeError:
            return False


* Thu 26 Sep 2013 03:53:46 AM JST
    def isbelow(self):
        r"""SUMMARY

        @Return:
        """
        try:
            props = self._window.get_full_property(self._WM_STATE, 0).value.tolist()
            if self._STATE_BELOW in props:
                return True
            return False
        except AttributeError:
            return False


* Thu 26 Sep 2013 03:53:51 AM JST
window.get_full_property(self._WM_STATE, 0).value.tolist()
* Thu 26 Sep 2013 03:54:28 AM JST
_WMBelow
* Thu 26 Sep 2013 03:54:37 AM JST
_WMState
* Thu 26 Sep 2013 03:54:48 AM JST
_WMShade
* Thu 26 Sep 2013 03:54:56 AM JST
_WMFullscreen
* Thu 26 Sep 2013 03:55:01 AM JST
_WMMinimize
* Thu 26 Sep 2013 03:55:08 AM JST
_WMMaximize
* Thu 26 Sep 2013 03:55:34 AM JST

* Thu 26 Sep 2013 03:55:34 AM JST

* Thu 26 Sep 2013 03:55:34 AM JST
        Override ActiveWindow

* Thu 26 Sep 2013 03:55:37 AM JST

* Thu 26 Sep 2013 03:55:37 AM JST

* Thu 26 Sep 2013 03:55:37 AM JST
        Override ActiveWindow

* Thu 26 Sep 2013 03:56:27 AM JST
_WMBelow, _WMState, _WMShade, _WMFullscreen, _WMMaximize
* Thu 26 Sep 2013 03:56:39 AM JST
_WMState, 
* Thu 26 Sep 2013 03:56:48 AM JST
                    
* Thu 26 Sep 2013 03:56:54 AM JST
_WMState,
* Thu 26 Sep 2013 03:56:56 AM JST
                    
* Thu 26 Sep 2013 04:05:28 AM JST
/usr/local/lib/python2.7/dist-packages/autopy/
* Thu 26 Sep 2013 04:05:30 AM JST
__init__.pyc
* Thu 26 Sep 2013 04:14:07 AM JST
15517
* Thu 26 Sep 2013 04:17:14 AM JST
13596
* Thu 26 Sep 2013 04:21:07 AM JST
ps = 
* Thu 26 Sep 2013 04:21:17 AM JST
ps = 
* Thu 26 Sep 2013 04:21:19 AM JST

* Thu 26 Sep 2013 04:21:19 AM JST

* Thu 26 Sep 2013 04:21:19 AM JST
        return ps.name

* Thu 26 Sep 2013 04:26:06 AM JST
psutil.Process(self.pid).create_time
* Thu 26 Sep 2013 04:27:25 AM JST
from
* Thu 26 Sep 2013 04:27:25 AM JST
datetime.from
* Thu 26 Sep 2013 04:27:25 AM JST
datetime.datetime.from
* Thu 26 Sep 2013 04:27:27 AM JST
psutil.Process(self.pid).create_time
* Thu 26 Sep 2013 04:27:29 AM JST

* Thu 26 Sep 2013 04:27:29 AM JST

* Thu 26 Sep 2013 04:27:29 AM JST
        ctime = 

* Thu 26 Sep 2013 04:37:26 AM JST
_window.
* Thu 26 Sep 2013 04:37:36 AM JST
pid)
* Thu 26 Sep 2013 04:37:36 AM JST
self.pid)
* Thu 26 Sep 2013 04:37:37 AM JST
Process(self.pid)
* Thu 26 Sep 2013 04:37:37 AM JST
psutil.Process(self.pid)
* Thu 26 Sep 2013 04:37:49 AM JST
self._ps
* Thu 26 Sep 2013 04:38:48 AM JST

* Thu 26 Sep 2013 04:38:48 AM JST

* Thu 26 Sep 2013 04:38:48 AM JST
        _

* Thu 26 Sep 2013 04:40:21 AM JST

* Thu 26 Sep 2013 04:40:21 AM JST

* Thu 26 Sep 2013 04:40:21 AM JST
        _WMInfo.__init__(self, display=display)

* Thu 26 Sep 2013 04:49:58 AM JST
    @property
    def type(self):
        r"""SUMMARY

        @Return:
        """
        try:
            prpty = self._window.get_full_property(
                self._WINDOW_TYPE, 0).value.tolist()[0]
            return self._TYPES.get(prpty, '')
        except:
            return ''


* Thu 26 Sep 2013 04:50:48 AM JST
psname
* Thu 26 Sep 2013 04:50:54 AM JST
cmdline
* Thu 26 Sep 2013 04:50:58 AM JST
createtime
* Thu 26 Sep 2013 04:51:03 AM JST
io
* Thu 26 Sep 2013 04:51:06 AM JST
openedfiles
* Thu 26 Sep 2013 04:51:11 AM JST
cwd
* Thu 26 Sep 2013 04:54:11 AM JST
psname,cmdline,
* Thu 26 Sep 2013 04:54:54 AM JST
                'x',
                'y',
                'height',
                'width',
                'isactive',

* Thu 26 Sep 2013 04:55:00 AM JST
                  self.geo.x,
                  self.geo.y,
                  self.geo.height,
                  self.geo.width,
                  self.isactive(),

* Thu 26 Sep 2013 04:55:50 AM JST

* Thu 26 Sep 2013 04:55:50 AM JST

* Thu 26 Sep 2013 04:55:50 AM JST
                  self.isactive(),

* Thu 26 Sep 2013 04:56:08 AM JST

* Thu 26 Sep 2013 04:56:08 AM JST

* Thu 26 Sep 2013 04:56:08 AM JST
                'isactive',

* Thu 26 Sep 2013 04:56:56 AM JST
createtime
* Thu 26 Sep 2013 04:57:19 AM JST
createtime,
* Thu 26 Sep 2013 05:00:23 AM JST

* Thu 26 Sep 2013 05:00:23 AM JST

* Thu 26 Sep 2013 05:00:23 AM JST
            print('DEBUG-1-_core.py')

* Thu 26 Sep 2013 05:00:31 AM JST

* Thu 26 Sep 2013 05:00:31 AM JST

* Thu 26 Sep 2013 05:00:31 AM JST
            print('DEBUG-1-_core.py')

* Thu 26 Sep 2013 05:00:41 AM JST
KLUDGE
* Thu 26 Sep 2013 05:02:18 AM JST
KLUDGE
* Thu 26 Sep 2013 05:04:24 AM JST
        io = self.io
        str_.append(fmt.format('read count'))

* Thu 26 Sep 2013 05:05:09 AM JST

* Thu 26 Sep 2013 05:05:09 AM JST

* Thu 26 Sep 2013 05:05:09 AM JST
        str_.append(fmt.format('read count'))

* Thu 26 Sep 2013 05:10:24 AM JST
print('Press "Control-c" will exit.')
* Thu 26 Sep 2013 05:13:11 AM JST
'Press "Control-c" will exit.'
* Thu 26 Sep 2013 05:13:31 AM JST

* Thu 26 Sep 2013 05:13:31 AM JST

* Thu 26 Sep 2013 05:13:31 AM JST
    print('Press "Control-c" will exit.')

* Thu 26 Sep 2013 05:14:31 AM JST
stdscr.addstr(0, 0, '* Press "Control c" will exit. *')
* Thu 26 Sep 2013 05:15:05 AM JST

* Thu 26 Sep 2013 05:15:05 AM JST

* Thu 26 Sep 2013 05:15:05 AM JST
        print('Press "Control-c" will exit.')

* Thu 26 Sep 2013 05:18:28 AM JST
%Y-%m-%d %H:%M:%S
* Thu 26 Sep 2013 05:40:45 AM JST
                  
* Thu 26 Sep 2013 05:41:17 AM JST
_determine
* Thu 26 Sep 2013 06:30:21 AM JST
for w in 
* Thu 26 Sep 2013 06:35:36 AM JST
OP: 
* Thu 26 Sep 2013 06:35:41 AM JST
AR: 
* Thu 26 Sep 2013 06:35:46 AM JST
TY: 
* Thu 26 Sep 2013 06:35:47 AM JST
H: 
* Thu 26 Sep 2013 06:35:48 AM JST
G: 
* Thu 26 Sep 2013 06:35:50 AM JST
L: 
* Thu 26 Sep 2013 06:36:18 AM JST
SUMMARY
* Thu 26 Sep 2013 06:37:33 AM JST

* Thu 26 Sep 2013 06:37:33 AM JST

* Thu 26 Sep 2013 06:37:33 AM JST
        Desktop, Dock, Toolbar, Menu, Utility, Splash, Dialog, Normal 

* Thu 26 Sep 2013 06:49:55 AM JST
close()
* Thu 26 Sep 2013 06:49:56 AM JST
win.close()
* Thu 26 Sep 2013 06:57:37 AM JST

* Thu 26 Sep 2013 06:57:37 AM JST

* Thu 26 Sep 2013 06:57:37 AM JST
    display = _XDisplay()

* Thu 26 Sep 2013 07:00:46 AM JST
win
* Thu 26 Sep 2013 07:05:29 AM JST

* Thu 26 Sep 2013 07:05:29 AM JST

* Thu 26 Sep 2013 07:05:29 AM JST
            if winlist:

* Thu 26 Sep 2013 07:05:29 AM JST
            if winlist:

* Thu 26 Sep 2013 07:05:29 AM JST
            if winlist:
                for win in winlist:

* Thu 26 Sep 2013 07:05:36 AM JST

* Thu 26 Sep 2013 07:05:36 AM JST

* Thu 26 Sep 2013 07:05:36 AM JST
            winlist = []

* Thu 26 Sep 2013 07:11:17 AM JST
            if wm.exists(determine=spnir_determine):
                win = wm.getwin(determine=spnir_determine)
                win.close()

* Thu 26 Sep 2013 07:11:29 AM JST
            if wm.exists(determine=spnir_determine):
                win = wm.getwin(determine=spnir_determine)
                win.close()

* Thu 26 Sep 2013 07:11:51 AM JST

* Thu 26 Sep 2013 07:11:51 AM JST

* Thu 26 Sep 2013 07:11:52 AM JST
            sleep(1)

* Thu 26 Sep 2013 07:33:51 AM JST
before
* Thu 26 Sep 2013 07:33:56 AM JST
beforeids
* Thu 26 Sep 2013 08:08:49 AM JST
3, 
* Thu 26 Sep 2013 08:08:50 AM JST
sec=3, 
* Thu 26 Sep 2013 08:20:18 AM JST

* Thu 26 Sep 2013 08:20:18 AM JST

* Thu 26 Sep 2013 08:20:18 AM JST
    # g = ChromeBMParse()

* Thu 26 Sep 2013 08:27:24 AM JST
    geos = [(0, 0, 675, 560),      # left display
            (1280, 370, 675, 560), # left down
            (1840, 370, 675, 560), # middle down
            (2400, 370, 675, 560), # right down
            (1840, -100, 575, 560), # middle up
            (2400, -100, 575, 560), # right up
            (1280, -100, 575, 560), # left up
            ]


* Thu 26 Sep 2013 08:27:27 AM JST
    geos = [(0, 0, 675, 560),      # left display
            (1280, 370, 675, 560), # left down
            (1840, 370, 675, 560), # middle down
            (2400, 370, 675, 560), # right down
            (1840, -100, 575, 560), # middle up
            (2400, -100, 575, 560), # right up
            (1280, -100, 575, 560), # left up
            ]


* Thu 26 Sep 2013 08:29:13 AM JST
print()
* Thu 26 Sep 2013 08:32:22 AM JST
after
* Thu 26 Sep 2013 08:32:34 AM JST

* Thu 26 Sep 2013 08:32:34 AM JST

* Thu 26 Sep 2013 08:32:34 AM JST
    print(afterids)

* Thu 26 Sep 2013 08:32:34 AM JST
    print(afterids)

* Thu 26 Sep 2013 08:32:34 AM JST
    print(afterids)
    print(beforeids)

* Thu 26 Sep 2013 08:33:50 AM JST
200, 120, 700, 880
* Thu 26 Sep 2013 08:34:09 AM JST

* Thu 26 Sep 2013 08:34:09 AM JST

* Thu 26 Sep 2013 08:34:09 AM JST
            print('DEBUG-1-daily.py')

* Thu 26 Sep 2013 08:34:10 AM JST

* Thu 26 Sep 2013 08:34:10 AM JST

* Thu 26 Sep 2013 08:34:10 AM JST
                print('DEBUG-2-daily.py')

* Thu 26 Sep 2013 08:34:11 AM JST

* Thu 26 Sep 2013 08:34:11 AM JST

* Thu 26 Sep 2013 08:34:11 AM JST
                    print('DEBUG-3-daily.py')

* Thu 26 Sep 2013 08:34:12 AM JST

* Thu 26 Sep 2013 08:34:12 AM JST

* Thu 26 Sep 2013 08:34:12 AM JST
                    print('DEBUG-4-daily.py')

* Thu 26 Sep 2013 08:34:25 AM JST

* Thu 26 Sep 2013 08:34:25 AM JST

* Thu 26 Sep 2013 08:34:25 AM JST
    print('DEBUG-5-daily.py')

* Thu 26 Sep 2013 08:40:53 AM JST
pylib/
* Thu 26 Sep 2013 08:41:11 AM JST
pylib/
* Thu 26 Sep 2013 08:42:58 AM JST
python_path="/usr/bin/python"
mirror="/root/.pylib/mirror.py"
pull_push_opt="--pull-push"

[ -x $python_path ] || exit 0
[ -x $mirror ] || exit 0

$python_path $mirror $pull_push_opt $@

exit 0

* Thu 26 Sep 2013 08:43:13 AM JST
mirror
* Thu 26 Sep 2013 08:43:19 AM JST
mirror
* Thu 26 Sep 2013 08:43:26 AM JST
pylib
* Thu 26 Sep 2013 08:43:41 AM JST

* Thu 26 Sep 2013 08:43:41 AM JST

* Thu 26 Sep 2013 08:43:41 AM JST
pull_push_opt="--pull-push"

* Thu 26 Sep 2013 08:43:47 AM JST
mirror
* Thu 26 Sep 2013 08:43:54 AM JST
mirror
* Thu 26 Sep 2013 08:53:00 AM JST
** TODO [#B] python mode make headers.

1) 背景(問題点)


2) 対応方法
   header2

3) 優先順位の根拠
   日付をつけて保存すると管理しやすくなる。
   library が増えてきたので

4) 備考

5) 結果
6) time/ref
    / cf. [[file:~/.pylib/myxlib/__init__.py::import%20Xlib][file:~/.pylib/myxlib/__init__.py::import Xlib]]
** TODO [#C] python mode, @ key call decolater list

1) 背景(問題点)

2) 対応方法
rare use @ key, almost in decolater

3) 優先順位の根拠

4) 備考

5) 結果
6) time/ref
    / cf. [[file:~/.pylib/wm/_core.py]]

* Thu 26 Sep 2013 09:14:33 AM JST
svn rm $SVNROOT/.pylib/apropos/dataholder.py -m "delete"
* Thu 26 Sep 2013 05:00:18 PM JST

* Thu 26 Sep 2013 05:00:18 PM JST

* Thu 26 Sep 2013 05:00:19 PM JST
Window Manager

* Thu 26 Sep 2013 05:06:34 PM JST
obj.
* Thu 26 Sep 2013 05:06:37 PM JST
obj.
* Thu 26 Sep 2013 05:07:24 PM JST
SUMMARY
* Thu 26 Sep 2013 05:08:02 PM JST
    def __eq__(self, other):
        r"""Compare each x, y, height, width.

        @Return: boolean
        """
        return (self.x == other.x and self.y == other.y and
                self.height == other.height and self.width == other.width)

* Thu 26 Sep 2013 05:08:59 PM JST
SUMMARY
* Thu 26 Sep 2013 05:12:49 PM JST
SUMMARY
* Thu 26 Sep 2013 05:13:05 PM JST
SUMMARY
* Thu 26 Sep 2013 05:13:40 PM JST
s 
* Thu 26 Sep 2013 05:13:41 PM JST
Window's 
* Thu 26 Sep 2013 05:14:14 PM JST
SUMMARY
* Thu 26 Sep 2013 05:30:29 PM JST
None
* Thu 26 Sep 2013 05:40:58 PM JST
if 
* Thu 26 Sep 2013 05:40:59 PM JST
:
* Thu 26 Sep 2013 05:42:37 PM JST
{'x': -translated.x,
                'y': -translated.y,
                'height': geo.height,
                'width': geo.width, }
* Thu 26 Sep 2013 05:46:45 PM JST
            
* Thu 26 Sep 2013 05:47:44 PM JST

* Thu 26 Sep 2013 05:47:44 PM JST

* Thu 26 Sep 2013 05:47:44 PM JST
        print('DEBUG-2-_core.py')

* Thu 26 Sep 2013 05:47:46 PM JST

* Thu 26 Sep 2013 05:47:46 PM JST

* Thu 26 Sep 2013 05:47:46 PM JST
            print('DEBUG-1-_core.py')

* Thu 26 Sep 2013 05:48:52 PM JST
Cache 
* Thu 26 Sep 2013 05:49:19 PM JST
from time import time as _time


class Cache(object):
    r"""
    """

    def __init__(self, duration=60):
        r"""

        Arguments:
        - `duration`:
        """
        self._duration = duration
        self._cached_time = 0
        self._cache = None

    def _set_cache(self, value):
        r"""SUMMARY

        @Return:
        """
        self._set_cached_time()
        self._cache = value

    def _get_cache(self):
        r"""SUMMARY

        @Return:
        """
        return self._cache

    def _set_cached_time(self):
        r"""SUMMARY

        @Return:
        """
        self._cached_time = _time()

    def _isneed_cache(self):
        r"""SUMMARY

        @Return:
        """
        return (self._cached_time + self._duration) < _time()


* Thu 26 Sep 2013 05:49:27 PM JST

* Thu 26 Sep 2013 05:49:27 PM JST

* Thu 26 Sep 2013 05:49:27 PM JST
from time import time as _time

* Thu 26 Sep 2013 06:03:39 PM JST
SUMMARY
* Thu 26 Sep 2013 06:06:26 PM JST
        - `data`:
* Thu 26 Sep 2013 06:06:40 PM JST
data
* Thu 26 Sep 2013 06:10:05 PM JST
SUMMAR
* Thu 26 Sep 2013 06:10:11 PM JST
Represent
* Thu 26 Sep 2013 06:11:26 PM JST
SUMMARY
* Thu 26 Sep 2013 06:11:45 PM JST

* Thu 26 Sep 2013 06:11:46 PM JST
window
* Thu 26 Sep 2013 06:11:50 PM JST
        
* Thu 26 Sep 2013 06:11:52 PM JST
display
* Thu 26 Sep 2013 06:14:18 PM JST
parsable
* Thu 26 Sep 2013 06:14:50 PM JST

* Thu 26 Sep 2013 06:14:50 PM JST

* Thu 26 Sep 2013 06:14:50 PM JST
        @Return:

* Thu 26 Sep 2013 06:15:22 PM JST
int
* Thu 26 Sep 2013 06:16:33 PM JST
    
* Thu 26 Sep 2013 06:17:20 PM JST

* Thu 26 Sep 2013 06:17:20 PM JST

* Thu 26 Sep 2013 06:17:20 PM JST
    # protocol

* Thu 26 Sep 2013 06:21:28 PM JST
                
* Thu 26 Sep 2013 06:22:25 PM JST
    
* Thu 26 Sep 2013 06:22:30 PM JST
SUMMARY
* Thu 26 Sep 2013 06:22:57 PM JST
'_NET_WM_STATE'
* Thu 26 Sep 2013 06:25:05 PM JST
SUMMARY
* Thu 26 Sep 2013 06:25:41 PM JST
command
* Thu 26 Sep 2013 06:27:42 PM JST

* Thu 26 Sep 2013 06:27:42 PM JST

* Thu 26 Sep 2013 06:27:42 PM JST
        @Return:

* Thu 26 Sep 2013 06:33:11 PM JST
createtime
* Thu 26 Sep 2013 06:34:11 PM JST
cwd
* Thu 26 Sep 2013 06:35:12 PM JST
SUMMARY
* Thu 26 Sep 2013 06:35:49 PM JST
- `display`: display object from python-xlib.
* Thu 26 Sep 2013 06:36:43 PM JST

* Thu 26 Sep 2013 06:36:43 PM JST

* Thu 26 Sep 2013 06:36:43 PM JST
        - `display`:

* Thu 26 Sep 2013 06:36:48 PM JST

* Thu 26 Sep 2013 06:36:48 PM JST

* Thu 26 Sep 2013 06:36:48 PM JST
        @Return:

* Thu 26 Sep 2013 06:37:51 PM JST
SUMMARY
* Thu 26 Sep 2013 06:38:08 PM JST
SUMMARY
* Thu 26 Sep 2013 06:38:35 PM JST
Return 
* Thu 26 Sep 2013 06:39:18 PM JST
SUMMARY
* Thu 26 Sep 2013 06:39:32 PM JST

* Thu 26 Sep 2013 06:39:32 PM JST

* Thu 26 Sep 2013 06:39:32 PM JST
        - `win`: 

* Thu 26 Sep 2013 06:39:33 PM JST

* Thu 26 Sep 2013 06:39:33 PM JST

* Thu 26 Sep 2013 06:39:34 PM JST
        @Arguments:

* Thu 26 Sep 2013 06:40:16 PM JST
string 
* Thu 26 Sep 2013 06:40:17 PM JST
empty string 
* Thu 26 Sep 2013 06:40:35 PM JST
SUMMARY
* Thu 26 Sep 2013 06:40:56 PM JST
SUMMARY
* Thu 26 Sep 2013 06:41:39 PM JST
SUMMARY
* Thu 26 Sep 2013 06:42:05 PM JST
SUMMARY
* Thu 26 Sep 2013 06:42:18 PM JST
object 
* Thu 26 Sep 2013 06:42:40 PM JST
of 
* Thu 26 Sep 2013 06:42:41 PM JST
struct of 
* Thu 26 Sep 2013 06:43:37 PM JST
SUMMARY
* Thu 26 Sep 2013 06:43:57 PM JST
SUMMARY
* Thu 26 Sep 2013 06:44:17 PM JST
SUMMARY
* Thu 26 Sep 2013 06:44:52 PM JST

* Thu 26 Sep 2013 06:44:52 PM JST

* Thu 26 Sep 2013 06:44:52 PM JST
        @Return:

* Thu 26 Sep 2013 06:45:15 PM JST
"Control c" will exit.
* Thu 26 Sep 2013 06:47:41 PM JST
SUMMARY
* Thu 26 Sep 2013 06:48:19 PM JST
above
* Thu 26 Sep 2013 06:49:20 PM JST

* Thu 26 Sep 2013 06:49:20 PM JST

* Thu 26 Sep 2013 06:49:20 PM JST
        @Return:

* Thu 26 Sep 2013 06:50:34 PM JST
SUMMARY
* Thu 26 Sep 2013 06:50:52 PM JST
SUMMARY
* Thu 26 Sep 2013 06:51:12 PM JST
active
* Thu 26 Sep 2013 06:51:36 PM JST

* Thu 26 Sep 2013 06:51:36 PM JST

* Thu 26 Sep 2013 06:51:36 PM JST
    `activate` 

* Thu 26 Sep 2013 06:51:38 PM JST
    
* Thu 26 Sep 2013 06:52:19 PM JST
    
* Thu 26 Sep 2013 09:51:25 PM JST
(popup-window)
* Thu 26 Sep 2013 09:51:47 PM JST
ac-
* Thu 26 Sep 2013 09:52:05 PM JST
(p)
* Thu 26 Sep 2013 09:56:16 PM JST
https://github.com/syohex/emacs-helm-pydoc
* Thu 26 Sep 2013 10:19:56 PM JST
noerror
* Thu 26 Sep 2013 10:21:20 PM JST
(buffer-name)
* Thu 26 Sep 2013 10:21:23 PM JST
(popwin:display-buffer (buffer-name))
* Thu 26 Sep 2013 10:22:12 PM JST
popwin:popup-buffer'
* Thu 26 Sep 2013 10:22:30 PM JST
(popwin:popup-buffer (buffer-name))
* Thu 26 Sep 2013 10:33:13 PM JST
popwin:popup-buffer
* Thu 26 Sep 2013 10:36:39 PM JST
(popwin:popup-buffer (buffer-name) :noselect nil)
* Thu 26 Sep 2013 10:40:29 PM JST
popwin:pop-to-buffer
* Thu 26 Sep 2013 10:40:38 PM JST
(buffer-name)
* Thu 26 Sep 2013 10:40:41 PM JST
(popwin:pop-to-buffer (buffer-name))
* Thu 26 Sep 2013 10:41:00 PM JST
popwin:display-buffer
* Thu 26 Sep 2013 10:41:08 PM JST
(popwin:display-buffer (buffer-name) :noselect nil)
* Thu 26 Sep 2013 10:41:17 PM JST
(popwin:display-buffer (buffer-name))
* Thu 26 Sep 2013 10:41:48 PM JST
(popwin:popup-buffer (buffer-name) :noselect nil)
* Thu 26 Sep 2013 11:20:46 PM JST
e2wm:def-plugin-files-mode-map
* Thu 26 Sep 2013 11:21:57 PM JST
[backspace]
* Thu 26 Sep 2013 11:22:21 PM JST
e2wm:def-plugin-files-mode-map
* Thu 26 Sep 2013 11:22:34 PM JST
[backspace]
* Thu 26 Sep 2013 11:22:43 PM JST
e2wm:def-plugin-files-updir-command
* Thu 26 Sep 2013 11:23:01 PM JST
e2wm:def-plugin-files-delete-command
* Thu 26 Sep 2013 11:24:31 PM JST
e2wm:def-plugin-files-mkdir-command
* Thu 26 Sep 2013 11:24:54 PM JST
e2wm:def-plugin-files-open-dired-command
* Thu 26 Sep 2013 11:26:52 PM JST
e2wm:def-plugin-files-rename-command
* Thu 26 Sep 2013 11:28:41 PM JST
e2wm:def-plugin-files-delete-command
* Thu 26 Sep 2013 11:29:31 PM JST
e2wm:def-plugin-files-open-dired-command
* Fri 27 Sep 2013 12:04:07 AM JST
(popwin:popup-buffer (buffer-name) :noselect nil)
* Fri 27 Sep 2013 12:16:18 AM JST
 (defun indirect-region (start end)
      "Edit the current region in another buffer.
    If the buffer-local variable `indirect-mode-name' is not set, prompt
    for mode name to choose for the indirect buffer interactively.
    Otherwise, use the value of said variable as argument to a funcall."
      (interactive "r")
      (let ((buffer-name (generate-new-buffer-name "*indirect*"))
            (mode
             (if (not indirect-mode-name)
                 (setq indirect-mode-name
                       (intern
                        (completing-read 
                         "Mode: "
                         (mapcar (lambda (e) 
                                   (list (symbol-name e)))
                                 (apropos-internal "-mode$" 'commandp))
                         nil t)))
               indirect-mode-name)))
        (pop-to-buffer (make-indirect-buffer (current-buffer) buffer-name))
        (funcall mode)
        (narrow-to-region start end)
        (goto-char (point-min))
        (shrink-window-if-larger-than-buffer)))
* Fri 27 Sep 2013 12:16:39 AM JST
indirect-region
* Fri 27 Sep 2013 12:17:32 AM JST
py--import-region',
* Fri 27 Sep 2013 12:17:58 AM JST
py--import-region
* Fri 27 Sep 2013 12:18:12 AM JST
#!/usr/bin/env python
# -*- coding: utf-8 -*-
r""" _core -- Abstract Cache.

$Revision$

"""

import sys as _sys
from time import time as _time

# for debug
import cgitb as _cgitb
_cgitb.enable(format='text')


__revision__ = '$Revision$'
__version__ = '0.1.0'


class Cache(object):
    r"""
    """

    def __init__(self, duration=60):
        r"""

        Arguments:
        - `duration`:
        """
        self._duration = duration
        self._cached_time = 0
        self._cache = None

    def _set_cache(self, value):
        r"""SUMMARY

        @Return:
        """
        self._set_cached_time()
        self._cache = value

    def _get_cache(self):
        r"""SUMMARY

        @Return:
        """
        return self._cache

    def _set_cached_time(self):
        r"""SUMMARY

        @Return:
        """
        self._cached_time = _time()

    def _isneed_cache(self):
        r"""SUMMARY

        @Return:
        """
        return (self._cached_time + self._duration) < _time()


def _test():
    r"""Test function."""
    return 0

if __name__ == '__main__':
    _sys.exit(_test())



# For Emacs
# Local Variables:
# coding: utf-8
# End:
# _core.py ends here

* Fri 27 Sep 2013 12:18:22 AM JST
(py--import-region)
* Fri 27 Sep 2013 12:18:32 AM JST
(py--import-region)
* Fri 27 Sep 2013 12:19:31 AM JST
(py--import-region)
* Fri 27 Sep 2013 12:20:11 AM JST
(py--import-region)
* Fri 27 Sep 2013 12:20:19 AM JST
message
* Fri 27 Sep 2013 12:20:23 AM JST
  
* Fri 27 Sep 2013 12:20:28 AM JST
(let ((region (py--import-region)))
  (princ car region)
  (princ cdr region)
  )
* Fri 27 Sep 2013 12:20:43 AM JST
(let ((region (py--import-region)))
  (princ (car region))
  (princ (cdr region))
  )
* Fri 27 Sep 2013 12:21:06 AM JST
(let ((region (py--import-region)))
  (princ (car region))
  (princ "\n")
  (princ (cdr region))
  )
* Fri 27 Sep 2013 12:21:17 AM JST
(py--import-region)
* Fri 27 Sep 2013 12:21:35 AM JST
(py--import-region)
* Fri 27 Sep 2013 12:21:46 AM JST
(setq tesregion (py--import-region))
* Fri 27 Sep 2013 12:24:13 AM JST
(let ((region (py--import-region)))
  (princ (car region))
  (princ "\n")
  (princ (cdr region))
  )
* Fri 27 Sep 2013 12:24:20 AM JST

* Fri 27 Sep 2013 12:24:20 AM JST

* Fri 27 Sep 2013 12:24:20 AM JST
    (princ (car region))

* Fri 27 Sep 2013 12:24:20 AM JST
    (princ (car region))

* Fri 27 Sep 2013 12:24:20 AM JST
    (princ (car region))
    (princ "\n")

* Fri 27 Sep 2013 12:24:20 AM JST
    (princ (car region))
    (princ "\n")

* Fri 27 Sep 2013 12:24:21 AM JST
    (princ (car region))
    (princ "\n")
    (princ (cdr region))

* Fri 27 Sep 2013 12:24:27 AM JST
  (indirect-region (py--import-region))
* Fri 27 Sep 2013 12:25:16 AM JST
(defvar indirect-mode-name nil
      "Mode to set for indirect buffers.")
    (make-variable-buffer-local 'indirect-mode-name)
* Fri 27 Sep 2013 12:25:23 AM JST
(defun pytes ()
  ""
  (interactive)
  (let ((region (py--import-region)))
    (indirect-region (car region) (cdr region))
    )
  )
* Fri 27 Sep 2013 12:32:37 AM JST
(defun indirect-region (start end)
  "Edit the current region in another buffer.
    If the buffer-local variable `indirect-mode-name' is not set, prompt
    for mode name to choose for the indirect buffer interactively.
    Otherwise, use the value of said variable as argument to a funcall."
  (interactive "r")
  (let ((buffer-name (generate-new-buffer-name "*indirect*"))
        (mode
         (if (not indirect-mode-name)
             (setq indirect-mode-name
                   (intern
                    (completing-read 
                     "Mode: "
                     (mapcar (lambda (e) 
                               (list (symbol-name e)))
                             (apropos-internal "-mode$" 'commandp))
                     nil t)))
           indirect-mode-name)))
    (pop-to-buffer (make-indirect-buffer (current-buffer) buffer-name))
    (funcall mode)
    (narrow-to-region start end)
    (goto-char (point-min))
    (shrink-window-if-larger-than-buffer)))


(defvar indirect-mode-name nil
  "Mode to set for indirect buffers.")
(make-variable-buffer-local 'indirect-mode-name)

* Fri 27 Sep 2013 12:34:02 AM JST
(defvar indirect-mode-name nil
  "Mode to set for indirect buffers.")
(make-variable-buffer-local 'indirect-mode-name)


* Fri 27 Sep 2013 12:34:26 AM JST
indirect-mode-name
* Fri 27 Sep 2013 12:36:25 AM JST
#!/usr/bin/env python
# -*- coding: utf-8 -*-
r""" _core -- Abstract Cache.

$Revision$

"""

import os
import sys as _sys
from time import time as _time

# for debug
import cgitb as _cgitb
_cgitb.enable(format='text')


__revision__ = '$Revision$'
__version__ = '0.1.0'


class Cache(object):
    r"""
    """

    def __init__(self, duration=60):
        r"""

        Arguments:
        - `duration`:
        """
        self._duration = duration
        self._cached_time = 0
        self._cache = None

    def _set_cache(self, value):
        r"""SUMMARY

        @Return:
        """
        self._set_cached_time()
        self._cache = value

    def _get_cache(self):
        r"""SUMMARY

        @Return:
        """
        return self._cache

    def _set_cached_time(self):
        r"""SUMMARY

        @Return:
        """
        self._cached_time = _time()

    def _isneed_cache(self):
        r"""SUMMARY

        @Return:
        """
        return (self._cached_time + self._duration) < _time()


def _test():
    r"""Test function."""
    return 0

if __name__ == '__main__':
    _sys.exit(_test())



# For Emacs
# Local Variables:
# coding: utf-8
# End:
# _core.py ends here

* Fri 27 Sep 2013 12:39:46 AM JST
  
* Fri 27 Sep 2013 12:39:47 AM JST
    
* Fri 27 Sep 2013 12:40:26 AM JST
                         
* Fri 27 Sep 2013 12:41:02 AM JST
forward-line'
* Fri 27 Sep 2013 12:44:29 AM JST
#!/usr/bin/env python
# -*- coding: utf-8 -*-
r""" king -- handling for king server

$Revision$

"""


__revision__ = "$Revision$"
__version__ = "0.1.0"

__all__ = [ '' ]


from getpass import getpass as _getpass
from time import sleep as _sleep
from socket import gethostbyname as _gethostbyname

import paramiko as _paramiko
import pexpect as _pexpect

from agent import AgentUtils as _AgentUtils
from rook import Rook, CHAPTERFORMAT, PRINTFORMAT
from ref.myinfo import king, kagi, kagiMD5
from mytemp.abstract import Verbose
from tunnel import Tunneling, TunnelError
from confirm import yesno


__revision__ = "$Revision$"
__version__ = "0.2.0"

__all__ = ['PRINTFORMAT', 'PasswordError', 'King']


class PasswordError(Exception):
    pass


class DecryptError(Exception):
    pass


class CMDError(Exception):
    pass

class MountError(Exception):
    pass


class _KingPave(_AgentUtils, Tunneling):
    """Pave king environment."""

    def isactive(self):
        """Check king server is running."""
        return self.router.isactive_machine(self._ip)

    def pave(self, decrypt=True, prompt=True, force=False):
        """Pave for king server.

        If not active server, try wake up.
        If not seting portforward, then try make tunneling.
        If not decrypt disk, then try get decrypted disk.

        @Return:
        """
        self.wol(force=force)
        # portforwarding
        self._pave_tunnel(force=force)
        if not decrypt:
            return
        # decrypt disk
        if not self.isdecrypt() and prompt and yesno('\rDecrypt disk? [y/n]: '):
            self._pave_disk(force=force)

    def wol(self, force=False):
        """Send Wake On Lan packet to king server."""
        if not self.isactive() or force:
            if self._verbose:
                print(CHAPTERFORMAT.format(' Wake On Lan '))
                print(PRINTFORMAT.format('Wake On Lan', 'Sending Packet...'))
            self.router.wol(self._mac, self._ip)

    def _pave_rook(self, force=False):
        """SUMMARY

        @Arguments:

        - `force`:

        @Return:
        """
        self.router.pave(force=force)

    def _pave_tunnel(self, force=False):
        """Set tunneling to ki server.

        @Arguments:

        - `force`:

        @Return:
        """
        if self.hastunnel() and not force:
            return True

        if self._verbose:
            print(CHAPTERFORMAT.format(' PortForward '))
        try:
            if self.gettunnel():
                if self._verbose:
                    print(PRINTFORMAT.format('PortForwarder', 'Launched!!'))
        except TunnelError:
            print("Can't create tunneling.")
            if yesno("\rRetry create tunneling?: "):
                if not self.gettunnel():
                    print("Can't create tunneling.")
                    raise TunnelError()
            else:
                raise TunnelError()

    def _pave_disk(self, force=False):
        """SUMMARY

        @Arguments:

        - `force`:

        @Return:
        """
        if self.ismount() and not force:
            if self._verbose:
                print(PRINTFORMAT.format('Mount', 'Already Mounted!!'))
            return True

        if self._verbose:
            print(CHAPTERFORMAT.format(' Decrypt Disk '))
            print(PRINTFORMAT.format('Check Disk', 'NOT decrypted.'))

        self.mount_data()
        if not self.ismount():
            if self._verbose:
                print(PRINTFORMAT.format('Mount', 'NOT Mounted!!'))
            return False
        if self._verbose:
            print(PRINTFORMAT.format('Mount', 'OK Mounted!!'))
        return True


class _Decrypt(object):
    """
    """
    _pexpect = None

    def ismount(self):
        """Check data disk is mounting."""
        self.pave(decrypt=False)
        return self._test_cmd('test -d /data/archive')

    def isdecrypt(self):
        """Check decrypt data disk.

        no check mounting.
        """
        self.pave(decrypt=False)
        return self._test_cmd('test -b /dev/mapper/data_crypt')

    def decrypt(self):
        """Decrypt and mount data disk.


        * sudo command has 3 type messages.
        Enter   [1] '[sudo] password for t1: '
        ReEnter [2] 'Sorry, try again.\n[sudo] password for t1: '
        Fail    [3] 'sudo: 3 incorrect password attempts'

        * cryptsetup luksOpen has 2 type messages.
        Enter   [1] 'Enter passphrase for /dev/mapper/VG-data: '
        ReEnter [2] 'No key available with this passphrase.\n
                     Enter passphrase for /dev/mapper/VG-data: '
        """
        if self.isdecrypt():
            if self._verbose:
                print(PRINTFORMAT.format('Cryptseup', 'Aleady Decrypted!!'))
            return 0
        if not self._pexpect:
            self._pexpect = _pexpect.spawn('ssh ki', maxread=4000)
            self._pexpect.expect('Last login')
            if self._verbose:
                host = '{0}@{1} ({2}) [king]'.format(self._user, self._host,
                                                     self._ip)
                print(PRINTFORMAT.format('SSH login', host))
        cmd = '/usr/bin/sudo /sbin/cryptsetup luksOpen {0} {1}'.format(
                                self._crypted_disk, self._decrypted_disk_name)
        self._pexpect.sendline(cmd)
        expect_lis = ['\[sudo\] password', '3 incorrect',
                      'Enter passphrase', '[#\$]']
        index = self._pexpect.expect(expect_lis)
        if index == 0:
            self._pexpect.sendline(
                _getpass('[sudo] password for {0}: '.format(self._user)))
        err_count = 0
        while 1:
            index = self._pexpect.expect(expect_lis)
            if 0 == index:
                self._pexpect.sendline(
                    _getpass('[sudo] password for {0}: '.format(self._user)))
            elif 1 == index:
                raise PasswordError('incorrected sudo password.')
            elif 2 == index:
                if 0 < err_count:
                    print('No key available with this passphrase.')
                err_count += 1
                self._pexpect.sendline(
                    _getpass('Enter passphrase for {0}: '.format(
                        self._crypted_disk)))
            elif 3 == index:
                if 3 == err_count and self._pexpect.exitstatus != 0:
                    raise PasswordError('incorrected cryptsetup password.')
                break

    def close_data(self):
        """SUMMARY

        @Return:
        """
        self.pave(decrypt=False)
        pass

    def mount_data(self):
        """SUMMARY

        @Return: exit status
        """
        if self.ismount():
            if self._verbose:
                print(PRINTFORMAT.format('/data', 'Already Mounted !!'))
            return True
        if not self.isdecrypt():
            try:
                self.decrypt()
            except PasswordError:
                if yesno('\rRetry it? [y/n]: '):
                    self.mount_data()
                else:
                    return False
            except DecryptError('Could not decrypt disk.'):
                return 1
        cmd = '/usr/bin/sudo /bin/mount /dev/mapper/data_crypt /data'
        self.cmd(cmd)

    def umount_data(self):
        """SUMMARY

        @Return:
        """
        pass


class _Upload(object):
    """
    """
    _sftp = None

    def upload(self, src, dst, decrypt=False):
        """Upload sfcp

        Arguments:

        - `src`:
        - `dst`:
        """
        self.pave(decrypt=True, prompt=True)
        if not self.sftp:
            self._sftp_connect()
        self.sftp.put(src, dst)

    def _sftp_connect(self):
        """Connect sftp"""
        if not self._ssh:
            self.connect()
        self._sftp = self._ssh.open_sftp()


class _KingScript(_Decrypt, _Upload):
    """
    """
    _ssh = None
    _chan = None

    def cmd(self, cmd):
        """Send command to server.

        Arguments:

        - `cmd`: command line
        """
        if not self._ssh:
            self._connect()
        chan = self._ssh.exec_command(cmd)
        if self._verbose:
            print(PRINTFORMAT.format('Sending command', cmd))
        _sleep(1)
        return chan

    def _connect(self, force=False):
        """Do connect server.

        Arguments:

        - `force`: if True, reconnect.
        """
        if force and self._ssh:
            self.close()
            self._ssh = None
        if not self._ssh:
            self._ssh = _paramiko.SSHClient()
            self._ssh.set_missing_host_key_policy(_paramiko.AutoAddPolicy())
            self._ssh.connect(self._host, self._listen_port, self._user)

    def chan_cmd(self):
        """SUMMARY

        @Arguments:

        - `cmd`:

        @Return:
        """
        if not self._ssh:
            self._connect()
        # chan = self._ssh.get_transport().open_session()
        # chan.get_pty()
        self._chan = self._ssh.invoke_shell()
        # chan.exec_command(cmd)
        # chan.send(cmd)
        # return chan

    def _test_cmd(self, cmd):
        """Send command and check exit code.

        Arguments:

        - `cmd`: command line
        """
        stdin, stdout, stderr = self.cmd(cmd)
        return 0 == stdout.channel.recv_exit_status()

    def halt(self):
        """Shutdown king server."""
        from sleep_progress import sleep_progress
        if not self.isactive():
            if self._verbose:
                print(PRINTFORMAT.format('Halting', 'Already Downed.'))
            return True
        if self._verbose:
            print(PRINTFORMAT.format('Command', 'Sending command...'))
        self._test_cmd('/usr/bin/sudo /sbin/halt')
        # wait shutdown
        if self._verbose:
            sleep_progress(10, PRINTFORMAT.format('Waiting', '%-2d seconds'))
        else:
            _sleep(10)
        for i in range(10):
            if not self.isactive():
                if self._verbose:
                    print(PRINTFORMAT.format('Halting', 'Halt OK!!'))
                break
        if 9 <= i:
            raise CMDError('Could not shutdown ki server.')
        self.router.port.close()
        if self.router.port.isopen():
            if self._verbose:
                print(PRINTFORMAT.format('Close port', 'OPEN!!'))
        return True


class _KingMain(_KingPave, _KingScript, Verbose):
    """
    """

    Router = Rook

    def __init__(self, host=king.get('host'),
                       ip = king.get('ip'),
                       user = king.get('user'),
                       listen_port = king.get('port'),
                       mac = king.get('mac'),
                       kagi = kagi,
                       kagiMD5 = kagiMD5,
                       crypted_disk = king.get('crypted_disk'),
                       decrypted_disk_name = king.get('decrypted_disk_name'),
                       verbose=False):
        """

        Arguments:
        - `host`:
        - `ip`:
        - `user`:
        - `listen_port`:
        - `mac`:
        - `kagi`:
        - `kagiMD5`:
        - `crypted_disk`:
        - `decrypted_disk_name`:
        - `verbose`:
        """
        super(_KingMain, self).__init__(verbose=verbose)
        self.router = self.Router(verbose=self._verbose)
        self._host = host
        self._ip = ip
        self._user = user
        self._listen_port = listen_port
        self._mac = mac
        self._kagi = kagi
        self._kagiMD5 = kagiMD5
        self._crypted_disk = crypted_disk
        self._decrypted_disk_name = decrypted_disk_name

    def __str__(self):
        """This returns a human-readable string that represents the state of
        the object.

        """
        dic = {'version': '{0} ({1})'.format(__version__, __revision__),
               'router': repr(self.router),
               'host': '{0} ({1})'.format(_gethostbyname(self._host), self._host),
               'ip': self._ip,
               'username': self._user,
               'listen_port': self._listen_port,
               'Mac address': self._mac,
               'SSH key': self._kagi,
               'SSH key md5': repr(self._kagiMD5),
               'ssh': repr(self._ssh),
               'ssh channel': repr(self._chan),
               'sftp': repr(self._sftp),}
        wide = len(max(dic.keys(), key=len)) + 1
        formt = '{0:<' + str(wide) + '}: {1}' # will be like this '{0:<10}: {1}'
        s = []
        s.append(repr(self))
        for key, value in dic.iteritems():
            s.append(formt.format(key, value))
        return '\n'.join(s)


class King(Verbose):
    """King server handling object."""

    KingMain = _KingMain

    def __init__(self, host=king.get('host'),
                       ip=king.get('ip'),
                       user=king.get('user'),
                       listen_port=king.get('port'),
                       mac=king.get('mac'),
                       kagi=kagi,
                       kagiMD5=kagiMD5,
                       crypted_disk=king.get('crypted_disk'),
                       decrypted_disk_name=king.get('decrypted_disk_name'),
                       verbose=False):
        """

        Arguments:
        - `host`: [string] global ip or domain name.
        - `ip`: [string] local ip address internal this server.
        - `user`: [string] user name by ssh login.
        - `listen_port`: [int] port of remote host.
        - `mac`: [string] king servers MAC address.
        - `kagi`: [string path] SSH key.
        - `kagiMD5`: [string] SSH key's MD5 by paramiko.
        - `crypted_disk`: [string path] crypted disk full path.
        - `decrypted_disk_name`: [string] after decrypted disk's name.
        - `verbose`: [bool] if True, a lot of print to stdout.
        """
        super(King, self).__init__(verbose=verbose)
        self.script = self.KingMain(host=host, ip=ip, user=user,
                                    listen_port=listen_port, mac=mac,
                                    kagi=kagi, kagiMD5=kagiMD5,
                                    crypted_disk=crypted_disk,
                                    decrypted_disk_name=decrypted_disk_name,
                                    verbose=self._verbose)


    def __str__(self):
        return self.script.__str__()

    def __del__(self):
        self.close()

    # for with statement
    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()

    def isactive(self):
        """Check king server is running."""
        return self.script.isactive()

    def isdecrypt(self):
        return self.script.isdecrypt()

    def ismount(self):
        return self.script.ismount()

    def halt(self):
        """Shutdown king server."""
        self.script.halt()

    def verbose_on(self):
        self._verbose = True
        self.script.verbose_on()
        self.router.verbose_on()

    def verbose_off(self):
        self._verbose = False
        self.script.verbose_off()
        self.router.verbose_off()

    def close(self):
        """Close connections."""
        if self.script.router:
            self.script.router.close()
        if self.script._pexpect:
            self.script._pexpect.close()
        if self.script._ssh:
            self.script._ssh.close()





# For Emacs
# Local Variables:
# coding: utf-8
# End:
# __init__.py ends here

* Fri 27 Sep 2013 12:46:02 AM JST
(defun pytes ()
  ""
  (interactive)
  (save-excursion
    (let* ((region (py--import-region))
           ;; expand region
           (start (progn (goto-char (car region))
                         (forward-line -1)
                         (point)))
           (end (progn (goto-char (cdr region))
                       (forward-line 5)
                       (point)))
           )
      (indirect-region start end)
      )))
* Fri 27 Sep 2013 12:47:26 AM JST
py-indirect-import
* Fri 27 Sep 2013 12:48:11 AM JST

* Fri 27 Sep 2013 12:53:31 AM JST

* Fri 27 Sep 2013 12:53:31 AM JST

* Fri 27 Sep 2013 12:53:32 AM JST
  (princ a)

* Fri 27 Sep 2013 12:55:26 AM JST
http://www.emacswiki.org/emacs/IndirectBuffers
* Fri 27 Sep 2013 12:59:44 AM JST

* Fri 27 Sep 2013 12:59:44 AM JST

* Fri 27 Sep 2013 12:59:44 AM JST
  ()

* Fri 27 Sep 2013 12:59:48 AM JST
unless
* Fri 27 Sep 2013 01:01:24 AM JST
(defun indirect-region (start end)
  "Edit the current region in another buffer.
START:start of region.
END:end of region.
    If the buffer-local variable `indirect-mode-name' is not set, prompt
    for mode name to choose for the indirect buffer interactively.
    Otherwise, use the value of said variable as argument to a funcall.
[2013/09/27]
copied from http://www.emacswiki.org/emacs/IndirectBuffers and modified."
  (interactive "r")
  (let ((buffer-name (generate-new-buffer-name "*indirect*"))
        (mode
         (if (not indirect-mode-name)
             (setq indirect-mode-name
                   (intern
                    (completing-read
                     "Mode: "
                     (mapcar (lambda (e)
                               (list (symbol-name e)))
                             (apropos-internal "-mode$" 'commandp))
                     nil t)))
           indirect-mode-name)))
    (pop-to-buffer (make-indirect-buffer (current-buffer) buffer-name))
    (funcall mode)
    (narrow-to-region start end)
    (goto-char (point-min))
    (shrink-window-if-larger-than-buffer)))
* Fri 27 Sep 2013 01:02:21 AM JST
2013/09/27
copied from http://www.emacswiki.org/emacs/IndirectBuffers and modified.
* Fri 27 Sep 2013 01:05:17 AM JST
nil
* Fri 27 Sep 2013 01:06:19 AM JST
(current-buffer)
* Fri 27 Sep 2013 01:06:50 AM JST
(buffer-file-name)
* Fri 27 Sep 2013 01:08:21 AM JST
(current-buffer)
* Fri 27 Sep 2013 01:09:29 AM JST
(current-buffer)
* Fri 27 Sep 2013 01:12:04 AM JST
princ
* Fri 27 Sep 2013 01:12:47 AM JST
(buffer-name)
* Fri 27 Sep 2013 01:14:41 AM JST
(defun indirect-region (start end &optional buffname)
  "Edit the current region in another buffer.
START:start of region.
END:end of region.
    If the buffer-local variable `indirect-mode-name' is not set, prompt
    for mode name to choose for the indirect buffer interactively.
    Otherwise, use the value of said variable as argument to a funcall."
  (interactive "r")
  (if buffname
      (setq buffname (concat " " buffname))
    (setq buffname ""))
  (let ((buffer-name (generate-new-buffer-name (concat "*indirect" buffname "*")))
        (mode
         (if (not indirect-mode-name)
             (setq indirect-mode-name
                   (intern
                    (completing-read
                     "Mode: "
                     (mapcar (lambda (e)
                               (list (symbol-name e)))
                             (apropos-internal "-mode$" 'commandp))
                     nil t)))
           indirect-mode-name)))
    (pop-to-buffer (make-indirect-buffer (current-buffer) buffer-name))
    (funcall mode)
    (narrow-to-region start end)
    (goto-char (point-min))
    (shrink-window-if-larger-than-buffer)))
* Fri 27 Sep 2013 01:15:54 AM JST
(indirect-region start end (buffer-name))
* Fri 27 Sep 2013 01:52:01 AM JST
SUMMARY
* Fri 27 Sep 2013 01:52:23 AM JST
args
* Fri 27 Sep 2013 01:52:30 AM JST
        
* Fri 27 Sep 2013 01:52:34 AM JST
        
* Fri 27 Sep 2013 01:52:39 AM JST
        
* Fri 27 Sep 2013 01:52:40 AM JST
height
* Fri 27 Sep 2013 01:59:34 AM JST
Geometry(window=self._window, display=self._display)
* Fri 27 Sep 2013 01:59:50 AM JST
self.geo
* Fri 27 Sep 2013 02:09:02 AM JST
    
* Fri 27 Sep 2013 02:09:10 AM JST
SUMMARY
* Fri 27 Sep 2013 02:23:39 AM JST
SUMMARY
* Fri 27 Sep 2013 02:23:51 AM JST

* Fri 27 Sep 2013 02:23:51 AM JST

* Fri 27 Sep 2013 02:23:51 AM JST
        @Return:

* Fri 27 Sep 2013 02:24:57 AM JST
SUMMARY
* Fri 27 Sep 2013 02:25:58 AM JST
boolean
* Fri 27 Sep 2013 02:26:35 AM JST
and 
* Fri 27 Sep 2013 02:28:06 AM JST
SUMMARY
* Fri 27 Sep 2013 02:30:41 AM JST
SUMMARY
* Fri 27 Sep 2013 02:32:00 AM JST

* Fri 27 Sep 2013 02:32:00 AM JST

* Fri 27 Sep 2013 02:32:00 AM JST
        @Return: 

* Fri 27 Sep 2013 02:33:13 AM JST
    
* Fri 27 Sep 2013 02:34:06 AM JST
SUMMARY
* Fri 27 Sep 2013 02:35:55 AM JST
        r"""Handling maximize window.

        @Arguments:

        - `mode`:
        0 == remove
        1 == add
        2 == toggle

* Fri 27 Sep 2013 02:36:18 AM JST
maximize
* Fri 27 Sep 2013 02:36:59 AM JST
SUMMARY
* Fri 27 Sep 2013 02:37:21 AM JST
boolean as True if success.
* Fri 27 Sep 2013 02:38:29 AM JST
SUMMARY
* Fri 27 Sep 2013 02:39:56 AM JST
SUMMARY
* Fri 27 Sep 2013 02:40:06 AM JST

* Fri 27 Sep 2013 02:40:06 AM JST

* Fri 27 Sep 2013 02:40:06 AM JST
        @Return:

* Fri 27 Sep 2013 02:40:07 AM JST
        
* Fri 27 Sep 2013 02:40:22 AM JST
    
* Fri 27 Sep 2013 02:40:40 AM JST
class _WMFullscreen(_WMState):
    r"""Handling fullscreen window."""

    def isfullscreen(self):
        r"""Check window is fullscreen.

        @Return: boolean
        """
        try:
            props = self._get_state()
            if self._STATE_FULLSCREEN in props:
                return True
            return False
        except AttributeError:
            return False

    def _fullscreen(self, mode):
        r"""Handling fullscreen window.

        @Arguments:

        - `mode`:
        0 == remove
        1 == add
        2 == toggle
        """
        self._state_cmd(data=[mode, self._STATE_FULLSCREEN, 0, 0, 0])

    def reset_fullscreen(self):
        r"""Reset fullscreen window.

        @Return: boolean as True if success.
        """
        self._fullscreen(mode=self._MODE_UNSET)
        return not self.isfullscreen()

    def fullscreen(self):
        r"""Set fullscreen window.

        @Return: boolean as True if success.
        """
        self._fullscreen(mode=self._MODE_SET)
        return self.isfullscreen()

    def toggle_fullscreen(self):
        r"""Toggle fullscreen window."""
        self._fullscreen(mode=self._MODE_TOGGLE)

* Fri 27 Sep 2013 02:41:11 AM JST
SUMMARY
* Fri 27 Sep 2013 02:41:29 AM JST
SUMMARY
* Fri 27 Sep 2013 02:41:47 AM JST

* Fri 27 Sep 2013 02:41:48 AM JST

* Fri 27 Sep 2013 02:41:48 AM JST
        """

* Fri 27 Sep 2013 02:41:49 AM JST

* Fri 27 Sep 2013 02:41:49 AM JST

* Fri 27 Sep 2013 02:41:49 AM JST
        @Return:

* Fri 27 Sep 2013 02:41:53 AM JST
        - `mode`:
        0 == remove
        1 == add
        2 == toggle

* Fri 27 Sep 2013 02:43:21 AM JST
SUMMARY
* Fri 27 Sep 2013 02:44:27 AM JST
SUMMARY
* Fri 27 Sep 2013 02:45:15 AM JST
SUMMARY
* Fri 27 Sep 2013 02:45:23 AM JST

* Fri 27 Sep 2013 02:45:23 AM JST

* Fri 27 Sep 2013 02:45:23 AM JST
        @Return:

* Fri 27 Sep 2013 02:45:24 AM JST
        
* Fri 27 Sep 2013 02:46:49 AM JST
    
* Fri 27 Sep 2013 02:46:52 AM JST
SUMMARY
* Fri 27 Sep 2013 02:47:24 AM JST
SUMMARY
* Fri 27 Sep 2013 02:47:41 AM JST
        0 == remove
        1 == add
        2 == toggle

* Fri 27 Sep 2013 02:47:44 AM JST

* Fri 27 Sep 2013 02:47:44 AM JST

* Fri 27 Sep 2013 02:47:44 AM JST
        @Return:

* Fri 27 Sep 2013 02:47:55 AM JST
SUMMARY
* Fri 27 Sep 2013 02:48:56 AM JST
SUMMARY
* Fri 27 Sep 2013 02:49:39 AM JST
SUMMARY
* Fri 27 Sep 2013 02:49:50 AM JST

* Fri 27 Sep 2013 02:49:50 AM JST

* Fri 27 Sep 2013 02:49:50 AM JST
        @Return:

* Fri 27 Sep 2013 02:49:52 AM JST
        
* Fri 27 Sep 2013 02:50:32 AM JST
    
* Fri 27 Sep 2013 02:50:35 AM JST
SUMMARY
* Fri 27 Sep 2013 02:51:26 AM JST
SUMMARY
* Fri 27 Sep 2013 02:51:47 AM JST
        0 == remove
        1 == add
        2 == toggle

* Fri 27 Sep 2013 02:51:58 AM JST

* Fri 27 Sep 2013 02:51:58 AM JST

* Fri 27 Sep 2013 02:51:58 AM JST
        @Return:

* Fri 27 Sep 2013 02:52:06 AM JST
SUMMARY
* Fri 27 Sep 2013 02:52:55 AM JST
SUMMARY
* Fri 27 Sep 2013 02:53:51 AM JST
SUMMARY
* Fri 27 Sep 2013 02:53:59 AM JST

* Fri 27 Sep 2013 02:54:00 AM JST

* Fri 27 Sep 2013 02:54:00 AM JST
        @Return:

* Fri 27 Sep 2013 02:54:01 AM JST
        
* Fri 27 Sep 2013 02:54:53 AM JST
    
* Fri 27 Sep 2013 02:55:23 AM JST

* Fri 27 Sep 2013 02:55:23 AM JST

* Fri 27 Sep 2013 02:55:23 AM JST
        @Arguments:

* Fri 27 Sep 2013 02:55:25 AM JST

* Fri 27 Sep 2013 02:55:26 AM JST

* Fri 27 Sep 2013 02:55:26 AM JST
        @Return:

* Fri 27 Sep 2013 02:55:27 AM JST
        
* Fri 27 Sep 2013 02:55:35 AM JST

* Fri 27 Sep 2013 02:55:35 AM JST

* Fri 27 Sep 2013 02:55:36 AM JST
        @Arguments:

* Fri 27 Sep 2013 02:55:36 AM JST

* Fri 27 Sep 2013 02:55:36 AM JST

* Fri 27 Sep 2013 02:55:37 AM JST
        @Return:

* Fri 27 Sep 2013 02:55:38 AM JST
        
* Fri 27 Sep 2013 02:56:17 AM JST
        try:
            props = self._get_state()
            if self._STATE_BELOW in props:
                return True
            return False
        except AttributeError:
            return False

* Fri 27 Sep 2013 02:58:15 AM JST
self._get_state()
* Fri 27 Sep 2013 02:58:22 AM JST

* Fri 27 Sep 2013 02:58:22 AM JST

* Fri 27 Sep 2013 02:58:22 AM JST
            props = self._get_state()

* Fri 27 Sep 2013 02:58:41 AM JST
    def _isinstate(self, atom):
        r"""SUMMARY
        
        @Arguments:
        
        - `atom`:
        
        @Return:
        """
        try:
            if atom in self._get_state():
                return True
            return False
        except AttributeError:
            return False


* Fri 27 Sep 2013 02:58:58 AM JST
SUMMARY
* Fri 27 Sep 2013 02:59:46 AM JST
it
* Fri 27 Sep 2013 03:06:24 AM JST
self._STATE_SHADED
* Fri 27 Sep 2013 03:06:53 AM JST
self._STATE_ABOVE
* Fri 27 Sep 2013 03:07:20 AM JST
self._STATE_BELOW
* Fri 27 Sep 2013 03:16:14 AM JST

* Fri 27 Sep 2013 03:16:14 AM JST

* Fri 27 Sep 2013 03:16:14 AM JST
        self._id = id_

* Fri 27 Sep 2013 03:20:50 AM JST
class _WMState(_AtomHolder):
    r"""State command Abstract."""

    def _get_state(self):
        r"""Get '_NET_WM_STATE' property of window.

        @Return: list of long interger.
        """
        return self._window.get_full_property(self._WM_STATE, 0).value.tolist()

    def _isinstate(self, atom):
        r"""Check if in state property in window.

        @Arguments:

        - `atom`: display.intern_atom()

        @Return: boolean
        """
        try:
            if atom in self._get_state():
                return True
            return False
        except AttributeError:
            return False

    def _state_cmd(self, data):
        r"""Send state event.

        @Arguments:

        - `data`: state value
        """
        assert data[0] in [0, 1, 2]
        event = _ClientMessage(window=self._window, client_type=self._WM_STATE,
                               data=(32, (data)))
        self._send_event(
            event, event_mask=_X.SubstructureRedirectMask, sender='root')



* Fri 27 Sep 2013 03:27:24 AM JST
        _WMInfo.__init__(self, display=self._display)
* Fri 27 Sep 2013 03:32:08 AM JST

* Fri 27 Sep 2013 03:32:08 AM JST

* Fri 27 Sep 2013 03:32:08 AM JST
        _WMInfo.__init__(self, display=display)

* Fri 27 Sep 2013 03:32:33 AM JST
    def __eq__(self, other):
        r"""SUMMARY

        @Arguments:

        - `other`:

        @Return:
        """
        return self.id == other.id

    def __ne__(self, other):
        r"""SUMMARY

        @Arguments:

        - `other`:

        @Return:
        """
        return not self.id == other.id


* Fri 27 Sep 2013 03:32:57 AM JST
    def resetall(self):
        r"""SUMMARY

        @Return:
        """
        self.reset_maximize()
        self.reset_fullscreen()
        self.reset_shade()
        self.reset_above()
        self.reset_below()
        # TODO: (Atami) [2013/09/24]
        # self.reset_hide() # not implementated


* Fri 27 Sep 2013 03:34:16 AM JST
    def _send_event(self, event, event_mask=0, propagate=0,
                    onerror=None, sender='root'):
        r"""SUMMARY

        @Arguments:

        - `event`:
        - `event_mask`:
        - `propagate`:

        @Return:
        """
        if 'root' == sender:
            self._root.send_event(
                event, event_mask=event_mask, propagate=propagate)
        elif 'window' == sender:
            self._window.send_event(
                event, event_mask=event_mask, propagate=propagate)
        self._sync()


* Fri 27 Sep 2013 03:36:29 AM JST

    def _hide(self):
        r"""SUMMARY

        @Return:
        """
        # TODO: (Atami) [2013/09/23]
        # not implemented
        pass

* Fri 27 Sep 2013 03:40:37 AM JST
SUMMARY
* Fri 27 Sep 2013 03:41:11 AM JST
SUMMARY
* Fri 27 Sep 2013 03:41:22 AM JST

* Fri 27 Sep 2013 03:41:22 AM JST

* Fri 27 Sep 2013 03:41:22 AM JST
        @Arguments:

* Fri 27 Sep 2013 03:41:23 AM JST

* Fri 27 Sep 2013 03:41:24 AM JST

* Fri 27 Sep 2013 03:41:24 AM JST
        - `other`:

* Fri 27 Sep 2013 03:45:46 AM JST
SUMMARY
* Fri 27 Sep 2013 03:46:17 AM JST
Client
* Fri 27 Sep 2013 03:47:18 AM JST

* Fri 27 Sep 2013 03:47:18 AM JST

* Fri 27 Sep 2013 03:47:18 AM JST
        @Return:

* Fri 27 Sep 2013 03:48:21 AM JST
window
* Fri 27 Sep 2013 03:51:49 AM JST
    X.BadRequest: BadRequest,
    X.BadValue: BadValue,
    X.BadWindow: BadWindow,
    X.BadPixmap: BadPixmap,
    X.BadAtom: BadAtom,
    X.BadCursor: BadCursor,
    X.BadFont: BadFont,
    X.BadMatch: BadMatch,
    X.BadDrawable: BadDrawable,
    X.BadAccess: BadAccess,
    X.BadAlloc: BadAlloc,
    X.BadColor: BadColor,
    X.BadGC: BadGC,
    X.BadIDChoice: BadIDChoice,
    X.BadName: BadName,
    X.BadLength: BadLength,
    X.BadImplementation: BadImplementation,

* Fri 27 Sep 2013 03:54:13 AM JST
'error'
* Fri 27 Sep 2013 03:57:43 AM JST
active
* Fri 27 Sep 2013 03:57:43 AM JST
Get active
* Fri 27 Sep 2013 03:57:54 AM JST
    
* Fri 27 Sep 2013 03:57:58 AM JST
SUMMARY
* Fri 27 Sep 2013 03:58:06 AM JST
window
* Fri 27 Sep 2013 03:58:06 AM JST
active window
* Fri 27 Sep 2013 03:58:06 AM JST
Get active window
* Fri 27 Sep 2013 03:58:32 AM JST

* Fri 27 Sep 2013 03:58:32 AM JST

* Fri 27 Sep 2013 03:58:32 AM JST
        @Return:

* Fri 27 Sep 2013 03:58:44 AM JST

* Fri 27 Sep 2013 03:58:44 AM JST

* Fri 27 Sep 2013 03:58:44 AM JST
        # WindowManager.__init__(self, id_=win.id, display=display)

* Fri 27 Sep 2013 04:02:24 AM JST
r
* Fri 27 Sep 2013 04:02:25 AM JST
Flushing r
* Fri 27 Sep 2013 04:03:52 AM JST

* Fri 27 Sep 2013 04:03:52 AM JST

* Fri 27 Sep 2013 04:03:52 AM JST
from Xlib import error

* Fri 27 Sep 2013 04:04:54 AM JST
SUMMARY
* Fri 27 Sep 2013 04:05:23 AM JST
win
* Fri 27 Sep 2013 04:05:35 AM JST

* Fri 27 Sep 2013 04:05:35 AM JST

* Fri 27 Sep 2013 04:05:35 AM JST
    @Return:

* Fri 27 Sep 2013 04:05:52 AM JST
Press "Control c" will exit.
* Fri 27 Sep 2013 04:31:19 AM JST
cmdline
* Fri 27 Sep 2013 04:32:25 AM JST
createtime
* Fri 27 Sep 2013 04:32:48 AM JST
time 
* Fri 27 Sep 2013 04:33:38 AM JST
io
* Fri 27 Sep 2013 04:34:24 AM JST
openfiles
* Fri 27 Sep 2013 04:35:04 AM JST
open
* Fri 27 Sep 2013 04:37:47 AM JST
current
* Fri 27 Sep 2013 04:39:39 AM JST
    
* Fri 27 Sep 2013 04:40:24 AM JST
    
* Fri 27 Sep 2013 04:40:26 AM JST
height
* Fri 27 Sep 2013 04:40:30 AM JST
vertical
* Fri 27 Sep 2013 04:42:47 AM JST
    def isactive(self):
        r"""Check window is active.

        @Return: boolean
        """
        activewin = ActiveWindow(display=self._display)
        try:
            return self.id == activewin.id
        except AttributeError:
            return False


* Fri 27 Sep 2013 04:42:55 AM JST
Check window is active.
* Fri 27 Sep 2013 04:47:23 AM JST
is 
* Fri 27 Sep 2013 04:47:26 AM JST
is 
* Fri 27 Sep 2013 04:48:56 AM JST
class _WMMaximize / class _WMMaximize
class _WMMaximize / ismaximize
class _WMMaximize / _maximize
class _WMMaximize / reset_maximize
class _WMMaximize / maximize
class _WMMaximize / toggle_maximize
class _WMMinimize / class _WMMinimize
class _WMMinimize / isminimize
class _WMMinimize / minimize
class _WMMinimize / minimizeall
class _WMMinimize / reset_minimize_all
class _WMFullscreen / class _WMFullscreen
class _WMFullscreen / isfullscreen
class _WMFullscreen / _fullscreen
class _WMFullscreen / reset_fullscreen
class _WMFullscreen / fullscreen
class _WMFullscreen / toggle_fullscreen
class _WMShade / class _WMShade
class _WMShade / isshade
class _WMShade / _shade
class _WMShade / reset_shade
class _WMShade / shade
class _WMShade / toggle_shade
class _WMAbove / class _WMAbove
class _WMAbove / isabove
class _WMAbove / _above
class _WMAbove / reset_above
class _WMAbove / above
class _WMAbove / toggle_above
class _WMBelow / class _WMBelow
class _WMBelow / isbelow
class _WMBelow / _below
class _WMBelow / reset_below
class _WMBelow / below
class _WMBelow / toggle_below
class _WMHide / class _WMHide
class _WMHide / ishide
class _WMHide / _hide
class _WMHide / hide
class _WMHide / toggle_hide
class _WMDestroy / class _WMDestroy
class _WMDestroy / kill
class _WMDestroy / close

* Fri 27 Sep 2013 04:52:34 AM JST
activate this window
* Fri 27 Sep 2013 04:52:39 AM JST
 that reset .
* Fri 27 Sep 2013 04:53:11 AM JST
 command
* Fri 27 Sep 2013 04:55:45 AM JST
    Maximize Window:
    - `ismaximize`: boolean what is maximizing this window now.
    - `reset_maximize`: boolean what is success command that reset maximize this window.
    - `maximize`: boolean what is success command that set maximize this window.
    - `toggle_maximize` unbound, toggle maximize or reset maximize.

* Fri 27 Sep 2013 04:56:08 AM JST
Fullscre
* Fri 27 Sep 2013 04:56:52 AM JST
maximizing
* Fri 27 Sep 2013 04:58:07 AM JST
    Maximize Window:
    - `ismaximize`: boolean what is maximizing this window now.
    - `reset_maximize`: boolean what is success command that reset maximize this window.
    - `maximize`: boolean what is success command that set maximize this window.
    - `toggle_maximize` unbound, toggle maximize or reset maximize.

    Fullscreen Window:
    - `isfullscreen`: boolean what is fullscreening this window now.
    - `reset_fullscreen`: boolean what is success command that reset fullscreen this window.
    - `fullscreen`: boolean what is success command that set fullscreen this window.
    - `toggle_fullscreen` unbound, toggle fullscreen or reset fullscreen.

* Fri 27 Sep 2013 04:58:13 AM JST
Maximize
* Fri 27 Sep 2013 04:58:36 AM JST
maximiz
* Fri 27 Sep 2013 04:58:49 AM JST
    Shade Window:
    - `isshade`: boolean what is shading this window now.
    - `reset_shade`: boolean what is success command that reset shade this window.
    - `shade`: boolean what is success command that set shade this window.
    - `toggle_shade` unbound, toggle shade or reset shade.

* Fri 27 Sep 2013 04:59:00 AM JST
Shade
* Fri 27 Sep 2013 04:59:35 AM JST
    Above Window:
    - `isabove`: boolean what is aboving this window now.
    - `reset_above`: boolean what is success command that reset above this window.
    - `above`: boolean what is success command that set above this window.
    - `toggle_above` unbound, toggle above or reset above.

* Fri 27 Sep 2013 04:59:38 AM JST
Above
* Fri 27 Sep 2013 05:00:02 AM JST
abov
* Fri 27 Sep 2013 05:00:11 AM JST
    Below Window:
    - `isbelow`: boolean what is belowing this window now.
    - `reset_below`: boolean what is success command that reset below this window.
    - `below`: boolean what is success command that set below this window.
    - `toggle_below` unbound, toggle below or reset below.

* Fri 27 Sep 2013 05:02:09 AM JST
geo
* Fri 27 Sep 2013 06:01:24 AM JST

* Fri 27 Sep 2013 06:01:24 AM JST
def tes(a='hello', 
* Fri 27 Sep 2013 06:01:24 AM JST
def tes(a='hello', 
* Fri 27 Sep 2013 06:01:24 AM JST
def tes(a='hello', 
* Fri 27 Sep 2013 06:01:24 AM JST
def tes(a='hello', 
* Fri 27 Sep 2013 06:01:24 AM JST
def tes(a='hello', 
* Fri 27 Sep 2013 12:56:05 PM JST
def confirm(win, title=None, klass=None, wid=None, pid=None, regexp=None,
            determine=_determine):
    r"""SUMMARY

    @Arguments:

    - `win`:
    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    if win is None:
        return False
    # title or klass or pid or regexp
    if ((wid is not None and wid == win.id) or
        (title is not None and title == win.title) or
        (klass is not None and klass == win.klass[1]) or
        (pid is not None and pid == win.pid) or
        (regexp is not None and
         (_re.search(regexp, win.title) is not None)) or
        (determine(win) is True)):
        return True
    return False

* Fri 27 Sep 2013 12:56:23 PM JST
_determine
* Fri 27 Sep 2013 12:56:23 PM JST
determine=_determine
* Fri 27 Sep 2013 12:56:26 PM JST
None,
* Fri 27 Sep 2013 12:56:27 PM JST
regexp=None,
* Fri 27 Sep 2013 12:56:27 PM JST
None, regexp=None,
* Fri 27 Sep 2013 12:56:27 PM JST
pid=None, regexp=None,
* Fri 27 Sep 2013 12:56:27 PM JST
None, pid=None, regexp=None,
* Fri 27 Sep 2013 12:56:28 PM JST
wid=None, pid=None, regexp=None,
* Fri 27 Sep 2013 12:56:28 PM JST
None, wid=None, pid=None, regexp=None,
* Fri 27 Sep 2013 12:56:28 PM JST
klass=None, wid=None, pid=None, regexp=None,
* Fri 27 Sep 2013 12:56:29 PM JST
None, klass=None, wid=None, pid=None, regexp=None,
* Fri 27 Sep 2013 01:00:59 PM JST
        
* Fri 27 Sep 2013 01:02:18 PM JST
determine
* Fri 27 Sep 2013 01:02:49 PM JST
                    
* Fri 27 Sep 2013 01:04:50 PM JST
determine
* Fri 27 Sep 2013 01:04:56 PM JST
_determine
* Fri 27 Sep 2013 01:05:49 PM JST
           
* Fri 27 Sep 2013 01:06:09 PM JST
_determine
* Fri 27 Sep 2013 01:06:59 PM JST
 args
* Fri 27 Sep 2013 01:08:25 PM JST
            
* Fri 27 Sep 2013 01:09:35 PM JST
set 
* Fri 27 Sep 2013 01:16:53 PM JST
args, 
* Fri 27 Sep 2013 01:17:39 PM JST
window, 
* Fri 27 Sep 2013 01:23:20 PM JST
win, 
* Fri 27 Sep 2013 01:23:21 PM JST
window=win, 
* Fri 27 Sep 2013 01:25:30 PM JST
print()
* Fri 27 Sep 2013 01:28:09 PM JST
args=
* Fri 27 Sep 2013 01:29:42 PM JST
_win
* Fri 27 Sep 2013 01:33:18 PM JST
    # prevent
    if not (args.get('title') or args.get('klass') or
            args.get('wid') or args.get('pid') or
            args.get('regexp') or confirm.func_name != '_confirm'):
        msg = 'Must assign to title, klass, pid or regexp or confirm function.'
        raise ValueError(msg)


* Fri 27 Sep 2013 01:33:27 PM JST
_confirm'
* Fri 27 Sep 2013 01:33:28 PM JST
func_name != '_confirm'
* Fri 27 Sep 2013 01:33:28 PM JST
confirm.func_name != '_confirm'
* Fri 27 Sep 2013 01:33:35 PM JST
            
* Fri 27 Sep 2013 01:33:40 PM JST
function
* Fri 27 Sep 2013 01:33:40 PM JST
confirm function
* Fri 27 Sep 2013 01:35:03 PM JST
         
* Fri 27 Sep 2013 01:35:05 PM JST
        
* Fri 27 Sep 2013 01:35:07 PM JST
         
* Fri 27 Sep 2013 01:35:09 PM JST
         
* Fri 27 Sep 2013 01:36:00 PM JST
           
* Fri 27 Sep 2013 01:36:03 PM JST
determine
* Fri 27 Sep 2013 01:36:07 PM JST
_determine
* Fri 27 Sep 2013 01:36:23 PM JST
              
* Fri 27 Sep 2013 01:36:24 PM JST
regexp,
* Fri 27 Sep 2013 01:36:24 PM JST
regexp=regexp,
* Fri 27 Sep 2013 01:36:24 PM JST
pid, regexp=regexp,
* Fri 27 Sep 2013 01:36:25 PM JST
pid=pid, regexp=regexp,
* Fri 27 Sep 2013 01:36:25 PM JST
wid, pid=pid, regexp=regexp,
* Fri 27 Sep 2013 01:36:25 PM JST
wid=wid, pid=pid, regexp=regexp,
* Fri 27 Sep 2013 01:36:25 PM JST
klass, wid=wid, pid=pid, regexp=regexp,
* Fri 27 Sep 2013 01:36:25 PM JST
klass=klass, wid=wid, pid=pid, regexp=regexp,
* Fri 27 Sep 2013 01:36:26 PM JST
title, klass=klass, wid=wid, pid=pid, regexp=regexp,
* Fri 27 Sep 2013 01:36:26 PM JST
title=title, klass=klass, wid=wid, pid=pid, regexp=regexp,
* Fri 27 Sep 2013 01:36:30 PM JST
determine
* Fri 27 Sep 2013 01:36:37 PM JST
determine
* Fri 27 Sep 2013 01:39:43 PM JST

* Fri 27 Sep 2013 01:39:43 PM JST

* Fri 27 Sep 2013 01:39:44 PM JST
        if win is None:

* Fri 27 Sep 2013 01:39:44 PM JST
        if win is None:

* Fri 27 Sep 2013 01:39:44 PM JST
        if win is None:
            continue

* Fri 27 Sep 2013 01:42:20 PM JST
            
* Fri 27 Sep 2013 01:42:23 PM JST
determine
* Fri 27 Sep 2013 01:42:27 PM JST
_determine
* Fri 27 Sep 2013 01:42:49 PM JST
determine
* Fri 27 Sep 2013 01:42:49 PM JST
determine=determine
* Fri 27 Sep 2013 01:42:50 PM JST
regexp,
* Fri 27 Sep 2013 01:42:50 PM JST
regexp=regexp,
* Fri 27 Sep 2013 01:42:50 PM JST
pid, regexp=regexp,
* Fri 27 Sep 2013 01:42:51 PM JST
pid=pid, regexp=regexp,
* Fri 27 Sep 2013 01:42:51 PM JST
wid, pid=pid, regexp=regexp,
* Fri 27 Sep 2013 01:42:51 PM JST
wid=wid, pid=pid, regexp=regexp,
* Fri 27 Sep 2013 01:42:52 PM JST
klass, wid=wid, pid=pid, regexp=regexp,
* Fri 27 Sep 2013 01:42:52 PM JST
klass=klass, wid=wid, pid=pid, regexp=regexp,
* Fri 27 Sep 2013 01:42:52 PM JST
title, klass=klass, wid=wid, pid=pid, regexp=regexp,
* Fri 27 Sep 2013 01:42:53 PM JST
title=title, klass=klass, wid=wid, pid=pid, regexp=regexp,
* Fri 27 Sep 2013 01:43:38 PM JST
sec=0, confirm=_confirm, **args
* Fri 27 Sep 2013 01:43:55 PM JST
confirm=confirm, **args
* Fri 27 Sep 2013 01:44:13 PM JST
sec=0, confirm=_confirm, **args
* Fri 27 Sep 2013 01:44:47 PM JST
0, 
* Fri 27 Sep 2013 01:44:47 PM JST
_determinesec=0, 
* Fri 27 Sep 2013 01:44:47 PM JST
determine=_determinesec=0, 
* Fri 27 Sep 2013 01:44:48 PM JST
None,
* Fri 27 Sep 2013 01:44:48 PM JST
regexp=None,
* Fri 27 Sep 2013 01:44:48 PM JST
None, regexp=None,
* Fri 27 Sep 2013 01:44:49 PM JST
pid=None, regexp=None,
* Fri 27 Sep 2013 01:44:49 PM JST
None, pid=None, regexp=None,
* Fri 27 Sep 2013 01:44:49 PM JST
wid=None, pid=None, regexp=None,
* Fri 27 Sep 2013 01:44:49 PM JST
None, wid=None, pid=None, regexp=None,
* Fri 27 Sep 2013 01:44:50 PM JST
klass=None, wid=None, pid=None, regexp=None,
* Fri 27 Sep 2013 01:44:50 PM JST
None, klass=None, wid=None, pid=None, regexp=None,
* Fri 27 Sep 2013 01:44:51 PM JST
title=None, klass=None, wid=None, pid=None, regexp=None,
* Fri 27 Sep 2013 01:45:03 PM JST
confirm=confirm, **args
* Fri 27 Sep 2013 01:55:22 PM JST
['os', 'sys', 're', 'pprint', 'dis',
                   'types', 'time', 'subprocess as sbp', 'inspect']
* Fri 27 Sep 2013 01:55:24 PM JST
                   
* Fri 27 Sep 2013 01:56:37 PM JST
['os', 'sys', 're', 'pprint', 'dis', 'types', 'time',
            'subprocess as sbp', 'inspect']
* Fri 27 Sep 2013 01:56:43 PM JST
            
* Fri 27 Sep 2013 01:56:55 PM JST

* Fri 27 Sep 2013 01:56:55 PM JST

* Fri 27 Sep 2013 01:56:55 PM JST
imported = 

* Fri 27 Sep 2013 01:58:38 PM JST

* Fri 27 Sep 2013 01:58:38 PM JST

* Fri 27 Sep 2013 01:58:38 PM JST
from pprint import pprint

* Fri 27 Sep 2013 02:02:39 PM JST
determine
* Fri 27 Sep 2013 02:02:42 PM JST
determine
* Fri 27 Sep 2013 02:25:40 PM JST
def getpid(win):
    r"""SUMMARY

    @Arguments:
    - `win`:

    @Return:
    """
    display = _XDisplay()
    pid_reply = win.get_property(display.intern_atom('_NET_WM_PID'),
                                 _X.AnyPropertyType, 0, 10)
    return int(pid_reply.value.tolist()[0])



* Fri 27 Sep 2013 02:25:46 PM JST
def getpid(win):
    r"""SUMMARY

    @Arguments:
    - `win`:

    @Return:
    """
    display = _XDisplay()
    pid_reply = win.get_property(display.intern_atom('_NET_WM_PID'),
                                 _X.AnyPropertyType, 0, 10)
    return int(pid_reply.value.tolist()[0])



* Fri 27 Sep 2013 02:32:47 PM JST
def listid():
    r"""SUMMARY

    @Return:
    """
    display = _XDisplay()
    root = display.screen().root
    return (root.get_full_property(
        display.intern_atom('_NET_CLIENT_LIST'), _X.AnyPropertyType).value)


def listname():
    r"""SUMMARY

    @Return:
    """
    names = []
    for win in iter_wins():
        if win is not None:
            names.append(win.title)
    return names


def listclass():
    r"""SUMMARY

    @Return:
    """
    classes = []
    for win in iter_wins():
        if win is not None:
            classes.append(win.info().klass)
    return classes


* Fri 27 Sep 2013 02:33:07 PM JST

def iter_wins():
    r"""Generator

    @Return:
    """
    for id_ in listid():
        yield WindowManager(id_)


* Fri 27 Sep 2013 02:47:28 PM JST

* Fri 27 Sep 2013 02:47:28 PM JST

* Fri 27 Sep 2013 02:47:28 PM JST
getattr(OBJECT, NAME)

* Fri 27 Sep 2013 02:47:59 PM JST
    for win in iter_wins():
        yield win.title

* Fri 27 Sep 2013 02:48:04 PM JST
title
* Fri 27 Sep 2013 02:48:05 PM JST
win.title
* Fri 27 Sep 2013 02:50:19 PM JST
info()
* Fri 27 Sep 2013 02:50:28 PM JST

* Fri 27 Sep 2013 02:50:28 PM JST

* Fri 27 Sep 2013 02:50:28 PM JST
        if win is not None:

* Fri 27 Sep 2013 02:52:57 PM JST
names
* Fri 27 Sep 2013 02:53:09 PM JST
names
* Fri 27 Sep 2013 02:53:13 PM JST
names
* Fri 27 Sep 2013 04:12:04 PM JST
    if type(sec) is not _types.IntType:
        msg = '"sec" is not int type. Must be int. We got {}'.format(
            str(type(sec)))
        raise ValueError(msg)

    wait = sec * 2
    count = 0
    while 1:
        if exists(confirm=confirm, **args) is True:
            return True
        _sleep(0.5)
        # infinity loop if sec is 0
        if wait == 0:
            continue
        count += 0.5
        if wait <= count:
            return False

* Fri 27 Sep 2013 04:16:17 PM JST
    def breaker():
        r"""SUMMARY
        
        @Return:
        """
        if exists(confirm=_confirm, **args) is True:
            return True
        return False
    return _wait(breaker=breaker, sec=sec, confirm=confirm)

* Fri 27 Sep 2013 04:16:28 PM JST
True
* Fri 27 Sep 2013 04:16:59 PM JST
    def breaker():
        r"""SUMMARY
        
        @Return:
        """
        if exists(confirm=_confirm, **args) is False:
            return True
        return False
    return _wait(breaker=breaker, sec=sec, confirm=confirm)

* Fri 27 Sep 2013 04:17:14 PM JST
isactive(confirm=confirm, **args) is True:
* Fri 27 Sep 2013 04:18:01 PM JST
    def breaker():
        r"""SUMMARY
        
        @Return:
        """
        if isactive(confirm=confirm, **args) is True:
            return True
        return False
    return _wait(breaker=breaker, sec=sec, confirm=confirm)

* Fri 27 Sep 2013 04:18:09 PM JST
True
* Fri 27 Sep 2013 04:21:25 PM JST
confirm=confirm, **args
* Fri 27 Sep 2013 04:24:59 PM JST
def isactive(confirm=_confirm, **args):
    r"""SUMMARY

    @Arguments:

    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    win = getwin(confirm=confirm, **args)
    if win is None:
        return False
    return win.isactive()



* Fri 27 Sep 2013 04:26:44 PM JST
confirm
* Fri 27 Sep 2013 04:26:57 PM JST
confirm
* Fri 27 Sep 2013 04:27:05 PM JST
confirm
* Fri 27 Sep 2013 04:27:09 PM JST
confirm
* Fri 27 Sep 2013 04:28:32 PM JST
_confirm
* Fri 27 Sep 2013 04:28:36 PM JST
confirm,
* Fri 27 Sep 2013 04:28:53 PM JST
sec=sec,
* Fri 27 Sep 2013 04:29:19 PM JST
**args
* Fri 27 Sep 2013 04:29:25 PM JST
breaker=breaker, confirm=confirm, sec=sec, **args
* Fri 27 Sep 2013 04:33:43 PM JST

* Fri 27 Sep 2013 04:33:43 PM JST

* Fri 27 Sep 2013 04:33:43 PM JST
    r"""

* Fri 27 Sep 2013 04:33:43 PM JST
    r"""

* Fri 27 Sep 2013 04:33:43 PM JST
    r"""
    """

* Fri 27 Sep 2013 04:34:00 PM JST
False
* Fri 27 Sep 2013 04:34:00 PM JST
return False
* Fri 27 Sep 2013 04:37:03 PM JST
class TimeoutError(Exception):
    def __init__(self, count):
        r"""
        """
        self._count = count


* Fri 27 Sep 2013 04:51:19 PM JST
def _wait(breaker, confirm, sec=0, **args):
    r"""SUMMARY

    @Arguments:
    - `breaker`:
    - `sec`:
    - `confirm`:
    - `**args`:

    @Return:
    """
    if type(sec) is not _types.IntType:
        msg = '"sec" is not int type. Must be int. We got {}'.format(
            str(type(sec)))
        raise ValueError(msg)

    wait = sec * 2
    count = 0
    while 1:
        if breaker(confirm=confirm, **args) is True:
            return True
        _sleep(0.5)
        # infinity loop if sec is 0
        if wait == 0:
            continue
        count += 0.5
        if wait <= count:
            raise TimeoutError(count / 2)

* Fri 27 Sep 2013 04:53:28 PM JST
0,
* Fri 27 Sep 2013 04:53:29 PM JST
sec=0,
* Fri 27 Sep 2013 04:53:29 PM JST
confirm, sec=0,
* Fri 27 Sep 2013 04:53:29 PM JST
breaker, confirm, sec=0,
* Fri 27 Sep 2013 04:54:22 PM JST
        if type(self._sec) is not _types.IntType:
            msg = '"sec" is not int type. Must be int. We got {}'.format(
                str(type(sec)))
            raise ValueError(msg)

* Fri 27 Sep 2013 04:54:29 PM JST
_sec
* Fri 27 Sep 2013 04:54:30 PM JST
self._sec
* Fri 27 Sep 2013 04:55:03 PM JST
_sec = 
* Fri 27 Sep 2013 04:55:03 PM JST
self._sec = 
* Fri 27 Sep 2013 04:55:30 PM JST
0
* Fri 27 Sep 2013 04:55:32 PM JST

* Fri 27 Sep 2013 04:55:32 PM JST

* Fri 27 Sep 2013 04:55:32 PM JST
        self.set_sec(sec)

* Fri 27 Sep 2013 05:02:08 PM JST
F
* Fri 27 Sep 2013 05:02:08 PM JST
types.F
* Fri 27 Sep 2013 05:03:26 PM JST
type(confirm)
* Fri 27 Sep 2013 05:03:49 PM JST
 = confirm
* Fri 27 Sep 2013 05:04:03 PM JST
def waitwin(sec=0, confirm=_confirm, **args):
    r"""SUMMARY

    @Arguments:

    - `sec`:
    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    def breaker(confirm, **args):
        r"""SUMMARY

        @Return:
        """
        if exists(confirm=confirm, **args) is True:
            return True
        return False
    return _wait(breaker=breaker, confirm=confirm, sec=sec, **args)

* Fri 27 Sep 2013 05:04:24 PM JST
0, 
* Fri 27 Sep 2013 05:06:45 PM JST
def waitclose(sec=0, confirm=_confirm, **args):
    r"""SUMMARY

    @Arguments:

    - `sec`:
    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    def breaker(confirm, **args):
        r"""SUMMARY

        @Return:
        """
        if exists(confirm=confirm, **args) is False:
            return True
        return False
    return _wait(breaker=breaker, confirm=confirm, sec=sec, **args)

* Fri 27 Sep 2013 05:06:56 PM JST
_confirm, 
* Fri 27 Sep 2013 05:06:56 PM JST
confirm=_confirm, 
* Fri 27 Sep 2013 05:06:57 PM JST
0, confirm=_confirm, 
* Fri 27 Sep 2013 05:06:58 PM JST
sec=0, confirm=_confirm, 
* Fri 27 Sep 2013 05:07:52 PM JST
    def waitclose(self, **args):
        r"""SUMMARY

        @Arguments:

        - `sec`:
        - `title`:
        - `klass`:
        - `pid`:
        - `regexp`:

        @Return:
        """
        def breaker(confirm, **args):
            r"""SUMMARY

            @Return:
            """
            if exists(confirm=confirm, **args) is False:
                return True
            return False
        return self._wait(breaker=breaker, **args)


* Fri 27 Sep 2013 05:08:35 PM JST
wait
* Fri 27 Sep 2013 05:08:39 PM JST
wait
* Fri 27 Sep 2013 05:08:53 PM JST
def waitactive(sec=0, confirm=_confirm, **args):
    r"""SUMMARY

    @Arguments:

    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    def breaker(confirm, **args):
        r"""SUMMARY

        @Return:
        """
        if isactive(confirm=confirm, **args) is True:
            return True
        return False
    return _wait(breaker=breaker, confirm=confirm, sec=sec, **args)


def waitdeactive(sec=0, confirm=_confirm, **args):
    r"""SUMMARY

    @Arguments:

    - `title`:
    - `klass`:
    - `pid`:
    - `regexp`:

    @Return:
    """
    def breaker(confirm, **args):
        r"""SUMMARY

        @Return:
        """
        if isactive(confirm=confirm, **args) is False:
            return True
        return False
    return _wait(breaker=breaker, confirm=confirm, sec=sec, **args)

* Fri 27 Sep 2013 05:09:17 PM JST
wait
* Fri 27 Sep 2013 05:09:48 PM JST
wait
* Fri 27 Sep 2013 05:19:53 PM JST

* Fri 27 Sep 2013 05:19:53 PM JST

* Fri 27 Sep 2013 05:19:53 PM JST
            r"""SUMMARY

* Fri 27 Sep 2013 05:19:54 PM JST

* Fri 27 Sep 2013 05:19:54 PM JST

* Fri 27 Sep 2013 05:19:54 PM JST
            @Return:

* Fri 27 Sep 2013 05:19:54 PM JST
            @Return:

* Fri 27 Sep 2013 05:19:54 PM JST
            @Return:
            """

* Fri 27 Sep 2013 05:39:09 PM JST

* Fri 27 Sep 2013 05:39:09 PM JST

* Fri 27 Sep 2013 05:39:09 PM JST
import cgitb as _cgitb

* Fri 27 Sep 2013 05:39:11 PM JST

* Fri 27 Sep 2013 05:39:11 PM JST

* Fri 27 Sep 2013 05:39:11 PM JST
import cgitb as _cgitb

* Fri 27 Sep 2013 05:40:40 PM JST
active
* Fri 27 Sep 2013 05:41:59 PM JST

* Fri 27 Sep 2013 05:41:59 PM JST

* Fri 27 Sep 2013 05:41:59 PM JST
import cgitb as _cgitb

* Fri 27 Sep 2013 05:42:01 PM JST

* Fri 27 Sep 2013 05:42:01 PM JST

* Fri 27 Sep 2013 05:42:01 PM JST
import cgitb as _cgitb

* Fri 27 Sep 2013 06:00:02 PM JST
rx symbol-start
* Fri 27 Sep 2013 06:00:27 PM JST
(re-search-backward "\\_<" nil 'noerror)
* Fri 27 Sep 2013 06:00:56 PM JST
"\\_<"
* Fri 27 Sep 2013 06:00:59 PM JST
(looking-at "\\_<")
* Fri 27 Sep 2013 06:01:17 PM JST
"\\_<"
* Fri 27 Sep 2013 06:01:19 PM JST
re "\\_<"
* Fri 27 Sep 2013 06:01:52 PM JST

* Fri 27 Sep 2013 06:01:52 PM JST

* Fri 27 Sep 2013 06:01:52 PM JST
(looking-at "\\_<")

* Fri 27 Sep 2013 06:01:54 PM JST
at "\\_<"
* Fri 27 Sep 2013 06:02:23 PM JST
  
* Fri 27 Sep 2013 06:02:30 PM JST
  
* Fri 27 Sep 2013 06:02:35 PM JST

* Fri 27 Sep 2013 06:02:35 PM JST

* Fri 27 Sep 2013 06:02:35 PM JST
(re-search-backward "\\_<" nil 'noerror)

* Fri 27 Sep 2013 06:02:40 PM JST
(let ((re (rx symbol-start)))
  (unless (looking-at re)
    (re-search-backward "\\_<" nil 'noerror)
    ))
* Fri 27 Sep 2013 06:04:20 PM JST
(re-search-backward "\\_<" nil 'noerror)
* Fri 27 Sep 2013 06:04:27 PM JST
backward "\\_<"
* Fri 27 Sep 2013 06:11:50 PM JST
(defun py-wharap-quote ()
  ""
  (interactive)
  (let ((re-start (rx symbol-start))
        (re-end (rx symbol-end)))
    (unless (looking-at re-start)
      (re-search-backward re-start nil 'noerror)
      (insert "'")
      (re-search-backward re-end nil 'noerror)
      (insert "'")
      )))
* Fri 27 Sep 2013 06:25:11 PM JST
(defun py-wharap-quote ()
  ""
  (interactive)
  (let ((re-start (rx symbol-start))
        (re-end (rx symbol-end)))
    (unless (looking-at re-start)
      (re-search-backward re-start nil 'noerror)
      (insert "'")
      (re-search-backward re-end nil 'noerror)
      (insert "'")
      )))
* Fri 27 Sep 2013 06:25:30 PM JST
(defun py-wharap-quote ()
  ""
  (interactive)
  (let ((re-start (rx symbol-start))
        (re-end (rx symbol-end)))
    (unless (looking-at re-start)
      (re-search-backward re-start nil 'noerror)
      (insert "'")
      (re-search-backward re-end nil 'noerror)
      (insert "'")
      )))
* Fri 27 Sep 2013 06:25:52 PM JST
py-wharap-quote
* Fri 27 Sep 2013 06:26:39 PM JST
py-wharap-quote
* Fri 27 Sep 2013 06:27:02 PM JST
unless
* Fri 27 Sep 2013 06:27:15 PM JST
py-wharap-quote
* Fri 27 Sep 2013 06:27:35 PM JST
when
* Fri 27 Sep 2013 06:27:44 PM JST
(looking-at re-start)
* Fri 27 Sep 2013 06:28:02 PM JST
(rx symbol-start)
* Fri 27 Sep 2013 06:28:09 PM JST
"\\_<"
* Fri 27 Sep 2013 06:28:17 PM JST
(looking-at "\\_<")
* Fri 27 Sep 2013 06:28:50 PM JST
(defun py-wharap-quote ()
  ""
  (interactive)
  (let ((re-start (rx symbol-start))
        (re-end (rx symbol-end)))
    (unless (looking-at re-start)
      (re-search-backward re-start nil 'noerror))
    (insert "'")
    (re-search-forward re-end nil 'noerror)
    (insert "'")
    ))
* Fri 27 Sep 2013 06:41:49 PM JST
(defun py-wharap-quote ()
  ""
  (interactive)
  (let ((re-start (rx symbol-start))
        (re-end (rx symbol-end)))
    (unless (looking-at re-start)
      (re-search-backward re-start nil 'noerror))
    (insert "'")
    (re-search-forward re-end nil 'noerror)
    (insert "'")
    ))
* Fri 27 Sep 2013 06:42:13 PM JST
py-wharap-quote
* Fri 27 Sep 2013 06:43:49 PM JST
foward
* Fri 27 Sep 2013 06:44:00 PM JST
(defun py-wharap-quote ()
  ""
  (interactive)
  (let ((re-start (rx symbol-start))
        (re-end (rx symbol-end)))
    (unless (looking-at re-start)
      (re-search-backward re-start nil 'noerror))
    (insert "'")
    (re-search-forward re-end nil 'noerror)
    (insert "'")
    ))
* Fri 27 Sep 2013 06:45:43 PM JST
(setq ac-sources (append ac-sources '(ac-emacs-lisp-features
                                          ac-source-functions
                                          ac-source-variables
                                          ac-source-symbols)))
* Fri 27 Sep 2013 06:46:53 PM JST
(if
* Fri 27 Sep 2013 06:46:55 PM JST
if
* Fri 27 Sep 2013 06:52:01 PM JST
(defun py-wrap-byquote ()
  "Wrap symbol by quote."
  (interactive)
  (when (looking-at "[ \t]")
    (error "Do not on space or tab"))
  (save-excursion
    (let ((re-start (rx symbol-start))
          (re-end (rx symbol-end)))
      (unless (looking-at re-start)
        (re-search-backward re-start nil 'noerror))
      (insert "'")
      (re-search-forward re-end nil 'noerror)
      (insert "'")
      )))
* Fri 27 Sep 2013 06:59:45 PM JST
unless
* Fri 27 Sep 2013 06:59:48 PM JST
unless
* Fri 27 Sep 2013 07:00:27 PM JST

* Fri 27 Sep 2013 07:00:27 PM JST

* Fri 27 Sep 2013 07:00:27 PM JST
      (py-wrap-byquote))

* Fri 27 Sep 2013 07:00:41 PM JST
  
* Fri 27 Sep 2013 07:01:28 PM JST
        
* Fri 27 Sep 2013 07:05:05 PM JST
quote-doublequote-toggle
* Fri 27 Sep 2013 07:07:25 PM JST
  
* Fri 27 Sep 2013 07:07:37 PM JST
  
* Fri 27 Sep 2013 07:07:49 PM JST
  
* Fri 27 Sep 2013 07:08:32 PM JST
  
* Fri 27 Sep 2013 07:40:08 PM JST
(rx symbol-start)
* Fri 27 Sep 2013 07:40:23 PM JST
(rx symbol-end)
* Fri 27 Sep 2013 07:40:29 PM JST
"\\_>"
* Fri 27 Sep 2013 07:40:32 PM JST
(rx symbol-start)
* Fri 27 Sep 2013 07:40:57 PM JST
(re-search-backward (concat (rx symbol-start) "import" (rx symbol-end)) nil 'noerror)
* Fri 27 Sep 2013 07:42:52 PM JST
(match-end 0)
* Fri 27 Sep 2013 07:43:05 PM JST
(save-excursion
  
  (re-search-backward (concat (rx symbol-start) "import" (rx symbol-end))
                      nil 'noerror)
  (match-end 0)
)
* Fri 27 Sep 2013 07:49:07 PM JST
narrow-line
* Fri 27 Sep 2013 09:15:24 PM JST
title='Sleipnir'
* Fri 27 Sep 2013 09:15:29 PM JST
wm.WinWait(sec=180).win(title='Sleipnir')
* Fri 27 Sep 2013 10:15:07 PM JST
  (setq e2wm:c-code-recipe
        '(| (:left-max-size 30)
            (- (:upper-size-ratio 0.4)
               files imenu)
            (| (:right-max-size 85) main
               (- (:upper-size-ratio 0.6) main-prev sub))))

  (setq e2wm:c-code-winfo
        '((:name imenu     :plugin imenu :default-hide nil)
          (:name files     :plugin files :plugin-args)
          (:name main)
          (:name main-prev :plugin main-prev :default-hide nil)
          (:name sub       :buffer "*info*" :default-hide nil)))

* Fri 27 Sep 2013 10:19:26 PM JST
(setq e2wm:c-code-recipe
      '(| (:left-max-size 30)
          (- (:upper-size-ratio 0.3)
             files
             (- (:upper-size-ratio 0.2)
                history imenu))
          (| (:right-max-size 85) main
             (- (:upper-size-ratio 0.6) main-prev sub))))

(setq e2wm:c-code-winfo
      '((:name imenu     :plugin imenu :default-hide nil)
        (:name files     :plugin files :plugin-args)
        (:name history   :plugin history-list :default-hide nil)
        (:name main)
        (:name main-prev :plugin main-prev :default-hide nil)
        (:name sub       :buffer "*info*" :default-hide nil)))

* Fri 27 Sep 2013 10:24:34 PM JST
(defface e2wm:face-history-list-normal
  '((t :foreground "DarkSlateBlue"))
  "Face for e2wm history list." :group 'e2wm)
(defface e2wm:face-history-list-select1
  '((t :foreground "OrangeRed" :background "Lightsteelblue1"))
  "Face for e2wm history list." :group 'e2wm)
(defface e2wm:face-history-list-select2
  '((t :foreground "Blue" :background "WhiteSmoke"))
  "Face for e2wm history list." :group 'e2wm)

* Fri 27 Sep 2013 10:24:52 PM JST
e2wm:face-history-list-normal
* Fri 27 Sep 2013 10:25:13 PM JST
'((t :foreground "DarkSlateBlue"))
* Fri 27 Sep 2013 10:25:17 PM JST
DarkSlateBlue
* Fri 27 Sep 2013 10:25:49 PM JST
e2wm:face-history-list-select2
* Fri 27 Sep 2013 10:28:07 PM JST
(face-spec-set 'modeline-mousable-minor-mode
               '((t (:background "white" :foreground "black"))))
* Fri 27 Sep 2013 10:28:15 PM JST
e2wm:face-history-list-normal
* Fri 27 Sep 2013 10:28:20 PM JST
'((t :foreground "White"))
* Fri 27 Sep 2013 10:29:27 PM JST
               
* Fri 27 Sep 2013 10:29:29 PM JST
(face-spec-set 'e2wm:face-history-list-normal '((t :foreground "White")))
* Fri 27 Sep 2013 10:30:06 PM JST
e2wm:c-code-recipe
* Fri 27 Sep 2013 10:30:17 PM JST
Modified: `e2wm:c-code-recipe', `e2wm:c-code-winfo'
* Fri 27 Sep 2013 10:45:29 PM JST
evolution.EVOLUTION.get('binpath')
* Fri 27 Sep 2013 10:45:34 PM JST
CMD
* Fri 27 Sep 2013 10:54:31 PM JST
type == 
* Fri 27 Sep 2013 10:54:31 PM JST
win.type == 
* Fri 27 Sep 2013 10:57:58 PM JST
if :
* Fri 27 Sep 2013 11:07:43 PM JST
and 
* Fri 27 Sep 2013 11:07:43 PM JST
None and 
* Fri 27 Sep 2013 11:07:43 PM JST
not None and 
* Fri 27 Sep 2013 11:07:43 PM JST
is not None and 
* Fri 27 Sep 2013 11:07:44 PM JST
klass') is not None and 
* Fri 27 Sep 2013 11:07:44 PM JST
get('klass') is not None and 
* Fri 27 Sep 2013 11:07:45 PM JST
args.get('klass') is not None and 
* Fri 27 Sep 2013 11:07:48 PM JST
klass')
* Fri 27 Sep 2013 11:07:48 PM JST
get('klass')
* Fri 27 Sep 2013 11:07:49 PM JST
args.get('klass')
* Fri 27 Sep 2013 11:08:28 PM JST
            
* Fri 27 Sep 2013 11:10:42 PM JST
confirm=_confirm
* Fri 27 Sep 2013 11:13:00 PM JST

* Fri 27 Sep 2013 11:13:00 PM JST

* Fri 27 Sep 2013 11:13:00 PM JST
    for win in wm.iter_wins():

* Fri 27 Sep 2013 11:13:06 PM JST

* Fri 27 Sep 2013 11:13:06 PM JST

* Fri 27 Sep 2013 11:13:06 PM JST
    if win.klass == 'Evoluton' and win.type == 'Normal':

* Fri 27 Sep 2013 11:13:18 PM JST
win
* Fri 27 Sep 2013 11:17:10 PM JST
python_path="/usr/bin/python"
mirror="/root/.pylib/mirror.py"
pull_opt="--pull-only"

[ -x $python_path ] || exit 0
[ -x $mirror ] || exit 0

$python_path $mirror $pull_opt $@

exit 0

* Fri 27 Sep 2013 11:17:13 PM JST
mirror
* Fri 27 Sep 2013 11:17:18 PM JST
mirror
* Fri 27 Sep 2013 11:17:24 PM JST

* Fri 27 Sep 2013 11:17:24 PM JST

* Fri 27 Sep 2013 11:17:24 PM JST
pull_opt="--pull-only"

* Fri 27 Sep 2013 11:17:27 PM JST
mirror
* Fri 27 Sep 2013 11:17:34 PM JST
opt
* Fri 27 Sep 2013 11:17:36 PM JST
mirror
* Fri 27 Sep 2013 11:24:57 PM JST
(re-search-backward (concat (rx symbol-start) "import" (rx symbol-end))
                        nil 'noerror)
    (match-end 0)
* Fri 27 Sep 2013 11:25:04 PM JST
(progn
  (re-search-backward (concat (rx symbol-start) "import" (rx symbol-end))
                      nil 'noerror)
  (match-end 0))
* Fri 27 Sep 2013 11:29:24 PM JST
(thing-at-point 'symbol)
* Fri 27 Sep 2013 11:30:16 PM JST
(progn
  (message (thing-at-point 'symbol)))
* Fri 27 Sep 2013 11:30:33 PM JST
message
* Fri 27 Sep 2013 11:30:52 PM JST
(progn
  (setq msg (thing-at-point 'symbol))
  (message (car msg)))
* Fri 27 Sep 2013 11:31:03 PM JST
(progn
  (setq msg (thing-at-point 'symbol))
  (message msg))
* Fri 27 Sep 2013 11:31:16 PM JST
(thing-at-point 'symbol)
* Fri 27 Sep 2013 11:31:55 PM JST

* Fri 27 Sep 2013 11:31:55 PM JST

* Fri 27 Sep 2013 11:31:55 PM JST
(progn

* Fri 27 Sep 2013 11:31:57 PM JST

* Fri 27 Sep 2013 11:31:57 PM JST

* Fri 27 Sep 2013 11:31:57 PM JST
  )

* Fri 27 Sep 2013 11:33:07 PM JST
(concat (rx symbol-start) "import" (rx symbol-end))
* Fri 27 Sep 2013 11:33:23 PM JST
                      
* Fri 27 Sep 2013 11:33:36 PM JST
(re (concat (rx symbol-start) "import" (rx symbol-end)))
* Fri 27 Sep 2013 11:33:46 PM JST
        
* Fri 27 Sep 2013 11:34:09 PM JST
  (re-search-backward re nil 'noerror)
  (match-end 0)

* Fri 27 Sep 2013 11:34:35 PM JST
progn 
* Fri 27 Sep 2013 11:34:44 PM JST

* Fri 27 Sep 2013 11:34:44 PM JST

* Fri 27 Sep 2013 11:34:44 PM JST
      ELSE

* Fri 27 Sep 2013 11:34:53 PM JST
(match-end 0)
* Fri 27 Sep 2013 11:35:07 PM JST
  
* Fri 27 Sep 2013 11:35:44 PM JST
(save-excursion
  (save-restriction

* Fri 27 Sep 2013 11:36:33 PM JST
(thing-at-point 'symbol)
* Fri 27 Sep 2013 11:37:08 PM JST
      
* Fri 27 Sep 2013 11:37:32 PM JST
ALIAS
* Fri 27 Sep 2013 11:37:35 PM JST
    
* Fri 27 Sep 2013 11:37:39 PM JST
(save-excursion
  (save-restriction
(let ((re (concat (rx symbol-start) "import" (rx symbol-end)))
      symbl)
  (if (re-search-backward re nil 'noerror)
      (progn
        (goto-char (match-end 0))
        (skip-chars-forward "[ \t]")
        (setq symbl (thing-at-point 'symbol))
        (concat "_" symbl))
    ("ALIAS")))))
* Fri 27 Sep 2013 11:56:44 PM JST
ALIAS
* Fri 27 Sep 2013 11:59:49 PM JST
ALIAS
* Sat 28 Sep 2013 12:01:13 AM JST
getattr
* Sat 28 Sep 2013 12:02:17 AM JST
(not (equal (this-command-keys-vector) [32]))
* Sat 28 Sep 2013 12:02:51 AM JST
super 
* Sat 28 Sep 2013 12:03:00 AM JST
impo
* Sat 28 Sep 2013 12:03:01 AM JST
impo
* Sat 28 Sep 2013 12:03:01 AM JST
impoinspect as _inspect

* Sat 28 Sep 2013 12:03:03 AM JST

* Sat 28 Sep 2013 12:03:03 AM JST

* Sat 28 Sep 2013 12:03:03 AM JST
from time import sleep

* Sat 28 Sep 2013 12:03:11 AM JST
sleep(SEC)
* Sat 28 Sep 2013 12:03:37 AM JST
sleep(SEC)
* Sat 28 Sep 2013 12:03:52 AM JST
(and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 12:04:12 AM JST
time.
* Sat 28 Sep 2013 12:04:55 AM JST
sleep(   )
* Sat 28 Sep 2013 12:05:12 AM JST
sleep()
* Sat 28 Sep 2013 12:05:37 AM JST
sleep()
* Sat 28 Sep 2013 12:05:45 AM JST
super()
* Sat 28 Sep 2013 12:06:07 AM JST
sleep(SEC)
* Sat 28 Sep 2013 12:06:11 AM JST
sleep()
* Sat 28 Sep 2013 12:06:28 AM JST
(this-command-keys-vector)
* Sat 28 Sep 2013 12:09:01 AM JST
(and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 12:09:24 AM JST
sleep()
* Sat 28 Sep 2013 12:09:31 AM JST

* Sat 28 Sep 2013 12:09:31 AM JST

* Sat 28 Sep 2013 12:09:31 AM JST
from time import sleep

* Sat 28 Sep 2013 12:09:51 AM JST
sleep()
* Sat 28 Sep 2013 12:10:17 AM JST
(and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 12:10:38 AM JST
sleep()
* Sat 28 Sep 2013 12:10:41 AM JST
sleep()
* Sat 28 Sep 2013 12:11:00 AM JST
os.path.exists()
* Sat 28 Sep 2013 12:11:14 AM JST
sleep()
* Sat 28 Sep 2013 12:11:19 AM JST
super()
* Sat 28 Sep 2013 12:12:59 AM JST
sleep(hello)
* Sat 28 Sep 2013 12:13:18 AM JST
(and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 12:15:27 AM JST
(py--insert-imports "time[ \t]+import[ \t]+sleep" "from time import sleep")
* Sat 28 Sep 2013 12:16:27 AM JST
(py--insert-imports "time[ \t]+import[ \t]+sleep" "from time import sleep")
* Sat 28 Sep 2013 12:16:34 AM JST
sleep(${1:SEC})$0`(py--insert-imports "time[ \t]+import[ \t]+sleep" "from time import sleep")`
* Sat 28 Sep 2013 12:16:41 AM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 12:17:13 AM JST
[ \t]
* Sat 28 Sep 2013 12:17:41 AM JST
(and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 12:19:01 AM JST
jit-lock-function
* Sat 28 Sep 2013 12:21:31 AM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 12:23:10 AM JST
`(progn (end-of-line) (skip-chars-backward " \t") (unless (eq (char-before) 58) (insert ":")))`
* Sat 28 Sep 2013 12:25:02 AM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 12:29:39 AM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 12:30:10 AM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 12:53:32 AM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 12:55:10 AM JST
getpass()
* Sat 28 Sep 2013 12:58:08 AM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 12:58:51 AM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 12:59:13 AM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 01:04:55 AM JST
___
* Sat 28 Sep 2013 01:04:56 AM JST
_
* Sat 28 Sep 2013 01:06:38 AM JST
[]
* Sat 28 Sep 2013 01:08:40 AM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 01:09:29 AM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 01:14:01 AM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 01:15:12 AM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 01:18:02 AM JST

* Sat 28 Sep 2013 01:18:02 AM JST

* Sat 28 Sep 2013 01:18:02 AM JST
# key: __

* Sat 28 Sep 2013 01:18:34 AM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Sat 28 Sep 2013 03:01:18 AM JST
sleep()
* Sat 28 Sep 2013 03:31:48 AM JST
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
"""

* Sat 28 Sep 2013 03:46:05 AM JST
.get(key, 0)
* Sat 28 Sep 2013 03:46:18 AM JST
'x'
* Sat 28 Sep 2013 03:46:25 AM JST
'y'
* Sat 28 Sep 2013 03:46:30 AM JST
'height'
* Sat 28 Sep 2013 03:46:37 AM JST
'width'
* Sat 28 Sep 2013 03:46:39 AM JST
.get(, 0)
* Sat 28 Sep 2013 03:46:42 AM JST
.get(, 0)
* Sat 28 Sep 2013 03:46:45 AM JST
.get(, 0)
* Sat 28 Sep 2013 03:46:47 AM JST
.get(, 0)
* Sat 28 Sep 2013 03:47:53 AM JST
, key
* Sat 28 Sep 2013 03:55:13 AM JST
    def get_geometry(self, key, force=False):
        r"""Return geometry or cached it of a Window.

        - `force`: skip cached value.

        @Return: dictionary
        """
        # cache return if not reached interval time
        if self._isneed_cache() or force is True:
            geo = self._window.get_geometry()
            translated = self._window.translate_coords(self._root, geo.x, geo.y)
            dic = {'x': -translated.x,
                   'y': -translated.y,
                   'height': geo.height,
                   'width': geo.width, }
            self._set_cache(dic)
            return self._get_cache().get(key, 0)
        return self._get_cache().get(key, 0)

* Sat 28 Sep 2013 03:56:18 AM JST
(delete-blank-lines)
* Sat 28 Sep 2013 03:56:33 AM JST
(defun py-kill-line (arg)
  "If line is blank, delete all surrounding blank lines, leaving just one.
On isolated blank line, delete that one.
On nonblank line, kill whole line."
  (interactive "P*")
  (cond (mark-active
         (cua-cut-region arg))
        ((progn (beginning-of-line) (looking-at "\\(?:def\\|class\\)"))
         (kill-whole-line))
        ((save-excursion
           (re-search-backward "[^ \t\n]" nil 'noerror)
           (forward-line 1)
           (looking-at "^[ \t\n]+[\n\r]\\(?:def\\|class\\)"))
         (if (eq last-command this-command)
             (progn (delete-blank-lines) (kill-whole-line))
           (delete-blank-lines)
           (save-excursion (insert "\n"))))
        ((progn (beginning-of-line) (looking-at "[ \t]*$"))
         (delete-blank-lines))
        (t
         (kill-whole-line))))
* Sat 28 Sep 2013 03:56:43 AM JST
    @property
    def x(self):
        r"""X-coordinate of a Window.

        @Return: integer value
        """
        return self.get_geometry('x')

    @property
    def y(self):
        r"""Y-coordinate of a Window.

        @Return: integer value
        """
        return self.get_geometry('y')

    @property
    def height(self):
        r"""Vertical size of a Window.

        @Return: interger value
        """
        return self.get_geometry('height')

    @property
    def width(self):
        r"""Horizontal size of a Window.

        @Return: integer value
        """
        return self.get_geometry('width')

    def __repr__(self):
        r"""Represent geometry.

        @Return: string
        """
        fmt = '\n{0:<7}: {1}'
        str_ = ['Geometry']
        geo = self.get_geometry()
        str_.append(fmt.format('x', geo.get('x', 0)))
        str_.append(fmt.format('y', geo.get('y', 0)))
        str_.append(fmt.format('height', geo.get('height', 0)))
        str_.append(fmt.format('width', geo.get('width', 0)))
        return ''.join(str_)

    def __eq__(self, other):
        r"""Compare each x, y, height, width.

        @Return: boolean
        """
        return (self.x == other.x and self.y == other.y and
                self.height == other.height and self.width == other.width)

    def __ne__(self, other):
        r"""Compare each x, y, height, width.

        @Return: boolean
        """
        return not (self.x == other.x and self.y == other.y and
                    self.height == other.height and self.width == other.width)

* Sat 28 Sep 2013 03:56:56 AM JST
(delete-blank-lines)
* Sat 28 Sep 2013 03:57:28 AM JST
(interactive (list (point) (mark)))
* Sat 28 Sep 2013 03:59:38 AM JST
delete-blank-lines
* Sat 28 Sep 2013 04:00:09 AM JST
py-clean-kill-region
* Sat 28 Sep 2013 04:03:05 AM JST
    @property
    def y(self):
        r"""Y-coordinate of a Window.

        @Return: integer value
        """
        return self.get_geometry('y')

* Sat 28 Sep 2013 04:03:32 AM JST
    @property
    def height(self):
        r"""Vertical size of a Window.

        @Return: interger value
        """
        return self.get_geometry('height')


* Sat 28 Sep 2013 04:03:39 AM JST

    @property
    def height(self):
        r"""Vertical size of a Window.

        @Return: interger value
        """
        return self.get_geometry('height')


* Sat 28 Sep 2013 04:03:50 AM JST
(defun py-clean-kill-region (beg end &optional yank-handler)
  "BEG 
AND 
YANK-HANDLER"
  (interactive (list (point) (mark)))
  (kill-region beg end)
  (delete-blank-lines)
  )
* Sat 28 Sep 2013 04:04:23 AM JST
  
* Sat 28 Sep 2013 04:04:47 AM JST
region 
* Sat 28 Sep 2013 04:04:47 AM JST
kill region 
* Sat 28 Sep 2013 04:06:41 AM JST
(defun py-kill-line (arg)
  "If line is blank, delete all surrounding blank lines, leaving just one.
ARG:
On isolated blank line, delete that one.
On nonblank line, kill whole line."
  (interactive "P*")
  (cond (mark-active
         (cua-cut-region arg))
        ((progn (beginning-of-line) (looking-at "\\(?:def\\|class\\)"))
         (kill-whole-line))
        ((save-excursion
           (re-search-backward "[^ \t\n]" nil 'noerror)
           (forward-line 1)
           (looking-at "^[ \t\n]+[\n\r]\\(?:def\\|class\\)"))
         (if (eq last-command this-command)
             (progn (delete-blank-lines) (kill-whole-line))
           (delete-blank-lines)
           (save-excursion (insert "\n"))))
        ((progn (beginning-of-line) (looking-at "[ \t]*$"))
         (delete-blank-lines))
        (t
         (kill-whole-line))))
* Sat 28 Sep 2013 04:09:19 AM JST
    @property
    def height(self):
        r"""Vertical size of a Window.

        @Return: interger value
        """
        return self.get_geometry('height')

* Sat 28 Sep 2013 04:09:26 AM JST
    @property
    def height(self):
        r"""Vertical size of a Window.

        @Return: interger value
        """
        return self.get_geometry('height')

* Sat 28 Sep 2013 04:09:55 AM JST

* Sat 28 Sep 2013 04:09:56 AM JST

* Sat 28 Sep 2013 04:09:56 AM JST

* Sat 28 Sep 2013 04:09:57 AM JST

* Sat 28 Sep 2013 04:10:23 AM JST
C-d
* Sat 28 Sep 2013 04:10:40 AM JST
 ; testing
* Sat 28 Sep 2013 04:11:30 AM JST
    @property
    def height(self):
        r"""Vertical size of a Window.

        @Return: interger value
        """
        return self.get_geometry('height')

* Sat 28 Sep 2013 04:11:38 AM JST
    @property
    def height(self):
        r"""Vertical size of a Window.

        @Return: interger value
        """
        return self.get_geometry('height')

* Sat 28 Sep 2013 04:13:24 AM JST
   # move
   py:mv-block-up
   py:mv-block-down
   py:mv-def-up
   py:mv-def-down
   py:mv-class-up
   py:mv-class-down


* Sat 28 Sep 2013 04:13:45 AM JST
   # predicate
   py:in-if-line-p
   py:in-while-line-p
   py:in-def-line-p
   py:in-class-line-p

   py:in-func-paren-p
   py:in-paren-p

   py:in-if-block-p
   py:in-while-block-p
   py:in-class-block-p
   py:in-method-block-p
   py:in-comment-block-p
   py:docstring-p
   py:empty-line-p


   underscore-word-p
   in-string-or-comment-block-p
   in-string-block-p
   py-in-statement-p
   py-beginning-of-def-p
   py-beginning-of-class-p
   py-beginning-of-def-or-class-p

py-end-of-line-p
py-end-of-buffer-p
py-end-of-paragraph-p
py-end-of-statement-p
py-end-of-expression-p
py-end-of-partial-expression-p
py-end-of-block-p
py-end-of-clause-p
py-end-of-block-or-clause-p
py-end-of-def-p
py-end-of-class-p
py-statement-opens-block-p
py-statement-opens-base
py-statement-opens-clause-p
py-statement-opens-block-or-clause-p
py-statement-opens-class-p
py-statement-opens-def-p
py-statement-opens-def-or-class-p
py-statement-closes-block-p
py-beginning-of-block-bol-p
py-beginning-of-def-bol-p
py-beginning-of-class-bol-p

* Sat 28 Sep 2013 04:13:54 AM JST
predicate
* Sat 28 Sep 2013 04:13:56 AM JST

* Sat 28 Sep 2013 04:13:56 AM JST
   # 
* Sat 28 Sep 2013 04:13:56 AM JST
   # 

* Sat 28 Sep 2013 04:14:23 AM JST
   py:def--region
   py:class--region
   py:comment-region
   py:comment-def
   py:comment-block
   py:comment-class

* Sat 28 Sep 2013 04:14:31 AM JST
   # mark
   py:def--region
   py:class--region
   py:comment-region
   py:comment-def
   py:comment-block
   py:comment-class

   py:mark-paragraph
   py:mark-block
   py:mark-def
   py:mark-class
   py:mark-class-of-def
   py:mark-line
   py:mark-statement

* Sat 28 Sep 2013 04:29:31 AM JST
defun 
* Sat 28 Sep 2013 04:31:58 AM JST
"[ \t]*\\_<\\(for\\|if\\|try\\|with\\)\\_>[: \n\t]"
* Sat 28 Sep 2013 04:32:59 AM JST
"[ \t]*\\_<try\\_>[: \n\t]
* Sat 28 Sep 2013 04:33:59 AM JST
"[ \t]*\\_<\\(def\\)\\_>[ \n\t]"
* Sat 28 Sep 2013 04:37:37 AM JST
py-in-string-or-comment-p
* Sat 28 Sep 2013 04:39:03 AM JST
py-in-string-or-comment-p
* Sat 28 Sep 2013 04:39:38 AM JST
(defmacro py-in-string-or-comment-p ()
  "Returns beginning position if inside a string or comment, nil otherwise. "
  `(or (nth 8 (syntax-ppss))
       (when (or (looking-at "\"")(looking-at "[ \t]*#[ \t]*"))
         (match-beginning 0))))
* Sat 28 Sep 2013 04:47:12 AM JST
py-def-or-class-re
* Sat 28 Sep 2013 04:54:46 AM JST
py
* Sat 28 Sep 2013 04:54:47 AM JST
py-def-re
* Sat 28 Sep 2013 04:55:17 AM JST
"[ 	]*\\_<\\(def\\)\\_>[ 
	]"
* Sat 28 Sep 2013 04:59:31 AM JST
(back-to-indentation)
* Sat 28 Sep 2013 05:01:56 AM JST
(line-end-position)
* Sat 28 Sep 2013 05:03:48 AM JST
(line-end-position)
* Sat 28 Sep 2013 05:04:51 AM JST
line-beginning-position
* Sat 28 Sep 2013 05:11:41 AM JST
(skip-syntax-forward " " (line-end-position))
* Sat 28 Sep 2013 11:00:03 AM JST
defined
* Sat 28 Sep 2013 04:40:34 PM JST

* Sat 28 Sep 2013 04:40:34 PM JST

* Sat 28 Sep 2013 04:40:34 PM JST
    import wm

* Sat 28 Sep 2013 04:41:51 PM JST
'Downloads - File Manager'
* Sat 28 Sep 2013 04:42:37 PM JST
'Downloads - File Manager'
* Sat 28 Sep 2013 04:43:19 PM JST
'archive - File Manager'
* Sat 28 Sep 2013 04:43:35 PM JST
'archive - File Manager'
* Sat 28 Sep 2013 04:43:58 PM JST

* Sat 28 Sep 2013 04:43:58 PM JST

* Sat 28 Sep 2013 04:43:58 PM JST
    display =  Xlib.display.Display()

* Sat 28 Sep 2013 04:43:58 PM JST
    display =  Xlib.display.Display()

* Sat 28 Sep 2013 04:43:58 PM JST
    display =  Xlib.display.Display()
    downwin = myxlib.getwindowbyname2('Downloads - File Manager')

* Sat 28 Sep 2013 04:44:01 PM JST

* Sat 28 Sep 2013 04:44:01 PM JST

* Sat 28 Sep 2013 04:44:01 PM JST
    archivewin = myxlib.getwindowbyname2('archive - File Manager')

* Sat 28 Sep 2013 04:44:19 PM JST
x=2120, y=1, width=840, height=1024
* Sat 28 Sep 2013 04:44:25 PM JST
x=1280, y=1, width=835, height=1024
* Sat 28 Sep 2013 04:46:03 PM JST
wm.getwin(tilte='archive - File Manager')
* Sat 28 Sep 2013 04:46:56 PM JST
tilte
* Sat 28 Sep 2013 04:47:28 PM JST

* Sat 28 Sep 2013 04:47:28 PM JST

* Sat 28 Sep 2013 04:47:28 PM JST
    downwin = wm.getwin(title='Downloads - File Manager')

* Sat 28 Sep 2013 04:50:09 PM JST
wm.title
* Sat 28 Sep 2013 04:51:23 PM JST
or 
* Sat 28 Sep 2013 04:51:32 PM JST
downwin.move(x=2120, y=1, width=840, height=1024)
* Sat 28 Sep 2013 04:51:36 PM JST
downwin
* Sat 28 Sep 2013 04:51:41 PM JST
move(x=1280, y=1, width=835, height=1024)
* Sat 28 Sep 2013 04:57:33 PM JST
klass
* Sat 28 Sep 2013 04:58:31 PM JST

* Sat 28 Sep 2013 04:58:31 PM JST

* Sat 28 Sep 2013 04:58:31 PM JST
            print(wm.title)

* Sat 28 Sep 2013 04:58:32 PM JST
            print(wm.title)

* Sat 28 Sep 2013 04:58:32 PM JST
            print(wm.title)
            print(wm.klass)

* Sat 28 Sep 2013 04:58:50 PM JST

* Sat 28 Sep 2013 04:58:50 PM JST

* Sat 28 Sep 2013 04:58:51 PM JST
            print('Matched Thunar')

* Sat 28 Sep 2013 05:01:54 PM JST

* Sat 28 Sep 2013 05:01:54 PM JST

* Sat 28 Sep 2013 05:01:54 PM JST
            print()

* Sat 28 Sep 2013 05:01:56 PM JST
wm
* Sat 28 Sep 2013 05:01:59 PM JST
wm
* Sat 28 Sep 2013 05:02:01 PM JST

* Sat 28 Sep 2013 05:02:01 PM JST

* Sat 28 Sep 2013 05:02:02 PM JST
            sleep(0.5)

* Sat 28 Sep 2013 05:04:54 PM JST
win
* Sat 28 Sep 2013 05:15:19 PM JST
    sbp.Popen([CMD.get('rm'),
               '/root/Downloads/*.torrent', '/root/Downloads/*.*.torent'],
              stdout=sbp.PIPE, stderr=sbp.PIPE)

* Sat 28 Sep 2013 05:15:23 PM JST
sbp.Popen([CMD.get('rm'),
* Sat 28 Sep 2013 05:15:39 PM JST
               
* Sat 28 Sep 2013 05:19:06 PM JST

* Sat 28 Sep 2013 05:19:07 PM JST

* Sat 28 Sep 2013 05:19:07 PM JST
    for window in wm.iter_matchwin(regexp='File Manager'):

* Sat 28 Sep 2013 05:19:23 PM JST
        
* Sat 28 Sep 2013 05:19:25 PM JST
        
* Sat 28 Sep 2013 05:22:38 PM JST
BPATH
* Sat 28 Sep 2013 05:22:45 PM JST
CPATH
* Sat 28 Sep 2013 05:23:32 PM JST

* Sat 28 Sep 2013 05:23:32 PM JST

* Sat 28 Sep 2013 05:23:32 PM JST
    removable = []

* Sat 28 Sep 2013 05:31:28 PM JST
    removable = []
    targets = ['*torrent', '*.*.torrent']
    download_path = os.path.expanduser('~/Downloads')

    for target in targets:
        removable.append(glob.glob(os.path.join(download_path, target)))

    if removable:
        logging.log(10, 'Will remove: {}'.format(', '.join(removable)))
        # do!! remove
        for tgt in removable:
            shutil.rmtree(tgt)


* Sat 28 Sep 2013 05:32:17 PM JST
log(10, TEXT)
* Sat 28 Sep 2013 05:34:50 PM JST
delq
* Sat 28 Sep 2013 05:35:33 PM JST
ac-source-words-in-same-mode-buffers
* Sat 28 Sep 2013 05:35:54 PM JST
(delq 'ac-source-words-in-same-mode-buffers ac-sources)
* Sat 28 Sep 2013 05:36:38 PM JST
def
* Sat 28 Sep 2013 05:38:03 PM JST
logname = 'automyscript.log'
* Sat 28 Sep 2013 05:38:11 PM JST
logdir = '/var/log'
* Sat 28 Sep 2013 05:38:16 PM JST
logpath = os.path.join(logdir, logname)
* Sat 28 Sep 2013 05:38:21 PM JST
logging.basicConfig(filename=logpath, level=logging.DEBUG,
                    format='%(asctime)s %(message)s')
* Sat 28 Sep 2013 05:39:38 PM JST
DEBUG,
* Sat 28 Sep 2013 05:39:52 PM JST
DEBUG
* Sat 28 Sep 2013 05:42:34 PM JST
logname = 'automyscript.log'
logdir = '/var/log'
logpath = os.path.join(logdir, logname)

* Sat 28 Sep 2013 05:42:52 PM JST
logging.basicConfig(filename=logpath, level=logging.DEBUG,
                    format='%(asctime)s %(message)s')

* Sat 28 Sep 2013 05:43:03 PM JST
DEBUG
* Sat 28 Sep 2013 05:43:12 PM JST
format='%(asctime)s %(message)s')
* Sat 28 Sep 2013 05:44:35 PM JST
logging.
* Sat 28 Sep 2013 05:51:56 PM JST
'/root/Downloads', '/data/archive'
* Sat 28 Sep 2013 05:52:44 PM JST

* Sat 28 Sep 2013 05:52:44 PM JST

* Sat 28 Sep 2013 05:52:44 PM JST
    sleep(0.5)

* Sat 28 Sep 2013 05:53:01 PM JST
log
* Sat 28 Sep 2013 05:53:01 PM JST
logging.log
* Sat 28 Sep 2013 05:53:16 PM JST
Failed: clean download file
* Sat 28 Sep 2013 05:55:54 PM JST
fmt
* Sat 28 Sep 2013 05:56:36 PM JST
            
* Sat 28 Sep 2013 06:01:24 PM JST
TimeoutError
* Sat 28 Sep 2013 06:01:55 PM JST
if not 
* Sat 28 Sep 2013 06:05:56 PM JST
'Downloads - File Manager'
* Sat 28 Sep 2013 06:06:02 PM JST
'archive - File Manager'
* Sat 28 Sep 2013 06:06:44 PM JST
'TimeoutError {}'.format(title)
* Sat 28 Sep 2013 06:06:57 PM JST

* Sat 28 Sep 2013 06:06:57 PM JST

* Sat 28 Sep 2013 06:06:57 PM JST
    # if not wm.WinWait(sec=180).win(title=):

* Sat 28 Sep 2013 06:06:57 PM JST
    # if not wm.WinWait(sec=180).win(title=):

* Sat 28 Sep 2013 06:06:57 PM JST
    # if not wm.WinWait(sec=180).win(title=):
        # return False

* Sat 28 Sep 2013 06:16:02 PM JST

* Sat 28 Sep 2013 06:16:02 PM JST

* Sat 28 Sep 2013 06:16:02 PM JST
                print('move downloads folder')

* Sat 28 Sep 2013 06:16:03 PM JST

* Sat 28 Sep 2013 06:16:03 PM JST

* Sat 28 Sep 2013 06:16:03 PM JST
                print('move archive folder')

* Sat 28 Sep 2013 06:17:23 PM JST
is
* Sat 28 Sep 2013 06:17:23 PM JST
id is
* Sat 28 Sep 2013 06:17:48 PM JST
logging.log(10, 'Thunar Downloads {} moved.'.format(win.id))
* Sat 28 Sep 2013 06:17:52 PM JST
Downloads
* Sat 28 Sep 2013 06:18:22 PM JST

* Sat 28 Sep 2013 06:18:22 PM JST

* Sat 28 Sep 2013 06:18:22 PM JST
    print('Move window')

* Sat 28 Sep 2013 06:24:28 PM JST
    removable = []
    targets = ['*torrent', '*.*.torrent']
    download_path = os.path.expanduser('~/Downloads')

    for target in targets:
        removable.append(glob.glob(os.path.join(download_path, target)))

    if removable:
        logging.log(10, 'Auto Clean Downloads.')
        logging.log(10, 'Will remove: {}'.format(', '.join(removable)))
        # do!! remove
        for tgt in removable:
            shutil.rmtree(tgt)

* Sat 28 Sep 2013 06:24:49 PM JST
'/root/.local/share/Trash/*'
* Sat 28 Sep 2013 06:25:26 PM JST
'/data/.Trash-0/*', '/media/Data/.Trash-0/*'
* Sat 28 Sep 2013 06:25:40 PM JST
Downloads
* Sat 28 Sep 2013 06:25:56 PM JST

* Sat 28 Sep 2013 06:25:56 PM JST

* Sat 28 Sep 2013 06:25:56 PM JST
    if removable:

* Sat 28 Sep 2013 06:26:06 PM JST

* Sat 28 Sep 2013 06:26:06 PM JST

* Sat 28 Sep 2013 06:26:06 PM JST
    loggin

* Sat 28 Sep 2013 06:26:27 PM JST
    for target in targets:
        removable.append(glob.glob(os.path.join(download_path, target)))

* Sat 28 Sep 2013 06:26:37 PM JST
targets
* Sat 28 Sep 2013 06:27:01 PM JST
removable
* Sat 28 Sep 2013 06:27:05 PM JST
removable
* Sat 28 Sep 2013 06:27:15 PM JST

* Sat 28 Sep 2013 06:27:16 PM JST

* Sat 28 Sep 2013 06:27:16 PM JST
    removable = []

* Sat 28 Sep 2013 06:27:35 PM JST

* Sat 28 Sep 2013 06:27:35 PM JST

* Sat 28 Sep 2013 06:27:36 PM JST
        logging.log(10, '* Auto Clean Trush.')

* Sat 28 Sep 2013 06:28:32 PM JST
'Will remove: {}'.format(', '.join(removable))
* Sat 28 Sep 2013 06:31:53 PM JST
'\n\n{0:#^40}'.format(' Clean Downloads ')
* Sat 28 Sep 2013 06:32:46 PM JST
', '.join(removable)
* Sat 28 Sep 2013 06:33:12 PM JST
'Will remove: {}'.format(', '.join(removable))
* Sat 28 Sep 2013 06:33:25 PM JST
'Will remove: {}'.format(', '.join(removable))
* Sat 28 Sep 2013 06:33:40 PM JST

* Sat 28 Sep 2013 06:33:40 PM JST

* Sat 28 Sep 2013 06:33:40 PM JST
        logging.log(10, 'Auto Clean Downloads.')

* Sat 28 Sep 2013 09:21:28 PM JST
sbp.check_call(['/usr/sbin/service', 'vmware', 'start'])
* Sat 28 Sep 2013 09:21:43 PM JST
    try:
        sbp.check_call(['/usr/sbin/service', 'vmware', 'start'])
    except sbp.CalledProcessError as p:
        msg = str(p)
        if p.output:
            msg += '\n\n' + p.output
        easygui.msgbox(msg, 'Failed')
        sys.exit(1)

* Sat 28 Sep 2013 09:21:45 PM JST
start
* Sat 28 Sep 2013 09:24:21 PM JST
d/
* Sat 28 Sep 2013 09:24:22 PM JST
emac
* Sat 28 Sep 2013 10:04:07 PM JST
http://blog.livedoor.jp/dqnplus/archives/1776152.html
* Sat 28 Sep 2013 10:15:59 PM JST
sunday
* Sat 28 Sep 2013 10:16:01 PM JST
sunday
* Sat 28 Sep 2013 11:00:02 PM JST
$$(yas/choose-value '("r" "w" "a" "r+" "rb" "wb" "r+b"))
* Sat 28 Sep 2013 11:00:09 PM JST
b"
* Sat 28 Sep 2013 11:00:10 PM JST
r+b"
* Sat 28 Sep 2013 11:00:10 PM JST
wb" "r+b"
* Sat 28 Sep 2013 11:00:11 PM JST
rb" "wb" "r+b"
* Sat 28 Sep 2013 11:01:20 PM JST

* Sat 28 Sep 2013 11:01:20 PM JST

* Sat 28 Sep 2013 11:01:20 PM JST
import logging

* Sat 28 Sep 2013 11:02:30 PM JST
automyscript
* Sat 28 Sep 2013 11:03:55 PM JST

* Sat 28 Sep 2013 11:03:55 PM JST

* Sat 28 Sep 2013 11:03:55 PM JST
import logging

* Sat 28 Sep 2013 11:03:55 PM JST
import logging

* Sat 28 Sep 2013 11:03:55 PM JST
import logging
import logging

* Sat 28 Sep 2013 11:06:14 PM JST
        
* Sat 28 Sep 2013 11:06:52 PM JST
                    
* Sat 28 Sep 2013 11:25:58 PM JST
'%(asctime)s %(message)s'
* Sat 28 Sep 2013 11:26:34 PM JST
                    
* Sat 28 Sep 2013 11:27:19 PM JST
'%(asctime)s %(message)s'
* Sat 28 Sep 2013 11:32:21 PM JST
hello
* Sat 28 Sep 2013 11:32:24 PM JST
world
* Sat 28 Sep 2013 11:37:51 PM JST
dir(
* Sat 28 Sep 2013 11:40:43 PM JST
logdateformat = '%Y/%m/%d,%H:%M:%S'
* Sat 28 Sep 2013 11:41:41 PM JST

* Sat 28 Sep 2013 11:41:41 PM JST

* Sat 28 Sep 2013 11:41:41 PM JST
import logging

* Sat 28 Sep 2013 11:46:18 PM JST
DEBUG
* Sat 28 Sep 2013 11:47:21 PM JST
# 
* Sat 28 Sep 2013 11:48:05 PM JST
10
* Sat 28 Sep 2013 11:48:32 PM JST
"DEBUG" "INFO" "WARN" "ERROR" "FATAL"
* Sat 28 Sep 2013 11:51:00 PM JST

* Sat 28 Sep 2013 11:51:00 PM JST

* Sat 28 Sep 2013 11:51:00 PM JST
import logging

* Sat 28 Sep 2013 11:58:26 PM JST
height
* Sat 28 Sep 2013 11:58:39 PM JST
About
* Sun 29 Sep 2013 12:01:00 AM JST
NOTSET"
* Sun 29 Sep 2013 12:01:48 AM JST

* Sun 29 Sep 2013 12:01:48 AM JST

* Sun 29 Sep 2013 12:01:49 AM JST
logging.log(20, 'hello')

* Sun 29 Sep 2013 12:04:10 AM JST
f')
* Sun 29 Sep 2013 12:04:57 AM JST
appendp
* Sun 29 Sep 2013 12:11:42 AM JST

* Sun 29 Sep 2013 12:11:42 AM JST

* Sun 29 Sep 2013 12:11:42 AM JST
logformat = '%(asctime)s %(levelname)s %(message)s'

* Sun 29 Sep 2013 12:11:48 AM JST
'%(asctime)s %(levelname)s %(message)s'
* Sun 29 Sep 2013 12:11:51 AM JST

* Sun 29 Sep 2013 12:11:52 AM JST

* Sun 29 Sep 2013 12:11:52 AM JST
logdateformat = '%Y/%m/%d,%H:%M:%S'

* Sun 29 Sep 2013 12:11:55 AM JST
datefmt=logdateformat, 
* Sun 29 Sep 2013 12:13:30 AM JST
name
* Sun 29 Sep 2013 12:13:31 AM JST
file name
* Sun 29 Sep 2013 12:18:20 AM JST

* Sun 29 Sep 2013 12:18:20 AM JST

* Sun 29 Sep 2013 12:18:20 AM JST
n

* Sun 29 Sep 2013 12:19:28 AM JST
`(goto-char (point-min))`
* Sun 29 Sep 2013 12:19:55 AM JST

* Sun 29 Sep 2013 12:19:55 AM JST

* Sun 29 Sep 2013 12:19:55 AM JST
`(py--insert-imports "logging" "import logging")`
* Sun 29 Sep 2013 12:20:23 AM JST
"NOTSET"
* Sun 29 Sep 2013 12:20:48 AM JST

* Sun 29 Sep 2013 12:20:48 AM JST

* Sun 29 Sep 2013 12:20:48 AM JST
import logging

* Sun 29 Sep 2013 12:24:52 AM JST
%(asctime)s	実行時刻
%(filename)s	ファイル名
%(funcName)s	関数名
%(levelname)s	DEBUG、INFO等のレベル名
%(lineno)d	行番号
%(name)s	呼びだしたログの定義名
%(module)s	モジュール名
%(message)s	ログメッセージ
%(process)d	プロセスID
%(thread)d	スレッドID
* Sun 29 Sep 2013 12:25:02 AM JST
asctime
* Sun 29 Sep 2013 12:25:14 AM JST
filename
* Sun 29 Sep 2013 12:25:26 AM JST
funcName
* Sun 29 Sep 2013 12:25:36 AM JST
filename=
* Sun 29 Sep 2013 12:25:40 AM JST
time
* Sun 29 Sep 2013 12:25:45 AM JST
levelname
* Sun 29 Sep 2013 12:25:50 AM JST
lineno
* Sun 29 Sep 2013 12:25:54 AM JST
name
* Sun 29 Sep 2013 12:25:58 AM JST
module
* Sun 29 Sep 2013 12:26:04 AM JST
message
* Sun 29 Sep 2013 12:26:08 AM JST
process
* Sun 29 Sep 2013 12:26:12 AM JST
thread
* Sun 29 Sep 2013 12:27:13 AM JST
# 
* Sun 29 Sep 2013 12:29:50 AM JST
jit-lock-function
* Sun 29 Sep 2013 12:31:03 AM JST
Error during redisplay: (jit-lock-function 662) signaled
* Sun 29 Sep 2013 12:33:10 AM JST
(outshine-match-next-headline 0 outshine-level-1 t)
* Sun 29 Sep 2013 12:35:00 AM JST
font-lock-keyword-face
* Sun 29 Sep 2013 12:35:24 AM JST
font-lock-fontify-keywords-region
* Sun 29 Sep 2013 12:35:38 AM JST

* Sun 29 Sep 2013 12:36:07 AM JST
font-lock-preprocessor-face
* Sun 29 Sep 2013 12:38:38 AM JST

* Sun 29 Sep 2013 12:38:38 AM JST

* Sun 29 Sep 2013 12:38:38 AM JST
import logging

* Sun 29 Sep 2013 12:39:04 AM JST
log
* Sun 29 Sep 2013 12:39:05 AM JST
logging.log
* Sun 29 Sep 2013 12:39:11 AM JST
log
* Sun 29 Sep 2013 12:39:11 AM JST
logging.log
* Sun 29 Sep 2013 12:43:29 AM JST
log'
* Sun 29 Sep 2013 12:48:04 AM JST
char
* Sun 29 Sep 2013 12:50:31 AM JST
00000
* Sun 29 Sep 2013 12:53:13 AM JST
line:%(lineno)5d
* Sun 29 Sep 2013 12:53:25 AM JST
%(funcName)s
* Sun 29 Sep 2013 12:53:31 AM JST
             
* Sun 29 Sep 2013 12:54:01 AM JST
%(module)5s
* Sun 29 Sep 2013 12:54:07 AM JST
%(funcName)s
* Sun 29 Sep 2013 12:57:54 AM JST
%(levelname)-7s
* Sun 29 Sep 2013 12:58:13 AM JST
%(module)s
* Sun 29 Sep 2013 01:06:00 AM JST
%(levelname)-7s
* Sun 29 Sep 2013 01:06:29 AM JST
             
* Sun 29 Sep 2013 01:08:03 AM JST
'%(asctime)s,%(levelname)s,line:%(lineno)d,func:%(funcName)s,'
* Sun 29 Sep 2013 01:08:14 AM JST
'mod:%(module)s,%(message)s'
* Sun 29 Sep 2013 01:15:36 AM JST
logging.basicConfig
* Sun 29 Sep 2013 01:17:49 AM JST
logformat = ('%(asctime)s,%(levelname)s,line:%(lineno)d,func:%(funcName)s,'
             'mod:%(module)s,%(message)s')

* Sun 29 Sep 2013 01:17:52 AM JST
logformat = ('%(asctime)s,%(levelname)s,line:%(lineno)d,func:%(funcName)s,'
             'mod:%(module)s,%(message)s')

* Sun 29 Sep 2013 01:18:02 AM JST
logging.basicConfig
* Sun 29 Sep 2013 01:18:41 AM JST
# asctime, filename, funcName, levelname, lineno, name,
# module, message, process, thread

* Sun 29 Sep 2013 01:18:51 AM JST
logging.basicConfig
* Sun 29 Sep 2013 01:19:41 AM JST

* Sun 29 Sep 2013 01:19:41 AM JST

* Sun 29 Sep 2013 01:19:41 AM JST
import logging

* Sun 29 Sep 2013 01:20:13 AM JST
LEVEL
* Sun 29 Sep 2013 01:20:20 AM JST
# asctime, filename, funcName, levelname, lineno, name,
# module, message, process, thread
logformat = ('%(asctime)s,%(levelname)s,line:%(lineno)d,func:%(funcName)s,'
               'mod:%(module)s,%(message)s')

* Sun 29 Sep 2013 01:21:04 AM JST

* Sun 29 Sep 2013 01:21:04 AM JST

* Sun 29 Sep 2013 01:21:04 AM JST
import os

* Sun 29 Sep 2013 01:21:13 AM JST
logging.basicConfig
* Sun 29 Sep 2013 01:21:39 AM JST
${2:$$(yas/choose-value '("r" "w" "a" "r+" "rb" "wb" "r+b"))}
* Sun 29 Sep 2013 01:22:52 AM JST
`(py--insert-imports "logging" "import logging")`# define logging
logname = ${1:NAME}
logdir = ${2:'/var/log'}
logpath = `(cond ((save-excursion
         (goto-char (point-min))
         (re-search-forward "import[ \t]+os[ \t]+as[ \t]+_os" nil 'noerror))
       (insert "_os"))
      ((save-excursion
         (goto-char (point-min))
         (re-search-forward "import[ \t]+os" nil 'noerror)) (insert "os"))
      (t (py--insert-imports "os" "import os")))`.path.join(logdir, logname)
# asctime, filename, funcName, levelname, lineno, name,
# module, message, process, thread
logformat = ('%(asctime)s,%(levelname)s,line:%(lineno)d,func:%(funcName)s,'
             'mod:%(module)s,%(message)s')
logging.basicConfig(filename=logpath, level=logging.${3:$$(yas/choose-value '("NOTSET" "DEBUG" "INFO" "WARN" "ERROR" "FATAL"))}, filemode='${4:$$(yas/choose-value '("w" "a"))}',
                    format=logformat)


* Sun 29 Sep 2013 01:24:17 AM JST
logging.basicConfig
* Sun 29 Sep 2013 01:24:20 AM JST
# define log file name
# logname = 'weekly.log'
# logdir = '/var/log'
# logpath = os.path.join(logdir, logname)
# logging.basicConfig(filename=logpath, level=logging.DEBUG, filemode='w',
#                     format='%(asctime)s %logging.basicConfig(message)s')


* Sun 29 Sep 2013 01:25:07 AM JST
logging.basicConfig
* Sun 29 Sep 2013 01:29:17 AM JST
(re-search-forward "import[ \t]+os[ \t]+as[ \t]+_os" nil 'noerror)
* Sun 29 Sep 2013 01:29:54 AM JST
(re-search-forward "global" nil 'noerror)
* Sun 29 Sep 2013 01:30:25 AM JST
'noerror
* Sun 29 Sep 2013 01:35:33 AM JST
py--import-region
* Sun 29 Sep 2013 01:39:58 AM JST
(cond ((save-excursion
                   (goto-char (point-min))
         (re-search-forward "import[ \t]+os[ \t]+as[ \t]+_os" nil 'noerror))
       (insert "_os"))
      ((save-excursion
         (goto-char (point-min))
         (re-search-forward "import[ \t]+os" nil 'noerror)) (insert "os"))
      (t (py--insert-imports "os" "import os")))
* Sun 29 Sep 2013 01:40:13 AM JST
save-excursion
* Sun 29 Sep 2013 01:40:25 AM JST
         
* Sun 29 Sep 2013 01:40:58 AM JST
save-excursion
* Sun 29 Sep 2013 01:41:02 AM JST
           
* Sun 29 Sep 2013 01:41:53 AM JST
(save-excursion
  (cond ((progn (goto-char (point-min))
                (re-search-forward "import[ \t]+os[ \t]+as[ \t]+_os" nil 'noerror))
         (insert "_os"))
        ((progn (goto-char (point-min))
                (re-search-forward "import[ \t]+os" nil 'noerror))
         (insert "os"))
        (t (py--insert-imports "os" "import os"))))
* Sun 29 Sep 2013 01:43:42 AM JST
(cond ((save-excursion
                   (goto-char (point-min))
         (re-search-forward "import[ \t]+os[ \t]+as[ \t]+_os" nil 'noerror))
       (insert "_os"))
      ((save-excursion
         (goto-char (point-min))
         (re-search-forward "import[ \t]+os" nil 'noerror)) (insert "os"))
      (t (py--insert-imports "os" "import os")))
* Sun 29 Sep 2013 01:43:51 AM JST
         
* Sun 29 Sep 2013 01:44:28 AM JST
region 
* Sun 29 Sep 2013 01:44:28 AM JST
to-region 
* Sun 29 Sep 2013 01:44:29 AM JST
nallow-to-region 
* Sun 29 Sep 2013 01:44:47 AM JST
(na)
* Sun 29 Sep 2013 01:45:10 AM JST
(py--import-region)
* Sun 29 Sep 2013 01:46:36 AM JST

* Sun 29 Sep 2013 01:46:36 AM JST

* Sun 29 Sep 2013 01:46:36 AM JST
(narrow-to-region )

* Sun 29 Sep 2013 01:47:05 AM JST
(cond ((save-excursion
         (goto-char (point-min))
         (re-search-forward "import[ \t]+os[ \t]+as[ \t]+_os" nil 'noerror))
       (insert "_os"))
      ((save-excursion
         (goto-char (point-min))
         (re-search-forward "import[ \t]+os" nil 'noerror)) (insert "os"))
      (t (py--insert-imports "os" "import os")))
* Sun 29 Sep 2013 01:47:16 AM JST
    
* Sun 29 Sep 2013 01:47:18 AM JST
  
* Sun 29 Sep 2013 01:47:21 AM JST
(let* ((region (py--import-region))
       (start (car region))
       (end (cdr region)))
  (save-restriction
    (narrow-to-region start end)
    (cond ((save-excursion
             (goto-char (point-min))
             (re-search-forward "import[ \t]+os[ \t]+as[ \t]+_os" nil 'noerror))
           (insert "_os"))
          ((save-excursion
             (goto-char (point-min))
             (re-search-forward "import[ \t]+os" nil 'noerror)) (insert "os"))
          (t (py--insert-imports "os" "import os")))))
* Sun 29 Sep 2013 01:48:08 AM JST

* Sun 29 Sep 2013 01:48:08 AM JST

* Sun 29 Sep 2013 01:48:08 AM JST
import logging

* Sun 29 Sep 2013 01:48:50 AM JST

* Sun 29 Sep 2013 01:48:50 AM JST

* Sun 29 Sep 2013 01:48:50 AM JST
  (save-restriction

* Sun 29 Sep 2013 01:48:56 AM JST

* Sun 29 Sep 2013 01:48:56 AM JST

* Sun 29 Sep 2013 01:48:56 AM JST
    (narrow-to-region start end)

* Sun 29 Sep 2013 01:49:42 AM JST
             (save-restriction
               (narrow-to-region start end)

* Sun 29 Sep 2013 01:50:32 AM JST
(let* ((region (py--import-region))
       (start (car region))
       (end (cdr region)))
    (cond ((save-excursion
             (save-restriction
               (narrow-to-region start end)
               (goto-char (point-min))
               (re-search-forward "import[ \t]+os[ \t]+as[ \t]+_os" nil 'noerror)))
           (insert "_os"))
          ((save-excursion
             (save-restriction
               (narrow-to-region start end)
               (goto-char (point-min))
               (re-search-forward "import[ \t]+os" nil 'noerror)) (insert "os")))
           (t (py--insert-imports "os" "import os"))))
* Sun 29 Sep 2013 01:51:20 AM JST

* Sun 29 Sep 2013 01:51:20 AM JST

* Sun 29 Sep 2013 01:51:20 AM JST
import logging

* Sun 29 Sep 2013 01:52:01 AM JST

* Sun 29 Sep 2013 01:52:01 AM JST

* Sun 29 Sep 2013 01:52:02 AM JST
import logging

* Sun 29 Sep 2013 01:54:59 AM JST
`(save-excursion (save-restriction
(cond ((save-excursion
         (goto-char (point-min))
         (re-search-forward "import[ \t]+os[ \t]+as[ \t]+_os" nil 'noerror))
       (insert "_os"))
      ((save-excursion
         (goto-char (point-min))
         (re-search-forward "import[ \t]+os" nil 'noerror)) (insert "os"))
      (t (py--insert-imports "os" "import os")))))`
* Sun 29 Sep 2013 01:57:24 AM JST
isearch-query-replace
* Sun 29 Sep 2013 01:58:06 AM JST
replace-string
* Sun 29 Sep 2013 01:58:45 AM JST
(replace-string "WILLREPLACE" "os")
* Sun 29 Sep 2013 01:59:24 AM JST

os




(save-excursion
  (cond ((progn (goto-char (point-min))
                (re-search-forward "import[ \t]+os[ \t]+as[ \t]+_os" nil 'noerror))
         (insert "_os"))
        ((progn (goto-char (point-min))
                (re-search-forward "import[ \t]+os" nil 'noerror))
         (insert "os"))
        (t (py--insert-imports "os" "import os"))))



(cond ((save-excursion
         (goto-char (point-min))
         (re-search-forward "import[ \t]+os[ \t]+as[ \t]+_os" nil 'noerror))
       (insert "_os"))
      ((save-excursion
         (goto-char (point-min))
         (re-search-forward "import[ \t]+os" nil 'noerror)) (insert "os"))
      (t (py--insert-imports "os" "import os")))

(let* ((region (py--import-region))
       (start (car region))
       (end (cdr region)))
    (cond ((save-excursion
             (save-restriction
               (narrow-to-region start end)
               (goto-char (point-min))
               (re-search-forward "import[ \t]+os[ \t]+as[ \t]+_os" nil 'noerror)))
           (insert "_os"))
          ((save-excursion
             (save-restriction
               (narrow-to-region start end)
               (goto-char (point-min))
               (re-search-forward "import[ \t]+os" nil 'noerror)) (insert "os")))
           (t (py--insert-imports "os" "import os"))))







(isearch-query-replace )

(replace-string "os" "os")







* Sun 29 Sep 2013 01:59:58 AM JST
(replace-string "WILLREPLACE" "os")
* Sun 29 Sep 2013 02:02:25 AM JST
        (re-search-backward "WILLREPLACE" nil 'noerror)
        (goto-char (match-start 0)) 
       (replace-string "WILLREPLACE" "_os"))

* Sun 29 Sep 2013 02:02:39 AM JST
(insert "os")
* Sun 29 Sep 2013 02:02:40 AM JST
         (insert "os")
* Sun 29 Sep 2013 02:03:28 AM JST
(re-search-backward "WILLREPLACE" nil 'noerror)
        (goto-char (match-start 0)) 
       (replace-string "WILLREPLACE" "_os")
* Sun 29 Sep 2013 02:12:41 AM JST
weekly
* Sun 29 Sep 2013 02:16:47 AM JST
after
* Sun 29 Sep 2013 02:21:37 AM JST
point.
* Sun 29 Sep 2013 02:24:04 AM JST
WILLREPLACE
* Sun 29 Sep 2013 02:24:32 AM JST
(py--insert-imports "os" "import os")
* Sun 29 Sep 2013 02:26:29 AM JST
# asctime, filename, funcName, levelname, lineno, name,
# module, message, process, thread
logformat = ('%(asctime)s,%(levelname)s,line:%(lineno)d,func:%(funcName)s,'
               'mod:%(module)s,%(message)s')

* Sun 29 Sep 2013 02:39:20 AM JST
line-end-position
* Sun 29 Sep 2013 02:39:35 AM JST
(line-end-position)
* Sun 29 Sep 2013 02:39:55 AM JST
line-end-position
* Sun 29 Sep 2013 02:42:21 AM JST
(require 'cl)
* Sun 29 Sep 2013 02:44:04 AM JST
logging.basicConfig
* Sun 29 Sep 2013 02:44:16 AM JST
`(progn (py--insert-imports "logging" "import logging")
(py--insert-imports "os" "import os"))`
* Sun 29 Sep 2013 02:44:20 AM JST
`(progn (py--insert-imports "logging" "import logging")
(py--insert-imports "os" "import os"))`
* Sun 29 Sep 2013 02:45:06 AM JST
logging.basicConfig
* Sun 29 Sep 2013 02:45:48 AM JST
basicConfig
* Sun 29 Sep 2013 02:45:48 AM JST
logging.basicConfig
* Sun 29 Sep 2013 02:46:49 AM JST
logging_basicConfig
* Sun 29 Sep 2013 02:47:29 AM JST
logging_basicConfig
* Sun 29 Sep 2013 02:48:37 AM JST
logging_basicConfig
* Sun 29 Sep 2013 02:50:13 AM JST
# (yas/expand-link "argparse_add_argument" t)
* Sun 29 Sep 2013 02:51:31 AM JST
${3:$$(yas/choose-value '("NOTSET" "DEBUG" "INFO" "WARN" "ERROR" "FATAL"))}
* Sun 29 Sep 2013 02:52:23 AM JST
# (yas/expand-link "argparse_add_argument" t)$0
* Sun 29 Sep 2013 02:53:06 AM JST
Config
* Sun 29 Sep 2013 02:56:35 AM JST
sbp.Popen()
* Sun 29 Sep 2013 02:57:00 AM JST
CMD.get('google-chrome')
* Sun 29 Sep 2013 03:01:09 AM JST
INFO
* Sun 29 Sep 2013 03:05:59 AM JST

* Sun 29 Sep 2013 03:05:59 AM JST

* Sun 29 Sep 2013 03:06:00 AM JST
    # os.system('{0} {1}'.format(CMD.get('google-chrome'), url))

* Sun 29 Sep 2013 03:07:53 AM JST
result.group()
* Sun 29 Sep 2013 03:08:05 AM JST
str_
* Sun 29 Sep 2013 03:11:10 AM JST
result.group()
* Sun 29 Sep 2013 03:11:15 AM JST

* Sun 29 Sep 2013 03:11:15 AM JST

* Sun 29 Sep 2013 03:11:15 AM JST
        str_ = 

* Sun 29 Sep 2013 03:11:15 AM JST
        str_ = 

* Sun 29 Sep 2013 03:11:15 AM JST
        str_ = 
        if str_.startswith('"'):

* Sun 29 Sep 2013 03:11:15 AM JST
        str_ = 
        if str_.startswith('"'):

* Sun 29 Sep 2013 03:11:15 AM JST
        str_ = 
        if str_.startswith('"'):
            str_ = str[1:]

* Sun 29 Sep 2013 03:11:15 AM JST
        str_ = 
        if str_.startswith('"'):
            str_ = str[1:]

* Sun 29 Sep 2013 03:11:16 AM JST
        str_ = 
        if str_.startswith('"'):
            str_ = str[1:]
        if str_.endswith('"'):

* Sun 29 Sep 2013 03:11:16 AM JST
        str_ = 
        if str_.startswith('"'):
            str_ = str[1:]
        if str_.endswith('"'):

* Sun 29 Sep 2013 03:11:16 AM JST
        str_ = 
        if str_.startswith('"'):
            str_ = str[1:]
        if str_.endswith('"'):
            str_ = str[0:-1]

* Sun 29 Sep 2013 03:11:16 AM JST
        str_ = 
        if str_.startswith('"'):
            str_ = str[1:]
        if str_.endswith('"'):
            str_ = str[0:-1]

* Sun 29 Sep 2013 03:11:16 AM JST
        str_ = 
        if str_.startswith('"'):
            str_ = str[1:]
        if str_.endswith('"'):
            str_ = str[0:-1]
        return result.group()

* Sun 29 Sep 2013 03:13:47 AM JST
format(
* Sun 29 Sep 2013 03:13:47 AM JST
openchrome('"{}"'.format(
* Sun 29 Sep 2013 03:19:00 AM JST
DEBUG
* Sun 29 Sep 2013 03:19:03 AM JST
DEBUG
* Sun 29 Sep 2013 03:21:43 AM JST
system
* Sun 29 Sep 2013 03:21:43 AM JST
os.system
* Sun 29 Sep 2013 03:23:22 AM JST

* Sun 29 Sep 2013 03:23:22 AM JST

* Sun 29 Sep 2013 03:23:22 AM JST
        # move right window if window on left.

* Sun 29 Sep 2013 03:23:32 AM JST
window
* Sun 29 Sep 2013 03:23:44 AM JST
  if window on left.
* Sun 29 Sep 2013 03:26:37 AM JST

* Sun 29 Sep 2013 03:26:37 AM JST

* Sun 29 Sep 2013 03:26:37 AM JST
        sleep(3)

* Sun 29 Sep 2013 03:29:04 AM JST
    sbp.Popen([SIKULI.get('binpath'), SIKULI.get('runopt'),
               SKL_FILE.get('sleipnir_rss')])

* Sun 29 Sep 2013 03:30:25 AM JST

* Sun 29 Sep 2013 03:30:25 AM JST

* Sun 29 Sep 2013 03:30:25 AM JST
    # os.system(SIKULI.get('exeformat').format(SKL_FILE.get('sleipnir_rss')))

* Sun 29 Sep 2013 03:33:00 AM JST
    # kill update dialog if exists
    if wm.exists(confirm=spnir_dialog_confirm):
        win = wm.getwin(confirm=spnir_dialog_confirm)
        win.close()


* Sun 29 Sep 2013 03:36:02 AM JST

* Sun 29 Sep 2013 03:36:02 AM JST

* Sun 29 Sep 2013 03:36:02 AM JST
        sleep(5)

* Sun 29 Sep 2013 03:38:46 AM JST
from mytemp.mypsutil import psexists
* Sun 29 Sep 2013 03:39:58 AM JST
    if not psexists(SLEIPNIR.get('bin')):
        sbp.Popen([SLEIPNIR.get('launcher')])

* Sun 29 Sep 2013 03:42:01 AM JST
ref.CMD.sleipnir
* Sun 29 Sep 2013 03:43:19 AM JST

* Sun 29 Sep 2013 03:43:19 AM JST

* Sun 29 Sep 2013 03:43:19 AM JST
from ref.CMD.sleipnir import SLEIPNIR

* Sun 29 Sep 2013 03:43:20 AM JST

* Sun 29 Sep 2013 03:43:20 AM JST

* Sun 29 Sep 2013 03:43:20 AM JST
from mytemp.mypsutil import psexists

* Sun 29 Sep 2013 03:43:26 AM JST
CMD.
* Sun 29 Sep 2013 03:43:27 AM JST
ref.CMD.
* Sun 29 Sep 2013 03:43:41 AM JST
import
* Sun 29 Sep 2013 03:46:02 AM JST
    if wm.WinWait(sec=180).win(title='Sleipnir') is True:
        win = wm.getwin(title='Sleipnir')
        if win.ismaximize():
            win.reset_maximize()
        win.move(x=1280, y=0)
        win.maximize()

* Sun 29 Sep 2013 03:47:59 AM JST
    if wm.exists(confirm=spnir_dialog_confirm):
        win = wm.getwin(confirm=spnir_dialog_confirm)
        win.close()

* Sun 29 Sep 2013 03:48:12 AM JST
    def spnir_dialog_confirm(win, **args):
        r"""SUMMARY

        @Arguments:
        - `win`:

        @Return:
        """
        if 'Sleipnir' == win.title and 'Dialog' == win.type:
            return True
        return False


* Sun 29 Sep 2013 03:48:26 AM JST
def killdialog():
    r"""SUMMARY
    
    @Return:
    """
    def spnir_dialog_confirm(win, **args):
        r"""SUMMARY

        @Arguments:
        - `win`:

        @Return:
        """
        if 'Sleipnir' == win.title and 'Dialog' == win.type:
            return True
        return False

    if wm.exists(confirm=spnir_dialog_confirm):
        win = wm.getwin(confirm=spnir_dialog_confirm)
        win.close()



* Sun 29 Sep 2013 03:48:49 AM JST
    
* Sun 29 Sep 2013 03:49:19 AM JST

* Sun 29 Sep 2013 03:49:19 AM JST

* Sun 29 Sep 2013 03:49:19 AM JST
    # kill update dialog if exists

* Sun 29 Sep 2013 03:52:13 AM JST
sikuli 
* Sun 29 Sep 2013 03:53:21 AM JST

* Sun 29 Sep 2013 03:53:22 AM JST

* Sun 29 Sep 2013 03:53:22 AM JST
    logging.log(logging.INFO, '* Do ')

* Sun 29 Sep 2013 03:55:11 AM JST
'Google-chrome'
* Sun 29 Sep 2013 03:55:21 AM JST

* Sun 29 Sep 2013 03:55:21 AM JST

* Sun 29 Sep 2013 03:55:21 AM JST
            if w.klass[1] == 'Google-chrome':

* Sun 29 Sep 2013 03:56:16 AM JST
folder
* Sun 29 Sep 2013 03:56:27 AM JST
'【天気】'.decode('UTF-8')
* Sun 29 Sep 2013 03:56:37 AM JST
                                
* Sun 29 Sep 2013 03:58:14 AM JST
window
* Sun 29 Sep 2013 03:58:14 AM JST
chrome window
* Sun 29 Sep 2013 03:58:16 AM JST
All chrome window
* Sun 29 Sep 2013 04:02:01 AM JST
logging.log(logging.DEBUG, 'before exists window ids: {}'.format(beforeids))
* Sun 29 Sep 2013 04:02:05 AM JST
before
* Sun 29 Sep 2013 04:02:11 AM JST
before
* Sun 29 Sep 2013 04:02:33 AM JST

* Sun 29 Sep 2013 04:02:33 AM JST

* Sun 29 Sep 2013 04:02:33 AM JST
        logging.log(logging.DEBUG, 'after exists window ids: {}'.format(afterids))

* Sun 29 Sep 2013 04:02:46 AM JST
exists 
* Sun 29 Sep 2013 04:02:50 AM JST
exists 
* Sun 29 Sep 2013 04:03:39 AM JST
'Google-chrome'
* Sun 29 Sep 2013 04:03:46 AM JST

* Sun 29 Sep 2013 04:03:46 AM JST

* Sun 29 Sep 2013 04:03:46 AM JST
        if win.klass[1] == 'Google-chrome':

* Sun 29 Sep 2013 04:04:58 AM JST
not
* Sun 29 Sep 2013 04:10:34 AM JST
result
* Sun 29 Sep 2013 04:11:04 AM JST

* Sun 29 Sep 2013 04:11:04 AM JST

* Sun 29 Sep 2013 04:11:04 AM JST
        result.append(win.id) # 

* Sun 29 Sep 2013 04:11:06 AM JST

* Sun 29 Sep 2013 04:11:06 AM JST

* Sun 29 Sep 2013 04:11:06 AM JST
    result = []

* Sun 29 Sep 2013 04:15:07 AM JST

* Sun 29 Sep 2013 04:15:07 AM JST

* Sun 29 Sep 2013 04:15:07 AM JST
    logging.log(logging.INFO, 'Default weather page open.')

* Sun 29 Sep 2013 04:15:14 AM JST

* Sun 29 Sep 2013 04:15:14 AM JST

* Sun 29 Sep 2013 04:15:14 AM JST
    bmfolder = '【天気】'.decode('UTF-8')

* Sun 29 Sep 2013 04:15:18 AM JST

* Sun 29 Sep 2013 04:15:18 AM JST

* Sun 29 Sep 2013 04:15:18 AM JST
    logging.log(logging.INFO, 'Default weather page open.')

* Sun 29 Sep 2013 04:15:23 AM JST
Default
* Sun 29 Sep 2013 04:15:26 AM JST
weather
* Sun 29 Sep 2013 04:17:21 AM JST

* Sun 29 Sep 2013 04:17:21 AM JST

* Sun 29 Sep 2013 04:17:21 AM JST
    print('DEBUG-1-daily.py')

* Sun 29 Sep 2013 04:25:16 AM JST
)
* Sun 29 Sep 2013 04:27:26 AM JST
append
* Sun 29 Sep 2013 04:28:17 AM JST
set(
* Sun 29 Sep 2013 04:34:26 AM JST


* Sun 29 Sep 2013 04:34:53 AM JST
WinWait = wm.
* Sun 29 Sep 2013 04:35:13 AM JST
WinWait().
* Sun 29 Sep 2013 04:35:14 AM JST
wm.WinWait().
* Sun 29 Sep 2013 04:35:24 AM JST

* Sun 29 Sep 2013 04:35:24 AM JST

* Sun 29 Sep 2013 04:35:24 AM JST
        # if not wm.exists(wid=ids[0]):

* Sun 29 Sep 2013 04:43:53 AM JST
Please 
* Sun 29 Sep 2013 04:44:32 AM JST
window
* Sun 29 Sep 2013 04:47:29 AM JST
import
* Sun 29 Sep 2013 05:01:21 AM JST
kinter
* Sun 29 Sep 2013 05:03:08 AM JST
hello
* Sun 29 Sep 2013 05:03:16 AM JST
title
* Sun 29 Sep 2013 05:03:21 AM JST
Dialog
* Sun 29 Sep 2013 05:03:40 AM JST
"+300+200"
* Sun 29 Sep 2013 05:04:12 AM JST
minsize(400, 100)
* Sun 29 Sep 2013 05:06:16 AM JST
wm_maxsize
* Sun 29 Sep 2013 05:08:33 AM JST

* Sun 29 Sep 2013 05:08:33 AM JST

* Sun 29 Sep 2013 05:08:33 AM JST
import easygui

* Sun 29 Sep 2013 05:14:20 AM JST

* Sun 29 Sep 2013 05:14:20 AM JST

* Sun 29 Sep 2013 05:14:20 AM JST

* Sun 29 Sep 2013 05:14:20 AM JST

* Sun 29 Sep 2013 05:16:35 AM JST
pass 
* Sun 29 Sep 2013 05:16:45 AM JST
    
* Sun 29 Sep 2013 05:17:30 AM JST
None
* Sun 29 Sep 2013 05:22:20 AM JST
Popen
* Sun 29 Sep 2013 05:22:32 AM JST
Popen
* Sun 29 Sep 2013 05:22:57 AM JST
retcode = 
* Sun 29 Sep 2013 05:23:36 AM JST
[CMD.get('google-chrome')] + options + list(url)
* Sun 29 Sep 2013 05:23:42 AM JST

* Sun 29 Sep 2013 05:23:42 AM JST

* Sun 29 Sep 2013 05:23:42 AM JST
    cmdlist = 

* Sun 29 Sep 2013 05:26:19 AM JST

* Sun 29 Sep 2013 05:26:19 AM JST

* Sun 29 Sep 2013 05:26:19 AM JST
from mygoogle.chrome import ChromeBMParse

* Sun 29 Sep 2013 05:26:46 AM JST
open
* Sun 29 Sep 2013 05:27:43 AM JST
open
* Sun 29 Sep 2013 05:29:08 AM JST
open
* Sun 29 Sep 2013 05:30:17 AM JST

* Sun 29 Sep 2013 05:30:17 AM JST

* Sun 29 Sep 2013 05:30:17 AM JST
        chrome.open()

* Sun 29 Sep 2013 05:30:51 AM JST

* Sun 29 Sep 2013 05:30:51 AM JST

* Sun 29 Sep 2013 05:30:51 AM JST
        logging.log(logging.DEBUG, 'chrome open {}'.format(url))

* Sun 29 Sep 2013 05:33:38 AM JST
chrome.ChromeBMParse(bmfolder)
* Sun 29 Sep 2013 05:34:06 AM JST
count
* Sun 29 Sep 2013 05:34:36 AM JST
count
* Sun 29 Sep 2013 05:36:08 AM JST
def weather():

    geos = [(200, 120, 700, 880), # left display
            (1280, 370, 675, 560), # left down
            (1840, 370, 675, 560), # middle down
            (2400, 370, 675, 560), # right down
            (1840, -100, 575, 560), # middle up
            (2400, -100, 575, 560), # right up
            (1280, -100, 575, 560), # left up
            ]

    def chromewinids():
        r"""SUMMARY

        @Return:
        """
        idlist = []
        for w in wm.iter_matchwin(klass='Google-chrome'):
            idlist.append(w.id)
        return idlist

    bmfolder = '【天気】'.decode('UTF-8')
    logging.log(logging.INFO, '{} page open.'.format(bmfolder))
    # WARNING: (Atami) [2013/09/29]
    # for compare after windows because not get utf-8 window title.
    beforeids = set(chromewinids())
    logging.log(logging.DEBUG, 'before window ids: {}'.format(list(beforeids)))

    urls = list(chrome.ChromeBMParse(bmfolder))

    # for count, url in enumerate(chrome.ChromeBMParse(bmfolder), start=1):
        # urls.append(url)
        # sbp.Popen([CMD.get('google-chrome'), '--new-window', url])
    chrome.open(urls)
    logging.log(logging.DEBUG, 'chrome open {}'.format(urls))
    logging.log(logging.DEBUG, 'Opened chrome window {}'.format(len(urls)))

    # wait all open
    while 1:
        afterids = set(chromewinids())
        if len(urls) <= (len(afterids) - len(beforeids)):
            logging.log(logging.DEBUG, 'after window ids: {}'.format(list(afterids)))
            break
        sleep(2)

    banids = beforeids
    for win in wm.iter_matchwin(klass='Google-chrome'):
        if win.id in banids:
            continue
        banids.add(win.id) # ban id
        if not geos:
            x, y, h, w = 200, 120, 700, 880
        else:
            x, y, h, w = geos.pop(0)
        win.move(x=x, y=y, height=h, width=w)
    return list(beforeids.difference(afterids))

* Sun 29 Sep 2013 05:37:11 AM JST
logname = 'daily.log'
logdir = '/var/log'
logpath = os.path.join(logdir, logname)

* Sun 29 Sep 2013 05:37:17 AM JST
logformat = ('%(asctime)s,%(levelname)s,line:%(lineno)d,func:%(funcName)s,'
             'mod:%(module)s,%(message)s')
logging.basicConfig(filename=logpath, level=logging.INFO, filemode='w',
                    format=logformat)

* Sun 29 Sep 2013 05:40:58 AM JST
list(chrome.ChromeBMParse(season))
* Sun 29 Sep 2013 05:41:07 AM JST

* Sun 29 Sep 2013 05:41:07 AM JST

* Sun 29 Sep 2013 05:41:07 AM JST
        urls = []

* Sun 29 Sep 2013 05:41:07 AM JST
        urls = []

* Sun 29 Sep 2013 05:41:08 AM JST
        urls = []
        for url in :

* Sun 29 Sep 2013 05:41:08 AM JST
        urls = []
        for url in :

* Sun 29 Sep 2013 05:41:08 AM JST
        urls = []
        for url in :
            urls.append(u)

* Sun 29 Sep 2013 05:42:58 AM JST
[CMD.get('google-chrome')] + list(options) + list(url)
* Sun 29 Sep 2013 05:44:20 AM JST
list(chrome.ChromeBMParse(season))
* Sun 29 Sep 2013 05:47:53 AM JST
open
* Sun 29 Sep 2013 05:47:56 AM JST

* Sun 29 Sep 2013 05:47:56 AM JST

* Sun 29 Sep 2013 05:47:56 AM JST
    print([CMD.get('google-chrome')] + list(options) + url)

* Sun 29 Sep 2013 05:48:15 AM JST
list(chrome.ChromeBMParse(season))
* Sun 29 Sep 2013 05:48:19 AM JST

* Sun 29 Sep 2013 05:48:19 AM JST

* Sun 29 Sep 2013 05:48:19 AM JST
        urls = 

* Sun 29 Sep 2013 05:48:19 AM JST
        urls = 

* Sun 29 Sep 2013 05:48:19 AM JST
        urls = 
        print(urls)

* Sun 29 Sep 2013 05:48:27 AM JST
open
* Sun 29 Sep 2013 05:48:33 AM JST
open
* Sun 29 Sep 2013 05:48:36 AM JST
open
* Sun 29 Sep 2013 05:48:40 AM JST
open
* Sun 29 Sep 2013 05:49:30 AM JST
.decode('UTF-8')
* Sun 29 Sep 2013 05:49:57 AM JST
list(chrome.ChromeBMParse(bmfolder.decode('UTF-8')))
* Sun 29 Sep 2013 05:50:43 AM JST
chrome.ChromeBMParse(folder)
* Sun 29 Sep 2013 06:00:15 AM JST
list(
* Sun 29 Sep 2013 06:03:11 AM JST
ListType
* Sun 29 Sep 2013 06:03:56 AM JST
list(
* Sun 29 Sep 2013 06:07:15 AM JST
call
* Sun 29 Sep 2013 06:12:48 AM JST
INFO
* Sun 29 Sep 2013 06:16:39 AM JST
afterids
* Sun 29 Sep 2013 06:16:44 AM JST
beforeids
* Sun 29 Sep 2013 06:19:10 AM JST
difference
* Sun 29 Sep 2013 06:20:17 AM JST
set(
* Sun 29 Sep 2013 06:23:09 AM JST
list(set(afterids) - set(beforeids))
* Sun 29 Sep 2013 06:24:32 AM JST
set(
* Sun 29 Sep 2013 06:24:47 AM JST
list(
* Sun 29 Sep 2013 06:25:10 AM JST
set(
* Sun 29 Sep 2013 06:26:06 AM JST
list(
* Sun 29 Sep 2013 06:30:58 AM JST

* Sun 29 Sep 2013 06:30:58 AM JST

* Sun 29 Sep 2013 06:30:58 AM JST
    print(beforeids)

* Sun 29 Sep 2013 06:31:43 AM JST

* Sun 29 Sep 2013 06:31:44 AM JST

* Sun 29 Sep 2013 06:31:44 AM JST
    print(afterids)

* Sun 29 Sep 2013 06:35:28 AM JST

* Sun 29 Sep 2013 06:35:29 AM JST

* Sun 29 Sep 2013 06:35:29 AM JST
    print(list(set(afterids) - set(beforeids)))

* Sun 29 Sep 2013 06:35:31 AM JST

* Sun 29 Sep 2013 06:35:31 AM JST

* Sun 29 Sep 2013 06:35:31 AM JST
    print(list(set(afterids) - set(beforeids)))

* Sun 29 Sep 2013 06:37:39 AM JST
windows
* Sun 29 Sep 2013 06:37:53 AM JST
after
* Sun 29 Sep 2013 06:38:29 AM JST
chrome.ChromeBMParse(bmfolder.decode('UTF-8'))
* Sun 29 Sep 2013 06:38:33 AM JST

* Sun 29 Sep 2013 06:38:33 AM JST

* Sun 29 Sep 2013 06:38:33 AM JST
    urls = list()

* Sun 29 Sep 2013 06:39:25 AM JST
window
* Sun 29 Sep 2013 06:39:25 AM JST
chrome window
* Sun 29 Sep 2013 06:39:51 AM JST
urls
* Sun 29 Sep 2013 06:40:41 AM JST
len(urls)
* Sun 29 Sep 2013 06:40:54 AM JST

* Sun 29 Sep 2013 06:40:54 AM JST

* Sun 29 Sep 2013 06:40:54 AM JST
    logging.log(logging.DEBUG, 'Opened window num {}'.format())

* Sun 29 Sep 2013 06:41:09 AM JST
        
* Sun 29 Sep 2013 06:41:49 AM JST
append
* Sun 29 Sep 2013 06:41:49 AM JST
idlist.append
* Sun 29 Sep 2013 06:41:55 AM JST

* Sun 29 Sep 2013 06:41:55 AM JST

* Sun 29 Sep 2013 06:41:55 AM JST
        return idlist

* Sun 29 Sep 2013 06:41:56 AM JST

* Sun 29 Sep 2013 06:41:56 AM JST

* Sun 29 Sep 2013 06:41:56 AM JST
        idlist = []

* Sun 29 Sep 2013 07:03:02 AM JST
http://staff.science.uva.nl/~dominik/Tools/outline-magic.el
* Sun 29 Sep 2013 07:06:46 AM JST
(defun py-outline-level ()
  (let (buffer-invisibility-spec)
    (save-excursion
      (skip-chars-forward "    ")
      (current-column))))
* Sun 29 Sep 2013 07:07:03 AM JST
(add-hook 'outline-minor-mode-hook 
           (lambda () 
             (require 'outline-magic)
))
* Sun 29 Sep 2013 07:08:05 AM JST
(setq outline-regexp "[ \t]*# \\|[ \t]+\\(class\\|def\\|if\\|elif\\|else\\|while\\|for\\|try\\|except\\|with\\) ")
  (setq outline-level 'py-outline-level)

  (outline-minor-mode t)
  (hide-body)
  (show-paren-mode 1)
* Sun 29 Sep 2013 07:10:53 AM JST
(add-hook 'python-mode-hook 'my-python-outline-hook)
* Sun 29 Sep 2013 03:59:19 PM JST
line-
* Sun 29 Sep 2013 03:59:25 PM JST
line-
* Sun 29 Sep 2013 03:59:29 PM JST
line-
* Sun 29 Sep 2013 03:59:32 PM JST
line-
* Sun 29 Sep 2013 03:59:39 PM JST
block-
* Sun 29 Sep 2013 03:59:42 PM JST
block-
* Sun 29 Sep 2013 03:59:47 PM JST
block-
* Sun 29 Sep 2013 03:59:51 PM JST
block-
* Sun 29 Sep 2013 03:59:55 PM JST
block-
* Sun 29 Sep 2013 04:10:13 PM JST
**** in line
py:in-line-if-p
py:in-line-while-p
py:in-line-def-p
py:in-line-class-p

* Sun 29 Sep 2013 04:10:31 PM JST
py:in-block-if-p
py:in-block-while-p
py:in-block-class-p
py:in-block-method-p
py:in-block-comment-p
py:in-block-dict-p


* Sun 29 Sep 2013 04:10:34 PM JST

* Sun 29 Sep 2013 04:10:34 PM JST

* Sun 29 Sep 2013 04:10:34 PM JST


* Sun 29 Sep 2013 04:25:01 PM JST

* Sun 29 Sep 2013 04:25:01 PM JST

* Sun 29 Sep 2013 04:25:01 PM JST
py:empty-line-p

* Sun 29 Sep 2013 04:25:10 PM JST
empty
* Sun 29 Sep 2013 04:31:39 PM JST
block
* Sun 29 Sep 2013 04:31:40 PM JST
this-block
* Sun 29 Sep 2013 04:38:12 PM JST

* Sun 29 Sep 2013 04:38:12 PM JST

* Sun 29 Sep 2013 04:38:12 PM JST
py:in-block-dict-p

* Sun 29 Sep 2013 04:38:17 PM JST
block
* Sun 29 Sep 2013 04:38:21 PM JST
py:in-func-paren-p
py:in-paren-p
py:in-list-box-p
py:in-dict-p


* Sun 29 Sep 2013 04:38:30 PM JST

* Sun 29 Sep 2013 04:38:31 PM JST

* Sun 29 Sep 2013 04:38:31 PM JST


* Sun 29 Sep 2013 04:39:10 PM JST

* Sun 29 Sep 2013 04:39:10 PM JST

* Sun 29 Sep 2013 04:39:11 PM JST


* Sun 29 Sep 2013 04:39:14 PM JST

* Sun 29 Sep 2013 04:39:14 PM JST

* Sun 29 Sep 2013 04:39:14 PM JST


* Sun 29 Sep 2013 04:39:15 PM JST

* Sun 29 Sep 2013 04:39:15 PM JST

* Sun 29 Sep 2013 04:39:16 PM JST


* Sun 29 Sep 2013 04:39:29 PM JST

* Sun 29 Sep 2013 04:39:29 PM JST

* Sun 29 Sep 2013 04:39:29 PM JST
py:docstring-p

* Sun 29 Sep 2013 04:39:30 PM JST
py:docstring-p

* Sun 29 Sep 2013 04:39:30 PM JST
py:docstring-p


* Sun 29 Sep 2013 04:39:51 PM JST
mark
* Sun 29 Sep 2013 04:39:59 PM JST
# mark
* Sun 29 Sep 2013 04:40:00 PM JST
   # mark
* Sun 29 Sep 2013 04:40:06 PM JST

* Sun 29 Sep 2013 04:40:06 PM JST

* Sun 29 Sep 2013 04:40:06 PM JST


* Sun 29 Sep 2013 04:40:25 PM JST

* Sun 29 Sep 2013 04:40:25 PM JST

* Sun 29 Sep 2013 04:40:25 PM JST
py:mark-paragraph

* Sun 29 Sep 2013 04:40:25 PM JST

* Sun 29 Sep 2013 04:40:25 PM JST
p
* Sun 29 Sep 2013 04:40:25 PM JST
py:comment-region

* Sun 29 Sep 2013 04:40:25 PM JST

* Sun 29 Sep 2013 04:40:25 PM JST
*
* Sun 29 Sep 2013 04:40:25 PM JST
*** move
   # move
   py:mv-block-up
   py:mv-block-down
   py:mv-def-up
   py:mv-def-down
   py:mv-class-up
   py:mv-class-down


* Sun 29 Sep 2013 04:40:26 PM JST

* Sun 29 Sep 2013 04:40:26 PM JST
2
* Sun 29 Sep 2013 04:40:26 PM JST
2) time/ref

* Sun 29 Sep 2013 04:40:26 PM JST

* Sun 29 Sep 2013 04:40:26 PM JST
p
* Sun 29 Sep 2013 04:40:26 PM JST
pylint.el

* Sun 29 Sep 2013 04:40:26 PM JST

* Sun 29 Sep 2013 04:40:26 PM JST
d
* Sun 29 Sep 2013 04:40:26 PM JST
dictionary writer {}

* Sun 29 Sep 2013 04:40:26 PM JST

* Sun 29 Sep 2013 04:40:26 PM JST
#
* Sun 29 Sep 2013 04:40:26 PM JST
# pdb

* Sun 29 Sep 2013 04:40:26 PM JST

* Sun 29 Sep 2013 04:40:26 PM JST
p
* Sun 29 Sep 2013 04:40:26 PM JST
py:shell-send-defun

* Sun 29 Sep 2013 04:40:26 PM JST

* Sun 29 Sep 2013 04:40:27 PM JST

* Sun 29 Sep 2013 04:40:27 PM JST


* Sun 29 Sep 2013 04:40:27 PM JST

* Sun 29 Sep 2013 04:40:27 PM JST

* Sun 29 Sep 2013 04:40:27 PM JST


* Sun 29 Sep 2013 04:40:27 PM JST

* Sun 29 Sep 2013 04:40:27 PM JST
 
* Sun 29 Sep 2013 04:40:27 PM JST
   py:indent-shift-left

* Sun 29 Sep 2013 04:40:27 PM JST

* Sun 29 Sep 2013 04:40:27 PM JST
 
* Sun 29 Sep 2013 04:40:27 PM JST
   py:mode-line-name

* Sun 29 Sep 2013 04:40:27 PM JST

* Sun 29 Sep 2013 04:40:27 PM JST
 
* Sun 29 Sep 2013 04:40:27 PM JST
   need a lot of time

* Sun 29 Sep 2013 04:40:27 PM JST

* Sun 29 Sep 2013 04:40:27 PM JST

* Sun 29 Sep 2013 04:40:28 PM JST


* Sun 29 Sep 2013 04:40:28 PM JST

* Sun 29 Sep 2013 04:40:28 PM JST
*
* Sun 29 Sep 2013 04:40:28 PM JST
** TODO [#C] if/while で= を使用しない。
; if before char is ">" "<", then insert =
; if in "if" statement then, insert "=="
; else insert "="

* Sun 29 Sep 2013 04:40:28 PM JST

* Sun 29 Sep 2013 04:40:28 PM JST
*
* Sun 29 Sep 2013 04:40:28 PM JST
* server
** selinux
** kernel
** RAID1
** TODO recompile openssh
   - remove Banner
   - disable ipv6

* Sun 29 Sep 2013 04:40:28 PM JST

* Sun 29 Sep 2013 04:40:28 PM JST
*
* Sun 29 Sep 2013 04:40:28 PM JST
* Todo:
*** 設計の設計
**** TODO なぜ 5
     - このシステムの目的（価値）は？
     - どのような責務を持つ人に使われるのか？
     - どのような外部システムとかかわるのか？
     - システムはどのような使われ方をするのか？　
     - システムとの接点は？
     - その時の入出力情報は？
     - システムに必要な機能は？
     - その機能が使用するデータは？
***** Functionality (機能)
	  - 機能要求
	  - セキュリティ
	  - 汎用性
	  - 将来性
***** Usability (操作性)
      - 使い易さ、分かり易さ
	  - 整合性
	  - 見栄え
	  - 利用マニュアル
***** Reliability (信頼性)
	  - 平均故障時間
	  - 平均故障間隔
	  - 可用性
	  - 故障頻度と深刻さ
	  - 復旧性
	  - 正確さ
      - 予見性
***** Performance (性能)
	  - 処理速度
	  - スループット
	  - 応答時間
	  - リソースの消費量

***** Supportability (保守性)
	  - テストのしやすさ
	  - 拡張性
	  - 適応性
	  - 保守性
	  - 運用性
	  - 構成のしやすさ
	  - インストールのしやすさ
	  - ローカライズのしやすさ

***** Plus (その他)
      - 関係する法律
**** 設計手順
     1. 調査
     2. 設計
     3. 実装
     4. Summary
     5. 重要な要素から設計 :: 後になる程、集中力が落る。
**** 構成作成
- 本の目次から参考にする。
**** 目標 (期待成果)
	 - 時間の削減
***** TODO 簡単に環境を構築できるようにする。
      - OS を再インストールした時などでも，簡単に自分の環境に近い
		ものを構築できるようにする。
		インターネットからダウンロードできるようにする。
***** TODO 文字を一切間違いのないようにする。
	  spell も同じ。

      [[file:~/.emacs.d/ebackup/.svn]]
      <2011-09-17 Sat>

***** TODO コマンド統合
   	  upcase
   	  region が設定されていれば region-upcase
   	  初めてコマンドが実行されカーソル下が小文字なら upcase-char
   	  lastcommand = thiscommand でカーソル下が大文字なら upcase-word

   	  [[file:~/mydoc/memo/memo.org::*Super%20key%20script][Super key 処理の長い script などを割り当てる]]
   	  <2012-10-29 Mon>

**** apropos
apropos で kill delete などのコマンドをさがして設計を考える。

** TODO architect of architecture
*** 要件定義の計画と基準作成 (設計の計画)
**** 調査計画作成
**** 調査分析
**** 見直し
** TODO 道具
*** TODO keybord
- 気になった keybord は買って使って試す。高い物はオークションで
  売る。
- happy hacking
- realforce
*** TODO 椅子
*** TODO 机
*** TODO 部屋
*** TODO ディスプレイ
*** TODO Foot switch
- 怪我した時用に ctrl の代わりに
** TODO インターネットから usb の環境をダウンロードできる仕組みを構築
- putty portforward winscp など、サーバーにアクセスしてデー
  タをダウンロードできる最小限のものを archive 化する。
  A_drive などのサイトにアップロードしておく。
** TODO autohotkey on linux

   [[file:~/.emacs.d/init/view_init.el::Color]]
   <2011-10-05 Wed>
** TODO 正規表現をマスター
   - auto-insert の正規表現を編集
** TODO bookmarklet を種類別にまとめる
** TODO zsh
   completion
   aireplay-ng

   [[file:/data/mydoc/security/penlinux::*Discovery%20Live%20Hosts][Discovery Live Hosts]]
   <2011-10-17 Mon>
** TODO アルゴリズム辞典を作成
** TODO [#B] 正規表現 アルゴリズム

    [[file:~/work/emacs_architect.org::*Maintenance][Maintenance]]
    <2012-11-19 Mon>
** TODO [#C] winscp sync error
like 'http://' file name cannot create unix file name.

    [[file:l:/Autohotkey/script/weekly.ahk]]
** DONE [#C] weekly monthly quarter 統合
** DONE [#C] linux 差分 backup
   CLOSED: [2013-08-26 Mon 18:08]
** DONE [#A] create python backup script class
   CLOSED: [2013-08-28 Wed 11:09]
** DONE [#A] routines script
   CLOSED: [2013-09-02 Mon 06:39]
- chrome bookmark
- send mail
** DONE [#C] weekly link
   CLOSED: [2013-09-01 Sun 02:21]

    [[file:~/.emacs.d/allinone.org::*%5B#A%5D%20routines%20script][routines script]]
** DONE [#C] king server auto halt on cron daily
   CLOSED: [2013-09-02 Mon 06:38]
   backup
   samba
   login

    [[file:~/.pylib/backup_ki_local.py]]
** DONE [#C] pyStartup make class Data as d
   CLOSED: [2013-09-02 Mon 06:38]

    [[file:~/.pylib/pyStartup.py]]
** TODO [#C] rook tcpdump python script
        while 1:
            data = conn.recv(blocksize)
            if not data:
                break
            callback(data)
        conn.close()
    [[file:/etc/crontab]]
** DONE [#C] logging by auto script
   CLOSED: [2013-09-06 Fri 13:31]

    [[file:~/.pylib/ref/CMD/sikuli.py::def%20sikulirun(path):][file:~/.pylib/ref/CMD/sikuli.py::def sikulirun(path):]]


* Sun 29 Sep 2013 04:40:28 PM JST

* Sun 29 Sep 2013 04:40:28 PM JST
*
* Sun 29 Sep 2013 04:40:29 PM JST
* security
** dump memory process from password
- PsTools\x86\userdump.exe %psid%


* Sun 29 Sep 2013 04:40:29 PM JST

* Sun 29 Sep 2013 04:40:29 PM JST
*
* Sun 29 Sep 2013 04:40:29 PM JST
* Develop
** Common Develop
*** Lab
*** project 管理
*** Policy
**** 変数
**** 関数
**** 条件文
*** Default Coding Style
**** Naming Conventions
|-------------------------+----------------------------------------------------------------------------|
| Entity                  | Description                                                                |
|-------------------------+----------------------------------------------------------------------------|
| ClassName               | Class names are in mixed upper and lower case with an                      |
|                         | initial capital letter.                                                    |
|-------------------------+----------------------------------------------------------------------------|
| TypeName                | Type definitions including enumerated types and                            |
|                         | typedefs use mixed upper and lower case with an initial                    |
|                         | capital letter                                                             |
|-------------------------+----------------------------------------------------------------------------|
| EnumeratedTypes         | In addition to the rule above, enumerated types are                        |
|                         | always stated in the plural form.                                          |
|-------------------------+----------------------------------------------------------------------------|
| localVariable           | Local variables are in mixed uppercase and lowercase                       |
|                         | with an initial lower case letter. The name should be                      |
|                         | independent of the underlying data type and should                         |
|                         | refer to whatever the variable represents.                                 |
|-------------------------+----------------------------------------------------------------------------|
| RoutineName ()          | Routines are in mixed uppercase and lowercase.                             |
|-------------------------+----------------------------------------------------------------------------|
| m_ClassVariable         | Member variables that are available to multiple routines                   |
|                         | within a class, but only within a class, are prefixed with                 |
|                         | an m_.                                                                     |
|-------------------------+----------------------------------------------------------------------------|
| g_GlobalVariable        | Global variables are prefixed with a g_.                                   |
|-------------------------+----------------------------------------------------------------------------|
| CONSTANT                | Named constants are in ALL_CAPS.                                           |
|-------------------------+----------------------------------------------------------------------------|
| MACRO                   | Macros are in ALL_CAPS.                                                    |
|-------------------------+----------------------------------------------------------------------------|
| Base_EnumeratedType     | Enumerated types are prefixed with a mnemonic for                          |
|                         | their base type stated in the singular?for example,                        |
|                         | Color_Red, Color_Blue.                                                     |
|-------------------------+----------------------------------------------------------------------------|
| TypeName                | Type definitions use mixed upper and lower case with                       |
|                         | an initial capital letter                                                  |
|-------------------------+----------------------------------------------------------------------------|
| GlobalRoutineName ()    | Public routines are in mixed uppercase and lowercase.                      |
|-------------------------+----------------------------------------------------------------------------|
| f_FileRoutineName ()    | Routines that are private to a single module (file) are                    |
|                         | prefixed with an f-underscore.                                             |
|-------------------------+----------------------------------------------------------------------------|
| LocalVariable           | Local variables are in mixed uppercase and lowercase.                      |
|                         | The name should be independent of the underlying data                      |
|                         | type and should refer to whatever the variable                             |
|                         | represents.                                                                |
|-------------------------+----------------------------------------------------------------------------|
| f_FileStaticVariable    | Module (file) variables are prefixed with an f-underscore.                 |
|-------------------------+----------------------------------------------------------------------------|
| G_GLOBAL_GlobalVariable | Global variables are prefixed with a G_ and a                              |
|                         | mnemonic of the module (file) that defines the variable                    |
|                         | in all uppercase?for example, SCREEN_Dimensions.                           |
|-------------------------+----------------------------------------------------------------------------|
| LOCAL_CONSTANT          | Named constants that are private to a single routine or                    |
|                         | module (file) are in all uppercase?for example,                            |
|                         | ROWS_MAX.                                                                  |
|-------------------------+----------------------------------------------------------------------------|
| G_GLOBALCONSTANT        | Global named constants are in all uppercase and are                        |
|                         | prefixed with G_ and a mnemonic of the module (file)                       |
|                         | that defines the named constant in all uppercase?for                       |
|                         | example, G_SCREEN_ROWS_MAX.                                                |
|-------------------------+----------------------------------------------------------------------------|
| LOCALMACRO ()           | Macro definitions that are private to a single routine or                  |
|                         | module (file) are in all uppercase.                                        |
|-------------------------+----------------------------------------------------------------------------|
| G_GLOBAL_MACRO ()       | Global macro definitions are in all uppercase and are                      |
|                         | prefixed with G_ and a mnemonic of the module (file)                       |
|                         | that defines the macro in all uppercase?for example, G_SCREEN_LOCATION (). |
|-------------------------+----------------------------------------------------------------------------|

**** Prefixes
|----------+--------------------------------------------------------------------------------|
| Semantic | meanig                                                                         |
|----------+--------------------------------------------------------------------------------|
| c        | Count (as in the number of records, characters, and so on)                     |
|----------+--------------------------------------------------------------------------------|
| first    | The first element that needs to be dealt with in an array. first is similar to |
|----------+--------------------------------------------------------------------------------|
| min      | but relative to the current operation rather than to the array itself.         |
|----------+--------------------------------------------------------------------------------|
| g        | Global variable                                                                |
|----------+--------------------------------------------------------------------------------|
| i        | Index into an array                                                            |
|----------+--------------------------------------------------------------------------------|
| last     | The last element that needs to be dealt with in an array. last is the          |
|          | counterpart of first.                                                          |
|----------+--------------------------------------------------------------------------------|
| lim      | The upper limit of elements that need to be dealt with in an array. lim is     |
|          | not a valid index. Like last, lim is used as a counterpart of first. Unlike    |
|          | last, lim represents a noninclusive upper bound on the array; last             |
|          | represents a final, legal element. Generally, lim equals last + 1.             |
|----------+--------------------------------------------------------------------------------|
| m        | Class-level variable                                                           |
|----------+--------------------------------------------------------------------------------|
| max      | The absolute last element in an array or other kind of list. max refers to     |
|          | the array itself rather than to operations on the array.                       |
|----------+--------------------------------------------------------------------------------|
| min      | The absolute first element in an array or other kind of list.                  |
|----------+--------------------------------------------------------------------------------|
| p        | Pointer                                                                        |
|----------+--------------------------------------------------------------------------------|



**** タブ幅
**** タブをスペースに変更
**** パラグラフのインデント
*** Change Log
*** Tags
*** Documentation Lookup
*** Comments
*** Completion
*** Window
*** Cycle
**** Code Reading
- ref. http://i.loveruby.net/ja/misc/readingcode.html

***** Over view
- Make preprocessor, callgraph and name list while Specification
****** Build & Run
:実行して確認 変更させて動作させる:

- 関数すべてに"in <関数名>"の debug print を挿入
  関数がよばれるたびにカウントし print する。
  表示は file 名,関数名を表示。
  log を取る。

- 変数の変更があれば表示
****** Specification
******* Constraction
- Directory Constraction
- File Constraction
****** History
- Changelog
- Readme
- mailing list
- news
- subversion
****** Preprocessor
****** minimap
******* TODO follow mode
******* TODO left view and imenu
******* TODO Microsoft Word
******* TODO Libre Office Writer
****** Callgraph
- doxygen
****** symbol list
- functions
- variables
- classes
******* Expand abbreviation
***** Commenting on source
***** Jump Function or Variable
***** Document
****** TODO [0/2] 簡易表示
******* TODO arguments
******* TODO Summary

****** TODO [0/2] 詳細表示
******* TODO info
******* TODO source

****** TODO [0/2] Document History
******* TODO visited count
******* TODO memo

**** Edit Source
***** Pseudocode
- コメントで疑似コードを下書きする。
***** Code navigation
***** Template
***** refactoring
***** Interpreter
**** Compile build
**** Run
**** Debug
***** コンパイルエラー
***** ランタイムエラー
***** 論理エラー
**** Profile
**** SubVersion
** Programming Languages
*** C C++
**** Coding Style
*** Emacs Lisp
**** Coding Style
**** Interpreter
***** scratch
**** tmp
***** special form
****** with-current-buffer
       1.	そのバッファを一時的にカレントバッファにする
****** save-excursion
       save-excurtion に入った時点のポイント位置、マーク位置、
       カレントバッファを記憶し、引数中の処理を行った後にそれらを復帰する。
****** save-match-data
       match-data の内容を保存して引数内を評価した後で、 match-data の内容を復帰する。
****** unwind-protect
       unwind-protect は, body からどのように制御が離れた場合にも cleanup-forms の実行を保証して, body を実行
       する. body は通常どおり完了するか, throw を実行して unwind-protect から脱出するか, エラーを引き起こす.
       いずれの場合でも, cleanup-forms は評価される.
****** save-selected-window
       一時的にウィンドウを選択し、その後で元のウィンドウに戻す
****** condition-case
       この特殊フォームは、エラーが出さ (訳注： signal) れた場合、 (処理の全体をアボートするのではなく) Lisp プ
       ログラムが、そのエラーを扱うことができるようにします。 condition-case フォームは評価されると、まず
       (signal が探す) 特殊なマーカーをスタック上に置きます。次に、 form を評価します。 form がエラーを生ずる
       ことなく評価された場合、その結果を condition-case の値とします。

       form の評価中にエラーが出さ (訳注： signal) れた場合、 signal は condition- case マークを見つけるまでスタ
       ックをサーチし、 (現われた順に) そ handlers を見ていきます。各ハンドラは、 (condition-name body*) とい
       った形をしています。

       あるハンドラ中の condition-name が、そのエラーシンボルに対応付けられたコンディションの 1 つである場合、
       そのハンドラを用います。 (最初に) 変数 var に、 (それを持って signal が呼ばれた) リスト data と
       (condition-name ではなく) エラーシンボルとをコンスしたリストをバインドします。 (次に) body フォームを評
       価し、その最後の値を結果とします。

       condition-case が、 (その) どのコンディションに対するハンドラも持たない場合、 signal はそのエラーを扱う
       (別の) condition-case がスタック上に存在しないか調べ (続け) ます。見つからなかった場合、処理 (訳注：
       computation) をアボートします。

****** save-restriction
       ナロイング範囲を変更した場合にはもとに戻す
****** save-window-excursion
       the window configuration
****** with-temp-buffer
****** save-window-excursion
	 この関数は, buffer-name という名前のバッファに forms の任意の出力が挿入されるように準備して forms を
	 実行する. そのバッファは適当なウィンドウに表示されるが, そのバッファは選択されない.

	 文字列 buffer-name は, 既存である必要はない一時的なバッファを指定する. 引数は, バッファではなく文字
	 列であること. （問い合わせずに）はじめにバッファを消去し, with-output-to-temp-buffer が終了すると
	 未変更と印を付ける.

	 with-output-to-temp-buffer は, standard-output に一時的なバッファを束縛し, forms のフォーム群を評価
	 する. forms 内で用いた Lisp 出力関数からの出力はデフォルトでそのバッファに入る（しかし, スクリーン表
	 示やエコー領域のメッセージは, 用語の一般的な意味で『出力』であるが, 影響されない. ） see section
	 出力関数.

	 forms の最後のフォームの値を返す.

	 ---------- Buffer: foo ----------
	 This is the contents of foo.
	 ---------- Buffer: foo ----------

	 (with-output-to-temp-buffer "foo"
	 (print 20)
	 (print standard-output))
	 ⇑ #<buffer foo>

	 ---------- Buffer: foo ----------
	 20

#<buffer foo>

	 ---------- Buffer: foo ----------

****** with-output-to-temp-buffer
****** ignore-errors
***** cua-set
      C-x r c	clear-rectangle	矩形領域を空白文字に置き換える
      C-x r d	delete-rectangle	矩形領域を削除する
      C-x r o	open-rectangle	空白文字で埋まった矩形領域を挿入する
      C-x r t	string-rectangle	矩形領域を文字列で置き換える
      C-x r k	kill-rectangle	矩形領域を削除してキルリングに追加
      C-x r y	yank-rectangle	キルリングの矩形領域を貼り付ける
      C-x r r	copy-rectangle-to-register	レジスターに矩形領域を登録する
      C-x r i	insert-register	レジスターに登録された矩形領域を貼り付ける

      リージョン選択中に C-<enter> で矩形選択モードになります。 sense-region と同様に C-w や M-w が使えます
      。また、矩形選択中に次のコマンドを打つと、矩形領域に対して操作を行うことができます。

      コマンド                                    動作
      適当なキー 矩形領域の前（または後ろ）にそのまま挿入。 <enter> で挿入位置を変えられる
      M-p        矩形の幅を固定
      M-b        空白文字で埋める。 open-rectangle と同等
      M-s        文字列で置き換える。 string-rectangle と同等
      M-f        1 種類の文字で埋める。 string-rectangle で 1 文字指定したときと同等
      M-i        矩形領域内の数字をインクリメントする
      M-n        矩形領域を連番で埋める。フォーマット指定可

***** command line
;;;; Command Option
(defun command-line-find-file-read-only (switch)
  (find-file-read-only (pop command-line-args-left)))

(add-to-list 'command-switch-alist
             '("--read-only" . command-line-find-file-read-only))

***** super character
      ?\a => 7                 ; control-g, `C-g'
      ?\b => 8                 ; backspace, <BS>, `C-h'
      ?\t => 9                 ; tab, <TAB>, `C-i'
      ?\n => 10                ; newline, `C-j'
      ?\v => 11                ; vertical tab, `C-k'
      ?\f => 12                ; formfeed character, `C-l'
      ?\r => 13                ; carriage return, <RET>, `C-m'
      ?\e => 27                ; escape character, <ESC>, `C-['
      ?\s => 32                ; space character, <SPC>
      ?\\ => 92                ; backslash character, `\'
      ?\d => 127               ; delete character, <DEL>

***** debug
      toggle-debug-on-quit

*** Python
**** Over view
***** [2/4] Build & Run
:実行して確認 変更させて動作させる:
****** DONE py-insert-debug-print
       CLOSED: [2013-02-27 03:32]
****** DONE py-delete-debug-print
       CLOSED: [2013-02-27 03:33]
****** TODO log を取る。
****** TODO 変数の変更があれば表示
***** [0/0] Specification
- Directory Constraction
- File Constraction
***** [0/0] History
- Changelog
- Readme
- mailing list
- news
- subversion
***** [0/0] Preprocessor
***** [2/4] minimap
******* TODO follow mode
******* TODO left view and imenu
******* DONE Microsoft Word
        CLOSED: [2013-02-27 03:38]
******* DONE Libre Office Writer
        CLOSED: [2013-02-27 03:39]
***** [0/0] Callgraph
- pycallgraph
- doxygen
****** UML
- pyreverse
  pyreverse.bat -o png package

***** [0/0] symbol list
- imenu
***** [0/0] Jump Function or Variable
***** [0/3] Document
****** TODO [1/2] 簡易表示
******* DONE arguments
        CLOSED: [2013-02-27 03:41]
******* TODO Summary

****** TODO [1/2] 詳細表示
******* DONE info
        CLOSED: [2013-02-27 03:41]
******* TODO source

****** TODO [0/2] Document History
******* TODO visited count
******* TODO memo



**** Edit Source
***** TODO Code Navigation
****** TODO Auto Completion
- jedi
****** TODO Function or Variable Name Assist
***** TODO Syntax Checker
***** Template
***** refactoring
**** Compile Build
**** Run
****** TODO Execute this buffer
**** Debug
***** TODO View Stack, locals/globals and return value
**** Profile
**** Coding style
(ref. [[http://www.python.org/dev/peps/pep-0008/][PEP 8 -- Style Guide for Python Code]])
(ref. [[http://google-styleguide.googlecode.com/svn/trunk/pyguide.html][Google Python Style Guide]])

***** Names to Avoid
- Never use the characters
  'l' (lowercase letter el),
  'O' (uppercase letter oh), or
  'I' (uppercase letter eye) as single character variable names.

- single character names except for counters or iterators
- dashes (-) in any package/module name
- __double_leading_and_trailing_underscore__ names (reserved by Python)

***** Naming Conventions

- "Internal" means internal to a module or protected or private within a class.
- Prepending a single underscore (_) has some support for protecting module variables
  and functions (not included with import * from).
  Prepending a double underscore (__) to an instance variable or method effectively
  serves to make the variable or method private to its class (using name mangling).
- Place related classes and top-level functions together in a module.
  Unlike Java, there is no need to limit yourself to one class per module.
- Use CapWords for class names, but lower_with_under.py for module names.
  Although there are many existing modules named CapWords.py,
  this is now discouraged because it's confusing when the module
  happens to be named after a class.
  ("wait -- did I write import StringIO or from StringIO import StringIO?")

|--------------------+--------------------------------------------------------------------------------|
| Entity             | Description                                                                    |
|--------------------+--------------------------------------------------------------------------------|
| package, module    | Public:   lower_with_under                                                     |
|                    | Internal: _lower_with_under                                                    |
|                    | Modules should have short, all-lowercase names.                                |
|                    | Underscores can be used in the module name if it improves readability.         |
|--------------------+--------------------------------------------------------------------------------|
| ClassName          | Public:   CapWords                                                             |
|                    | Internal: _CapWords                                                            |
|                    | Almost without exception,                                                      |
|                    | class names use the CapWords convention.                                       |
|                    | Classes for internal use have a leading underscore in addition.                |
|--------------------+--------------------------------------------------------------------------------|
| ExceptionNames     | Public:   CapWords                                                             |
| (ExceptionError)   | Because exceptions should be classes,                                          |
|                    | the class naming convention applies here.                                      |
|                    | However, you should use the suffix "Error" on your exception names             |
|                    | (if the exception actually is an error).                                       |
|--------------------+--------------------------------------------------------------------------------|
| G_GLOBAL_VARIABLE  | (Let's hope that these variables are meant for use inside one module only.)    |
|                    | The conventions are about the same as those for functions.                     |
|                    | Modules that are designed for use via from M import *                          |
|                    | should use the __all__ mechanism to prevent exporting globals,                 |
|                    | or use the older convention of prefixing such globals with an underscore       |
|                    | (which you might want to do to indicate these globals are                      |
|                    | "module non-public").                                                          |
|--------------------+--------------------------------------------------------------------------------|
| function_names     | Public:   lower_with_under ()                                                   |
|                    | Internal: _lower_with_under ()                                                  |
|                    | Function names should be lowercase,                                            |
|                    | with words separated by underscores as necessary to improve readability.       |
|                    | mixedCase is allowed only in contexts where that's already                     |
|                    | the prevailing style (e.g. threading.py), to retain backwards compatibility.   |
|--------------------+--------------------------------------------------------------------------------|
| function and       | Always use self for the first argument to instance methods.                    |
| method_arguments   | Always use cls for the first argument to class methods.                        |
|                    | If a function argument's name clashes with a reserved keyword,                 |
|                    | it is generally better to append a single trailing underscore                  |
|                    | rather than use an abbreviation or spelling corruption.                        |
|                    | Thus class_ is better than clss.                                               |
|                    | (Perhaps better is to avoid such clashes by using a synonym.)                  |
|--------------------+--------------------------------------------------------------------------------|
| method_name        | Public:   lower_with_under                                                     |
| and                | Internal: _lower_with_under                                                    |
| instance_variables | Use the function naming rules: lowercase with words separated                  |
| _non_public_meshod | by underscores as necessary to improve readability.                            |
|                    | Use one leading underscore only for non-public methods and instance variables. |
|                    | To avoid name clashes with subclasses, use two leading underscores             |
|                    | to invoke Python's name mangling rules.                                        |
|                    | Python mangles these names with the class name:                                |
|                    | if class Foo has an attribute named __a, it cannot be accessed by Foo.__a.     |
|                    | (An insistent user could still gain access by calling Foo._Foo__a.)            |
|                    | Generally, double leading underscores should be used only to avoid             |
|                    | name conflicts with attributes in classes designed to be subclassed.           |
|                    | Note: there is some controversy about the use of __names (see below).          |
|--------------------+--------------------------------------------------------------------------------|
| CONSTANT           | Public:   CAPS_WITH_UNDER                                                      |
|                    | Internal: _CAPS_WITH_UNDER                                                     |
|                    | Constants are usually defined on a module level and                            |
|                    | written in all capital letters with underscores separating words.              |
|                    | Examples include MAX_OVERFLOW and TOTAL.                                       |
|--------------------+--------------------------------------------------------------------------------|
| TypeName           |                                                                                |
| EnumeratedTypes    |                                                                                |

***** Rules
|--------------------+---------------------------------------------------------------------------------------------------|
| Line length        | Maximum line length is 80 characters. Do not use backslash line continuation.                     |
|                    | docstring or comments 72 characters.                                                                |
|--------------------+---------------------------------------------------------------------------------------------------|
| Indentation        | Indent your code blocks with 4 spaces. Never use tabs or mix tabs and spaces.                     |
|--------------------+---------------------------------------------------------------------------------------------------|
| Blank Lines        | Two blank lines between top-level definitions, one blank line between method definitions.         |
|                    | Two blank lines between top-level definitions, be they function or class definitions.             |
|                    | One blank line between method definitions and between the class line and the first method.        |
|                    | Use single blank lines as you judge appropriate within functions or methods.                      |
|--------------------+---------------------------------------------------------------------------------------------------|
| Semicolons         | Do not terminate your lines with semi-colons                                                      |
|                    | and do not use semi-colons to put two commands on the same line.                                  |
|--------------------+---------------------------------------------------------------------------------------------------|
| Whitespace         | Follow standard typographic rules for the use of spaces around punctuation.                       |
|                    | No whitespace inside parentheses, brackets or braces.                                             |
|                    | Yes: spam (ham[1], {eggs: 2}, [])                                                                  |
|                    | No:  spam ( ham[ 1 ], { eggs: 2 }, [ ] )                                                           |
|                    | ---                                                                                               |
|                    | No whitespace before a comma, semicolon, or colon.                                                |
|                    | Do use whitespace after a comma, semicolon, or colon except at the end of the line.               |
|                    | Yes: if x == 4:                                                                                   |
|                    | ........print x, y                                                                                |
|                    | ........x, y = y, x                                                                               |
|                    | No:  if x == 4 :                                                                                  |
|                    | ........print x , y                                                                               |
|                    | ........x , y = y , x                                                                             |
|                    | ---                                                                                               |
|                    | No whitespace before the open paren/bracket that                                                  |
|                    | starts an argument list, indexing or slicing.                                                     |
|                    | Yes: spam (1)                                                                                      |
|                    | No:  spam (1)                                                                                     |
|                    | Yes: dict['key'] = list[index]                                                                    |
|                    | No:  dict ['key'] = list [index]                                                                  |
|                    | ---                                                                                               |
|                    | Surround binary operators with a single space on either side for assignment (=),                   |
|                    | comparisons (==, <, >, !=, <>, <=, >=, in, not in, is, is not),                                   |
|                    | and Booleans (and, or, not).                                                                      |
|                    | Use your better judgment for the insertion of spaces around arithmetic operators                  |
|                    | but always be consistent about whitespace on either side of a binary operator.                    |
|                    | Yes: x == 1                                                                                       |
|                    | No:  x<1                                                                                          |
|                    | ---                                                                                               |
|                    | Don't use spaces around the '=' sign                                                              |
|                    | when used to indicate a keyword argument or a default parameter value.                            |
|                    | Yes: def complex (real, imag=0.0): return magic (r=real, i=imag)                                    |
|                    | No:  def complex (real, imag = 0.0): return magic (r = real, i = imag)                              |
|                    | ---                                                                                               |
|                    | Don't use spaces to vertically align tokens on consecutive lines,                                 |
|                    | since it becomes a maintenance burden (applies to :, #, =, etc.):                                 |
|                    |                                                                                                   |
|                    | Yes:                                                                                              |
|                    | foo = 1000  # comment                                                                             |
|                    | long_name = 2  # comment that should not be aligned                                               |
|                    |                                                                                                   |
|                    | dictionary = {                                                                                    |
|                    | ....'foo': 1,                                                                                     |
|                    | ....'long_name': 2,                                                                               |
|                    | }                                                                                                 |
|                    | No:                                                                                               |
|                    | foo       = 1000  # comment                                                                       |
|                    | long_name = 2     # comment that should not be aligned                                            |
|                    |                                                                                                   |
|                    | dictionary = {                                                                                    |
|                    | ....'foo'      : 1,                                                                               |
|                    | ....'long_name': 2,                                                                               |
|                    | }                                                                                                 |
|--------------------+---------------------------------------------------------------------------------------------------|
| shebang line       | Most .py files do not need to start with a #! line.                                               |
|                    | Start the main file of a program with #!/usr/bin/python.                                          |
|                    | This line is used by the kernel to find the Python interpreter,                                   |
|                    | but is ignored by Python when importing modules.                                                  |
|                    | It is only necessary on a file that will be executed directly.                                    |
|--------------------+---------------------------------------------------------------------------------------------------|
| strings            | Use the % operator for formatting strings, even when the parameters are all strings.              |
|                    | Use your best judgement to decide between + and % though.                                         |
|                    |                                                                                                   |
|                    | Yes: x = a + b                                                                                    |
|                    | .....x = '%s, %s!' % (imperative, expletive)                                                      |
|                    | .....x = 'name: %s; score: %d' % (name, n)                                                        |
|                    | No: x = '%s%s' % (a, b)  # use + in this case                                                     |
|                    | ....x = imperative + ', ' + expletive + '!'                                                       |
|                    | ....x = 'name: ' + name + '; score: ' + str (n)                                                    |
|                    |                                                                                                   |
|                    | Avoid using the + and += operators to accumulate a string within a loop.                          |
|                    | Since strings are immutable, this creates unnecessary temporary objects and                       |
|                    | results in quadratic rather than linear running time.                                             |
|                    | Instead, add each substring to a list and ''.join                                                 |
|                    | the list after the loop terminates (or, write each substring to a cStringIO.StringIO buffer).     |
|                    |                                                                                                   |
|                    | Yes: items = ['<table>']                                                                          |
|                    | .....for last_name, first_name in employee_list:                                                  |
|                    | .........items.append ('<tr><td>%s, %s</td></tr>' % (last_name, first_name))                       |
|                    | .....items.append ('</table>')                                                                     |
|                    | .....employee_table = ''.join (items)                                                              |
|                    | No: employee_table = '<table>'                                                                    |
|                    | ....for last_name, first_name in employee_list:                                                   |
|                    | ........employee_table += '<tr><td>%s, %s</td></tr>' % (last_name, first_name)                    |
|                    | ....employee_table += '</table>'                                                                  |
|                    |                                                                                                   |
|                    | Use """ for multi-line strings rather than '''. Note, however,                                    |
|                    | that it is often cleaner to use implicit line joining since multi-line                            |
|                    | strings do not flow with the indentation of the rest of the program:                              |
|                    |                                                                                                   |
|                    | Yes:                                                                                              |
|                    | ..print ("This is much nicer.\n"                                                                  |
|                    | ........."Do it this way.\n")                                                                     |
|                    | No:                                                                                               |
|                    | ..print """This is pretty ugly.                                                                   |
|                    | Don't do this.                                                                                    |
|--------------------+---------------------------------------------------------------------------------------------------|
| Files              | Explicitly close files and sockets when done with them.                                           |
| and                | Leaving files, sockets or other file-like objects open unnecessarily                              |
| Sockets            | has many downsides, including:                                                                    |
|                    |                                                                                                   |
|                    | They may consume limited system resources, such as file descriptors.                              |
|                    | Code that deals with many such objects may exhaust those resources unnecessarily                  |
|                    | if they're not returned to the system promptly after use.                                         |
|                    |                                                                                                   |
|                    | Holding files open may prevent other actions being performed on them,                             |
|                    | such as moves or deletion.                                                                        |
|                    | Files and sockets that are shared throughout a program may inadvertantly be                       |
|                    | read from or written to after logically being closed.                                             |
|                    | If they are actually closed, attempts to read or write from them will throw exceptions,           |
|                    | making the problem known sooner.                                                                  |
|                    |                                                                                                   |
|                    | Furthermore, while files and sockets are automatically closed when the file object is destructed, |
|                    | tying the life-time of the file object to the state of the file is poor practice,                 |
|                    | for several reasons:                                                                              |
|                    |                                                                                                   |
|                    | There are no guarantees as to when the runtime will actually run the file's destructor.           |
|                    | Different Python implementations use different memory management techniques,                      |
|                    | such as delayed Garbage Collection, which may increase the object's lifetime arbitrarily          |
|                    | and indefinitely.                                                                                 |
|                    |                                                                                                   |
|                    | Unexpected references to the file may keep it around longer than intended                         |
|                    | (e.g. in tracebacks of exceptions, inside globals, etc).                                          |
|                    |                                                                                                   |
|                    | The preferred way to manage files is using the "with" statement:                                  |
|                    |                                                                                                   |
|                    | with open ("hello.txt") as hello_file:                                                             |
|                    | ....for line in hello_file:                                                                       |
|                    | ........print line                                                                                |
|                    |                                                                                                   |
|                    | For file-like objects that do not support the "with" statement, use contextlib.closing ():         |
|                    |                                                                                                   |
|                    | import contextlib                                                                                 |
|                    |                                                                                                   |
|                    | with contextlib.closing (urllib.urlopen ("http://www.python.org/")) as front_page:                  |
|                    | ....for line in front_page:                                                                       |
|                    | ........print line                                                                                |
|                    |                                                                                                   |
|                    | Legacy AppEngine code using Python 2.5 may enable the "with" statement using                      |
|                    | "from __future__ import with_statement".                                                          |
|--------------------+---------------------------------------------------------------------------------------------------|
| TODO Comments      | Use TODO comments for code that is temporary,                                                     |
|                    | a short-term solution, or good-enough but not perfect.                                            |
|                    |                                                                                                   |
|                    | TODOs should include the string TODO in all caps,                                                 |
|                    | followed by the name, e-mail address, or other identifier                                         |
|                    | of the person who can best provide context about the problem                                      |
|                    | referenced by the TODO, in parentheses.                                                           |
|                    | A colon is optional.                                                                              |
|                    | A comment explaining what there is to do is required.                                             |
|                    | The main purpose is to have a consistent TODO format                                              |
|                    | that can be searched to find the person who can provide                                           |
|                    | more details upon request. A TODO is not a commitment that                                        |
|                    | the person referenced will fix the problem.                                                       |
|                    | Thus when you create a TODO, it is almost always your name that is given.                         |
|                    |                                                                                                   |
|                    | # TODO (kl@gmail.com): Use a "*" here for string repetition.                                       |
|                    | # TODO (Zeke) Change this to use relations.                                                        |
|                    |                                                                                                   |
|                    | If your TODO is of the form "At a future date do something"                                       |
|                    | make sure that you either include a very specific date                                            |
|                    | ("Fix by November 2009") or a very specific event                                                 |
|                    | ("Remove this code when all clients can handle XML responses.").                                  |
|--------------------+---------------------------------------------------------------------------------------------------|
| Imports formatting | Imports should be on separate lines.                                                              |
|                    |                                                                                                   |
|                    | E.g.:                                                                                             |
|                    |                                                                                                   |
|                    | Yes: import os                                                                                    |
|                    | _____import sys                                                                                   |
|                    | No:  import os, sys                                                                               |
|                    |                                                                                                   |
|                    | Imports are always put at the top of the file,                                                    |
|                    | just after any module comments and                                                                |
|                    | doc strings and before module globals and constants.                                              |
|                    | Imports should be grouped with                                                                    |
|                    | the order being most generic to least generic:                                                    |
|                    |                                                                                                   |
|                    | - standard library imports                                                                        |
|                    | - third-party imports                                                                             |
|                    | - application-specific imports                                                                    |
|                    |                                                                                                   |
|                    | Within each grouping, imports should be sorted lexicographically,                                 |
|                    | ignoring case, according to each module's full package path.                                      |
|                    |                                                                                                   |
|                    | import foo                                                                                        |
|                    | from foo import bar                                                                               |
|                    | from foo.bar import baz                                                                           |
|                    | from foo.bar import Quux                                                                          |
|                    | from Foob import ar                                                                               |
|--------------------+---------------------------------------------------------------------------------------------------|
| Statements         | Generally only one statement per line.                                                            |
|                    |                                                                                                   |
|                    | However, you may put the result of a test on the same line                                        |
|                    | as the test only if the entire statement fits on one line.                                        |
|                    | In particular, you can never do so with try/except                                                |
|                    | since the try and except can't both fit on the same line,                                         |
|                    | and you can only do so with an if if there is no else.                                            |
|                    |                                                                                                   |
|                    | Yes:                                                                                              |
|                    |                                                                                                   |
|                    | ..if foo: bar (foo)                                                                                |
|                    | No:                                                                                               |
|                    |                                                                                                   |
|                    | ..if foo: bar (foo)                                                                                |
|                    | ..else:   baz (foo)                                                                                |
|                    |                                                                                                   |
|                    | ..try:               bar (foo)                                                                     |
|                    | ..except ValueError: baz (foo)                                                                     |
|                    |                                                                                                   |
|                    | ..try:                                                                                            |
|                    | ......bar (foo)                                                                                    |
|                    | ..except ValueError: baz (foo)                                                                     |
|--------------------+---------------------------------------------------------------------------------------------------|
| Access Control     | If an accessor function would be trivial                                                          |
|                    | you should use public variables instead of accessor functions to avoid                            |
|                    | the extra cost of function calls in Python. When more functionality is                            |
|                    | added you can use property to keep the syntax consistent.                                         |
|                    |                                                                                                   |
|                    | On the other hand, if access is more complex,                                                     |
|                    | or the cost of accessing the variable is significant,                                             |
|                    | you should use function calls (following the Naming guidelines)                                   |
|                    | such as get_foo () and set_foo ().                                                                  |
|                    | If the past behavior allowed access through a property,                                           |
|                    | do not bind the new accessor functions to the property.                                           |
|                    | Any code still attempting to access the variable by the old method                                |
|                    | should break visibly so they are made aware of the change in complexity.                          |
|                    |                                                                                                   |
|                    |                                                                                                   |
|                    |                                                                                                   |
|                    |                                                                                                   |
|                    |                                                                                                   |
|                    |                                                                                                   |
|                    |                                                                                                   |
|                    |                                                                                                   |

***** Comments
|-----------------+--------------------------------------------------------------------------------------------|
| Comments        | Descriptions                                                                               |
|-----------------+--------------------------------------------------------------------------------------------|
| Doc Strings     | Python has a unique commenting style using doc strings.                                    |
|                 | A doc string is a string that is the first statement in a                                  |
|                 | package, module, class or function.                                                        |
|                 | These strings can be extracted automatically through the __doc__                           |
|                 | member of the object and are used by pydoc.                                                |
|                 | (Try running pydoc on your module to see how it looks.)                                    |
|                 | Our convention for doc strings is to use the three double-quote format for strings.        |
|                 | A doc string should be organized as a summary line (one physical line)                     |
|                 | terminated by a period, question mark, or exclamation point, followed by a blank line,     |
|                 | followed by the rest of the doc string starting at the same cursor position                |
|                 | as the first quote of the first line.                                                      |
|                 | There are more formatting guidelines for doc strings below.                                |
|-----------------+--------------------------------------------------------------------------------------------|
| Modules         | Every file should contain license boilerplate.                                             |
|                 | Choose the appropriate boilerplate for the license used by the project                     |
|                 | (for example, Apache 2.0, BSD, LGPL, GPL)                                                  |
|-----------------+--------------------------------------------------------------------------------------------|
| Functions       | As used in this section "function" applies to methods, function, and generators.           |
| and             | A function must have a docstring, unless it meets all of the following criteria:           |
| Methods         | - not externally visible                                                                   |
|                 | - very short                                                                               |
|                 | - obvious                                                                                  |
|                 |                                                                                            |
|                 | A docstring should give enough information to write a call to the function                 |
|                 | without reading the function's code.                                                       |
|                 | A docstring should describe the function's calling syntax                                  |
|                 | and its semantics, not its implementation.                                                 |
|                 | For tricky code, comments alongside the code are more appropriate than using docstrings.   |
|                 |                                                                                            |
|                 | Certain aspects of a function should be documented in special sections, listed below.      |
|                 | Each section begins with a heading line, which ends with a colon.                          |
|                 | Sections should be indented two spaces, except for the heading.                            |
|                 | Args:                                                                                      |
|                 | ......List each parameter by name.                                                         |
|                 | ......A description should follow the name, and be separated by a colon and a space.       |
|                 | ......If the description is too long to fit on a single 80-character line,                 |
|                 | ......use a hanging indent of 2 or 4 spaces (be consistent with the rest of the file).     |
|                 | ......The description should mention required type (s) and the meaning of the argument.     |
|                 |                                                                                            |
|                 | ......If a function accepts *foo (variable length argument lists)                          |
|                 | ......and/or **bar (arbitrary keyword arguments), they should be listed as *foo and **bar. |
|                 |                                                                                            |
|                 | Returns: (or Yields: for generators)                                                       |
|                 | ......Describe the type and semantics of the return value.                                 |
|                 | ......If the function only returns None, this section is not required.                     |
|                 |                                                                                            |
|                 | Raises:                                                                                    |
|                 | ......List all exceptions that are relevant to the interface.                              |
|                 |                                                                                            |
|                 | def fetch_bigtable_rows (big_table, keys, other_silly_variable=None):                       |
|                 | ...."""Fetches rows from a Bigtable.                                                       |
|                 |                                                                                            |
|                 | ....Retrieves rows pertaining to the given keys from the Table instance                    |
|                 | ....represented by big_table.  Silly things may happen if                                  |
|                 | ....other_silly_variable is not None.                                                      |
|                 | ....Args:                                                                                  |
|                 | ......big_table: An open Bigtable Table instance.                                          |
|                 | ......keys: A sequence of strings representing the key of each table row                   |
|                 | ......to fetch.                                                                            |
|                 | ......other_silly_variable: Another optional variable, that has a much                     |
|                 | ......longer name than the other args, and which does nothing.                             |
|                 |                                                                                            |
|                 | ....Returns:                                                                               |
|                 | ......A dict mapping keys to the corresponding table row data                              |
|                 | ......fetched. Each row is represented as a tuple of strings. For                          |
|                 | ......example:                                                                             |
|                 |                                                                                            |
|                 | ......{'Serak': ('Rigel VII', 'Preparer'),                                                 |
|                 | ......'Zim': ('Irk', 'Invader'),                                                           |
|                 | ......'Lrrr': ('Omicron Persei 8', 'Emperor')}                                             |
|                 | ....                                                                                       |
|                 | ......If a key from the keys argument is missing from the dictionary,                      |
|                 | ......then that row was not found in the table.                                            |
|                 |                                                                                            |
|                 | ....Raises:                                                                                |
|                 | ......IOError: An error occurred accessing the bigtable.Table object.                      |
|                 | ...."""                                                                                    |
|                 | ....pass                                                                                   |
|-----------------+--------------------------------------------------------------------------------------------|
| Classes         | Classes should have a doc string below the class definition describing the class.          |
|                 |                                                                                            |
|                 | If your class has public attributes, they should be documented here in an Attributes       |
|                 | section and follow the same formatting as a function's Args section.                       |
|                 |                                                                                            |
|                 | class SampleClass (object):                                                                 |
|                 | ...."""Summary of class here.                                                              |
|                 |                                                                                            |
|                 | ....Longer class information....                                                           |
|                 | ....Longer class information....                                                           |
|                 |                                                                                            |
|                 | ....Attributes:                                                                            |
|                 | ........likes_spam: A boolean indicating if we like SPAM or not.                           |
|                 | ........eggs: An integer count of the eggs we have laid.                                   |
|                 | ...."""                                                                                    |
|                 |                                                                                            |
|                 | ....def __init__(self, likes_spam=False):                                                  |
|                 | ........"""Inits SampleClass with blah."""                                                 |
|                 | ........self.likes_spam = likes_spam                                                       |
|                 | ........self.eggs = 0                                                                      |
|                 |                                                                                            |
|                 | ....def public_method (self):                                                               |
|                 | ........"""Performs operation blah."""                                                     |
|-----------------+--------------------------------------------------------------------------------------------|
| Block           | The final place to have comments is in tricky parts of the code.                           |
| and             | If you're going to have to explain it at the next code review,                             |
| Inline Comments | you should comment it now. Complicated operations get a few lines                          |
|                 | of comments before the operations commence.                                                |
|                 |                                                                                            |
|                 | # We use a weighted dictionary search to find out where i is in                            |
|                 | # the array.  We extrapolate position based on the largest num                             |
|                 | # in the array and the array size and then do binary search to                             |
|                 | # get the exact number.                                                                    |
|                 |                                                                                            |
|                 | if i & (i-1) == 0:        # true iff i is a power of 2                                     |
|                 |                                                                                            |
|                 | To improve legibility, these comments should be at least 2 spaces away from the code.      |
|                 |                                                                                            |
|                 | On the other hand, never describe the code.                                                |
|                 | Assume the person reading the code knows Python                                            |
|                 | (though not what you're trying to do) better than you do.                                  |
|                 |                                                                                            |
|                 | # BAD COMMENT: Now go through the b array and make sure whenever i occurs                  |
|                 | # the next element is i+1                                                                  |
|-----------------+--------------------------------------------------------------------------------------------|
| Classes         | If a class inherits from no other base classes, explicitly inherit from object.            |
|                 | This also applies to nested classes.                                                       |
|                 |                                                                                            |
|                 | Yes: class SampleClass (object):                                                            |
|                 | ........pass                                                                               |
|                 |                                                                                            |
|                 |                                                                                            |
|                 | .....class OuterClass (object):                                                             |
|                 |                                                                                            |
|                 | ........class InnerClass (object):                                                          |
|                 | .............pass                                                                          |
|                 |                                                                                            |
|                 |                                                                                            |
|                 | .....class ChildClass (ParentClass):                                                        |
|                 | ........"""Explicitly inherits from another class already."""                              |
|                 |                                                                                            |
|                 | No: class SampleClass:                                                                     |
|                 | ........pass                                                                               |
|                 |                                                                                            |
|                 |                                                                                            |
|                 | ....class OuterClass:                                                                      |
|                 |                                                                                            |
|                 | ........class InnerClass:                                                                  |
|                 | ............pass                                                                           |
|                 |                                                                                            |
|                 |                                                                                            |
|                 | Inheriting from object is needed to make properties work properly,                                                                                                     |
|                 | and it will protect your code from one particular potential incompatibility                                                                                            |
|                 | with Python 3000. It also defines special methods that implement the default                                                                                           |
|                 | semantics of objects including                                                                                                                                         |
|                 | __new__, __init__, __delattr__, __getattribute__, __setattr__,                                                                                                         |
|                 | __hash__, __repr__, and __str__.                                                                                                                                       |
|-----------------+--------------------------------------------------------------------------------------------|

**** Outline
**** Interpreter
**** tmp
***** Operaters
- lt <
- le <=
- eq =
- ne <>
- ge >=
- gt >

***** Standard Library
****** Text
1 string                -Text Constants and Templates
2 textwrap              -Formatting Text Paragraphs
3 re                    -Regular Expressions
4 difflib               -Compare Sequences

****** Data Structures
1 collections           -Container Data Types
2 array                 -Sequence of Fixed-Type Data
3 heapq                 -Heap Sort Algorithm
4 bisect                -Maintain Lists in Sorted Order
5 Queue                 -Thread-Safe FIFO Implementation
6 struct                -Binary Data Structures
7 weakref               -Impermanent References to Objects
8 copy                  -Duplicate Objects
9 pprint                -Pretty-Print Data Structures

****** Algorithms
1 functools             -Tools for Manipulating Functions
2 itertools             -Iterator Functions
3 operator              -Functional Interface to Built-in Operators
4 contextlib            -Context Manager Utilities

****** Dates and Times
1 time                  -Clock Time
2 datetime              -Date and Time Value Manipulation
3 calendar              -Work with Dates

****** Mathematics
1 decimal               -Fixed and Floating-Point Math
2 fractions             -Rational Numbers
3 random                -Pseudorandom Number Generators
4 math                  -Mathematical Functions

****** The File System
1 os.path               -Platform-Independent Manipulation of Filenames
2 glob                  -Filename Pattern Matching
3 linecache             -Read Text Files Efficiently
4 tempfile              -Temporary File System Objects
5 shutil                -High-Level File Operations
6 mmap                  -Memory-Map Files
7 codecs                -String Encoding and Decoding
8 StringIO              -Text Buffers with a File-like API
9 fnmatch               -UNIX-Style Glob Pattern Matching
10 dircache             -Cache Directory Listings
11 filecmp              -Compare Files

****** Data Persistence and Exchange
1 pickle                -Object Serialization
2 shelve                -Persistent Storage of Objects
3 anydbm                -DBM-Style Databases
4 whichdb               -Identify DBM-Style Database Formats
5 sqlite3               -Embedded Relational Database
6 xml.etree.ElementTree -XML Manipulation API
7 csv                   -Comma-Separated Value Files

****** Data Compression and Archiving
1 zlib                  -GNU zlib Compression
2 gzip                  -Read and Write GNU Zip Files
3 bz2                   -bzip2 Compression
4 tarfile               -Tar Archive Access
5 zipfile               -ZIP Archive Access

****** Cryptography
1 hashlib               -Cryptographic Hashing
2 hmac                  -Cryptographic Message Signing and Verification

****** Processes and Threads
1 subprocess            -Spawning Additional Processes
2 signal                -Asynchronous System Events
3 threading             -Manage Concurrent Operations
4 multiprocessing       -Manage Processes like Threads

****** Networking
1 socket                -Network Communication
2 select                -Wait for I/O Efficiently
3 SocketServer          -Creating Network Servers
4 asyncore              -Asynchronous I/O
5 asynchat              -Asynchronous Protocol Handler

****** The Internet
1 urlparse              -Split URLs into Components
2 BaseHTTPServer        -Base Classes for Implementing Web Servers
3 urllib                -Network Resource Access
4 urllib2               -Network Resource Access
5 base64                -Encode Binary Data with ASCII
6 robotparser           -Internet Spider Access Control
7 Cookie                -HTTP Cookies
8 uuid                  -Universally Unique Identifiers
9 json                  -JavaScript Object Notation
10 xmlrpclib            -Client Library for XML-RPC
11 SimpleXMLRPCServer   -An XML-RPC Server

****** Email
1 smtplib               -Simple Mail Transfer Protocol Client
2 smtpd                 -Sample Mail Servers
3 imaplib               -IMAP4 Client Library
4 mailbox               -Manipulate Email Archives

****** Application Building Blocks
1 getopt                -Command-Line Option Parsing
2 optparse              -Command-Line Option Parser
3 argparse              -Command-Line Option and Argument Parsing
4 readline              -The GNU Readline Library
5 getpass               -Secure Password Prompt
6 cmd                   -Line-Oriented Command Processors
7 shlex                 -Parse Shell-Style Syntaxes
8 ConfigParser          -Work with Configuration Files
9 logging               -Report Status, Error, and Informational Messages
10 fileinput            -Command-Line Filter Framework
11 atexit               -Program Shutdown Callbacks
12 sched                -Timed Event Scheduler

****** Internationalization and Localization
1 gettext               -Message Catalogs
2 locale                -Cultural Localization API

****** Developer Tools
1 pydoc                 -Online Help for Modules
2 doctest               -Testing through Documentation
3 unittest              -Automated Testing Framework
4 traceback             -Exceptions and Stack Traces
5 cgitb                 -Detailed Traceback Reports
6 pdb                   -Interactive Debugger
7 trace                 -Follow Program Flow
8 profile and pstats    -Performance Analysis
9 timeit                -Time the Execution of Small Bits of Python Code
10 compileall           -Byte-Compile Source Files
11 pyclbr               -Class Browser

****** Runtime Features
1 site                  -Site-Wide Configuration
2 sys                   -System-Specific Configuration
3 os                    -Portable Access to Operating System Specific Features
4 platform              -System Version Information
5 resource              -System Resource Management
6 gc                    -Garbage Collector
7 sysconfig             -Interpreter Compile-Time Configuration

****** Language Tools
1 warnings              -Nonfatal Alerts
2 abc                   -Abstract Base Classes
3 dis                   -Python Bytecode Disassembler
4 inspect               -Inspect Live Objects
5 exceptions            -Built-in Exception Classes

****** Modules and Packages
1 imp                   -Python's Import Mechanism
2 zipimport             -Load Python Code from ZIP Archives
3 pkgutil               -Package Utilities

***** optparse
(setq optparse '(("action="          . ("'store'," "'store_const'." "'store_true',"
										"'store_false'," "'append'," "'append_const'," "'count',"))
				 ("type="            . ("'string'" "'int'" "'long'" "'choice'" "'float'" "'complex'"))
				 ("dest="            . ("'',"))
				 ("default="         . ("'True'," "'False',"))
				 ("nargs="           . ("1" "2" "3" "4" "5" "6" "7" "8" "9"))
				 ("const="           . ("''"))
				 ("choices="         . ("''"))
				 ("callback="        . ("''"))
				 ("callback_args="   . ("''"))
				 ("callback_kwargs=" . ("''"))
				 ("help="            . ("''"))
				 ("metavar"          . ("''"))
				 ))
***** typecheck
****** inspect
- inspect.ismodule ()
- inspect.isclass ()
- inspect.ismethod ()
- inspect.ismethoddescriptor ()
- inspect.ismemberdescriptor ()
- inspect.isgetsetdescriptor ()
- inspect.isfunction ()
- inspect.isgeneratorfunction ()
- inspect.isgenerator ()
- inspect.istraceback ()
- inspect.isframe ()
- inspect.iscode ()
- inspect.isbuiltin ()
- inspect.isroutine ()
- inspect.isabstract ()

****** types
if type (etc) == types.NoneType:
if type (etc) == types.TypeType:
if type (etc) == types.ObjectType:
if type (etc) == types.IntType:
if type (etc) == types.LongType:
if type (etc) == types.FloatType:
if type (etc) == types.BooleanType:
if type (etc) == types.ComplexType:
if type (etc) == types.StringType:
if type (etc) == types.UnicodeType:
if type (etc) == types.StringTypes:
if type (etc) == types.StringTypes:
if type (etc) == types.BufferType:
if type (etc) == types.TupleType:
if type (etc) == types.ListType:
if type (etc) == types.DictType:
if type (etc) == types.FunctionType:
if type (etc) == types.LambdaType:
if type (etc) == types.CodeType:
if type (etc) == types.GeneratorType:
if type (etc) == types.ClassType:
if type (etc) == types.UnboundMethodType:
if type (etc) == types._x:
if type (etc) == types.InstanceType:
if type (etc) == types.MethodType:
if type (etc) == types.BuiltinFunctionType:
if type (etc) == types.BuiltinMethodType:
if type (etc) == types.ModuleType:
if type (etc) == types.FileType:
if type (etc) == types.XRangeType:
if type (etc) == types.tb:
if type (etc) == types.TracebackType:
if type (etc) == types.FrameType:
if type (etc) == types.SliceType:
if type (etc) == types.EllipsisType:
if type (etc) == types.DictProxyType:
if type (etc) == types.NotImplementedType:
if type (etc) == types.GetSetDescriptorType:
if type (etc) == types.MemberDescriptorType:

****** isinstance
- isinstance (object, classinfo)

*** Assembly

* Sun 29 Sep 2013 04:46:02 PM JST
void-function redo
* Sun 29 Sep 2013 04:48:48 PM JST
(require 'cl)
* Sun 29 Sep 2013 04:49:41 PM JST
http://www.dr-qubit.org/emacs.php
* Sun 29 Sep 2013 04:53:03 PM JST
http://www.dr-qubit.org/git/undo-tree.git
* Sun 29 Sep 2013 04:53:15 PM JST
http://www.dr-qubit.org/git/undo-tree.git
* Sun 29 Sep 2013 04:55:21 PM JST
http://www.dr-qubit.org/undo-tree/undo-tree-0.6.4.el
* Sun 29 Sep 2013 05:16:36 PM JST

* Sun 29 Sep 2013 05:16:36 PM JST

* Sun 29 Sep 2013 05:16:36 PM JST
   # move

* Sun 29 Sep 2013 05:17:49 PM JST
def--
* Sun 29 Sep 2013 05:17:53 PM JST
class--
* Sun 29 Sep 2013 06:07:59 PM JST
# Tail end of ' string.
Single = r"[^'\\]*(?:\\.[^'\\]*)*'"
# Tail end of " string.
Double = r'[^"\\]*(?:\\.[^"\\]*)*"'
# Tail end of ''' string.
Single3 = r"[^'\\]*(?:(?:\\.|'(?!''))[^'\\]*)*'''"
# Tail end of """ string.
Double3 = r'[^"\\]*(?:(?:\\.|"(?!""))[^"\\]*)*"""'
Triple = group("[uUbB]?[rR]?'''", '[uUbB]?[rR]?"""')
# Single-line ' or " string.
String = group(r"[uUbB]?[rR]?'[^\n'\\]*(?:\\.[^\n'\\]*)*'",
               r'[uUbB]?[rR]?"[^\n"\\]*(?:\\.[^\n"\\]*)*"')

* Sun 29 Sep 2013 06:12:05 PM JST
dir(
* Sun 29 Sep 2013 06:12:34 PM JST
"[^'\\\\]*(?:\\\\.[^'\\\\]*)*'"
* Sun 29 Sep 2013 06:14:54 PM JST
[^'\\\\]*(?:\\\\.[^'\\\\]*)*'
* Sun 29 Sep 2013 06:15:19 PM JST
"\\[\\^'\\\\\\\\]\\*(\\?:\\\\\\\\\\.\\[\\^'\\\\\\\\]\\*)\\*'"
* Sun 29 Sep 2013 06:16:43 PM JST
"[^'\\]*(?:(?:\\.|'(?!''))[^'\\]*)*'''"
* Sun 29 Sep 2013 06:17:12 PM JST
[^"\\]*(?:(?:\\.|"(?!""))[^"\\]*)*"""
* Sun 29 Sep 2013 06:20:45 PM JST
(\\*\\*=?|>>=?|<<=?|<>|!=|//=?|[+\\-*/%&|^=<>]=?|~)
* Sun 29 Sep 2013 09:04:25 PM JST
sbp.Popen
* Sun 29 Sep 2013 09:05:40 PM JST
Popen
* Sun 29 Sep 2013 09:14:19 PM JST
    def iter_chromewinids():
        r"""SUMMARY

        @Return:
        """
        for w in wm.iter_matchwin(klass='Google-chrome'):
            yield w.id


* Sun 29 Sep 2013 09:14:37 PM JST
list(iter_chromewinids())
* Sun 29 Sep 2013 10:26:20 PM JST
proxylist._URLS.get('speed')
* Sun 29 Sep 2013 10:26:29 PM JST
proxylist._URLS.get('anonymous')
* Sun 29 Sep 2013 10:27:37 PM JST
from ref.url import URLS
* Sun 29 Sep 2013 10:27:45 PM JST
proxylist.
* Sun 29 Sep 2013 10:27:47 PM JST
proxylist.
* Sun 29 Sep 2013 10:27:50 PM JST
proxylist.
* Sun 29 Sep 2013 10:27:52 PM JST
proxylist.
* Sun 29 Sep 2013 10:29:13 PM JST
speed
* Sun 29 Sep 2013 10:29:47 PM JST
URLS['proxy']['speed']
* Sun 29 Sep 2013 10:29:53 PM JST
URLS['proxy']['anonymous']
* Sun 29 Sep 2013 11:18:25 PM JST
wm.iter_matchwin(klass='Google-chrome')
* Sun 29 Sep 2013 11:26:41 PM JST

* Sun 29 Sep 2013 11:26:41 PM JST

* Sun 29 Sep 2013 11:26:41 PM JST
        # super(_WMActive, self).__init__(display=display)

* Sun 29 Sep 2013 11:31:51 PM JST

* Sun 29 Sep 2013 11:31:52 PM JST

* Sun 29 Sep 2013 11:31:52 PM JST
    for id_ in listids():

* Sun 29 Sep 2013 11:31:52 PM JST
    for id_ in listids():

* Sun 29 Sep 2013 11:31:52 PM JST
    for id_ in listids():
        win = WindowManager(id_)

* Sun 29 Sep 2013 11:32:55 PM JST
get
* Sun 29 Sep 2013 11:32:56 PM JST
get
* Sun 29 Sep 2013 11:32:56 PM JST
get
* Sun 29 Sep 2013 11:32:56 PM JST
get
* Mon 30 Sep 2013 12:43:19 AM JST
[+\\-*/%&|^=<>]=?
* Mon 30 Sep 2013 12:43:45 AM JST
(\\*\\*=?|>>=?|<<=?|<>|!=|//=?|[+\\-*/%&|^=<>]=?|~)
* Mon 30 Sep 2013 12:47:13 AM JST
(rx (or "+" "-" "/" "&" "^" "~" "|" "*" "<" ">"
                                       "=" "%" "**" "//" "<<" ">>" "<=" "!="
                                       "==" ">=" "is" "not"))
* Mon 30 Sep 2013 12:47:57 AM JST
'(\\*\\*=?|>>=?|<<=?|<>|!=|//=?|[+\\-*/%&|^=<>]=?|~)'
* Mon 30 Sep 2013 12:48:09 AM JST
'(\\*\\*=?|>>=?|<<=?|<>|!=|//=?|[+\\-*/%&|^=<>]=?|~)'
* Mon 30 Sep 2013 12:48:37 AM JST
(\\*\\*=?|>>=?|<<=?|<>|!=|//=?|[+\\-*/%&|^=<>]=?|~)
* Mon 30 Sep 2013 12:48:49 AM JST
(\\\\\\*\\\\\\*=\\?|>>=\\?|<<=\\?|<>|!=|//=\\?|\\[\\+\\\\-\\*/%&|\\^=<>]=\\?|~)
* Mon 30 Sep 2013 12:50:00 AM JST
(r"\*\*=?", r">>=?", r"<<=?", r"<>", r"!=",
                 r"//=?",
                 r"[+\-*/%&|^=<>]=?",
                 r"~")
* Mon 30 Sep 2013 12:50:33 AM JST
  
* Mon 30 Sep 2013 12:50:37 AM JST
r
* Mon 30 Sep 2013 12:50:37 AM JST
  r
* Mon 30 Sep 2013 12:50:48 AM JST
"\\(?:!=\\|\\*\\*=\\?\\|//=\\?\\|<\\(?:<=\\?\\|>\\)\\|>>=\\?\\|\\[\\+-\\*/%&|\\^=<>]=\\?\\|~\\)"
* Mon 30 Sep 2013 12:52:48 AM JST
hello **=a8
* Mon 30 Sep 2013 01:03:05 AM JST
"\\(?:!=\\|\\*\\*=\\?\\|//=\\?\\|<\\(?:<=\\?\\|>\\)\\|>>=\\?\\|\\[\\+-\\*/%&|\\^=<>]=\\?\\|~\\)"
* Mon 30 Sep 2013 01:11:48 AM JST
use '
* Mon 30 Sep 2013 01:11:48 AM JST
not use '
* Mon 30 Sep 2013 01:11:48 AM JST
Do not use '
* Mon 30 Sep 2013 01:15:20 AM JST
"\\(?:\\*\\*=?\\|>>=?\\|<<=?\\|<>\\|!=\\|//=?\\|[-*/%&|^=<>+]=?\\)\\|~"
* Mon 30 Sep 2013 01:26:27 AM JST
(rx (or "+" "-" "/" "&" "^" "~" "|" "*" "<" ">"
                                       "=" "%" "**" "//" "<<" ">>" "<=" "!="
                                       "==" ">=" "is" "not"))
* Mon 30 Sep 2013 01:29:01 AM JST
(rx (or "+" "-" "/" "&" "^" "~" "|" "*" "<" ">"
                                       "=" "%" "**" "//" "<<" ">>" "<=" "!="
                                       "==" ">=" "is" "not"))
* Mon 30 Sep 2013 01:29:19 AM JST
operator 
* Mon 30 Sep 2013 01:29:32 AM JST
(rx (or "=" "+=" "-=" "*=" "/=" "//=" "%=" "**="
                                       ">>=" "<<=" "&=" "^=" "|="))
* Mon 30 Sep 2013 01:30:13 AM JST
(rx (and
                                ;; Match even number of backslashes.
                                (or (not (any ?\\ ?\' ?\")) point
                                    ;; Quotes might be preceded by a escaped quote.
                                    (and (or (not (any ?\\)) point) ?\\
                                         (* ?\\ ?\\) (any ?\' ?\")))
                                (* ?\\ ?\\)
                                ;; Match single or triple quotes of any kind.
                                (group (or  "\"" "\"\"\"" "'" "'''"))))
* Mon 30 Sep 2013 01:31:13 AM JST
"\\(?:[
* Mon 30 Sep 2013 01:31:15 AM JST
"\\(?:[^\"'\\]\\|\\=\\|\\(?:[^\\]\\|\\=\\)\\\\\\(?:\\\\\\\\\\)*[\"']\\)\\(?:\\\\\\\\\\)*\\(\\(?:\"\"\"\\|'''\\|[\"']\\)\\)"
* Mon 30 Sep 2013 01:33:25 AM JST
(rx
                                (not
                                 (any ?+ ?- ?/ ?& ?^ ?~ ?| ?* ?< ?> ?= ?%)))
* Mon 30 Sep 2013 01:34:58 AM JST

* Mon 30 Sep 2013 01:34:58 AM JST

* Mon 30 Sep 2013 01:34:58 AM JST
"[^-%&*+/<->^|~]"

* Mon 30 Sep 2013 01:35:37 AM JST
(simple-operator      . ,(rx (any ?+ ?- ?/ ?& ?^ ?~ ?| ?* ?< ?> ?= ?%)))
* Mon 30 Sep 2013 01:35:43 AM JST
(simple-operator      . ,
* Mon 30 Sep 2013 01:36:15 AM JST
(rx (any ?+ ?- ?/ ?& ?^ ?~ ?| ?* ?< ?> ?= ?%))
* Mon 30 Sep 2013 01:36:41 AM JST
(rx
                                (not
                                 (any ?+ ?- ?/ ?& ?^ ?~ ?| ?* ?< ?> ?= ?%)))
* Mon 30 Sep 2013 01:36:45 AM JST
                                
* Mon 30 Sep 2013 01:36:47 AM JST
                                 
* Mon 30 Sep 2013 01:37:33 AM JST
(rx symbol-start
                                   (or "def" "class" "if" "elif" "else" "try"
                                       "except" "finally" "for" "while" "with")
                                   symbol-end)
* Mon 30 Sep 2013 01:37:50 AM JST
                                   
* Mon 30 Sep 2013 01:37:57 AM JST
(rx symbol-start (or "def" "class" "if" "elif" "else" "try"
"except" "finally" "for" "while" "with")
symbol-end)
* Mon 30 Sep 2013 01:38:31 AM JST
(rx line-start (* space) ?@ (any letter ?_)
                                   (* (any word ?_)))
* Mon 30 Sep 2013 01:39:10 AM JST
"^[[:space:]]*@[_[:alpha:]][_[:word:]]*"
* Mon 30 Sep 2013 01:46:55 AM JST
(rx line-start (* space) ?@ (any letter ?_)
    (* (any word ?_)))
* Mon 30 Sep 2013 01:48:31 AM JST
(rx line-start "if" (+ space) "__name__"
                                   (+ space) "==" (+ space)
                                   (any ?' ?\") "__main__" (any ?' ?\")
                                   (* space) ?:)
* Mon 30 Sep 2013 01:50:14 AM JST
(rx line-start "if" (+ space) "__name__"
    (+ space) "==" (+ space)
    (any ?' ?\") "__main__" (any ?' ?\")
    (* space) ?:)
* Mon 30 Sep 2013 01:50:39 AM JST
(rx (any letter ?_) (* (any word ?_)))
* Mon 30 Sep 2013 01:51:24 AM JST
open-paren
* Mon 30 Sep 2013 01:51:31 AM JST
(rx (or "{" "[" "("))
* Mon 30 Sep 2013 01:51:39 AM JST
close-paren
* Mon 30 Sep 2013 01:51:45 AM JST
open-paren
(rx (or "{" "[" "("))

close-paren


* Mon 30 Sep 2013 01:51:51 AM JST
(rx (or "}" "]" ")"))
* Mon 30 Sep 2013 02:25:32 AM JST
python-indent-dedent-line-backspace
* Mon 30 Sep 2013 02:26:19 AM JST
(global-set-key (kbd "s-p"
* Mon 30 Sep 2013 02:27:47 AM JST
python-indent-shift-left
* Mon 30 Sep 2013 02:28:34 AM JST
    
* Mon 30 Sep 2013 02:29:27 AM JST
python-indent-shift-right
* Mon 30 Sep 2013 02:29:48 AM JST
    
* Mon 30 Sep 2013 02:32:16 AM JST

* Mon 30 Sep 2013 02:32:20 AM JST
left
* Mon 30 Sep 2013 02:32:21 AM JST
shift-left
* Mon 30 Sep 2013 02:32:36 AM JST
    
* Mon 30 Sep 2013 02:32:39 AM JST
right
* Mon 30 Sep 2013 02:32:39 AM JST
shift-right
* Mon 30 Sep 2013 02:32:39 AM JST
py-shift-right
* Mon 30 Sep 2013 02:33:25 AM JST
python-indent-dedent-line
* Mon 30 Sep 2013 02:33:34 AM JST

* Mon 30 Sep 2013 02:33:41 AM JST
    
* Mon 30 Sep 2013 03:00:00 AM JST
(python-rx line-start (* space) defun (+ space) (group symbol-name))
* Mon 30 Sep 2013 03:00:22 AM JST
python-nav-beginning-of-defun-regexp
* Mon 30 Sep 2013 04:11:22 AM JST
(rx (and
                                ;; Match even number of backslashes.
                                (or (not (any ?\\ ?\' ?\")) point
                                    ;; Quotes might be preceded by a escaped quote.
                                    (and (or (not (any ?\\)) point) ?\\
                                         (* ?\\ ?\\) (any ?\' ?\")))
                                (* ?\\ ?\\)
                                ;; Match single or triple quotes of any kind.
                                (group (or  "\"" "\"\"\"" "'" "'''"))))
* Mon 30 Sep 2013 04:11:56 AM JST
(rx (and
;; Match even number of backslashes.
(or (not (any ?\\ ?\' ?\")) point
;; Quotes might be preceded by a escaped quote.
(and (or (not (any ?\\)) point) ?\\
(* ?\\ ?\\) (any ?\' ?\")))
(* ?\\ ?\\)
;; Match single or triple quotes of any kind.
(group (or  "\"" "\"\"\"" "'" "'''"))))
* Mon 30 Sep 2013 04:19:15 AM JST
py-blank-or-comment-re "[ \t]*\\($\\|#\\)"
* Mon 30 Sep 2013 04:20:49 AM JST
py-block-closing-keywords-re
  "[ \t]*\\_<\\(return\\|raise\\|break\\|continue\\|pass\\)\\_>[ \n\t]"
* Mon 30 Sep 2013 04:21:12 AM JST
from python-mode.el
* Mon 30 Sep 2013 04:21:26 AM JST
py-block-closing-keywords-re
  "[ \t]*\\_<\\(return\\|raise\\|break\\|continue\\|pass\\)\\_>[ \n\t]"
* Mon 30 Sep 2013 04:21:35 AM JST
from python-mode.el
* Mon 30 Sep 2013 04:21:45 AM JST
py-finally-re
* Mon 30 Sep 2013 04:21:48 AM JST
"[ \t]*\\_<finally\\_>[: \n\t]"
* Mon 30 Sep 2013 04:22:05 AM JST
py-except-re
  "[ \t]*\\_<except\\_>[: \n\t]"
* Mon 30 Sep 2013 04:22:16 AM JST
py-else-re
  "[ \t]*\\_<else\\_>[: \n\t]"
* Mon 30 Sep 2013 04:22:23 AM JST
py-return-re
  ".*:?[ \t]*\\_<\\(return\\)\\_>[ \n\t]"
* Mon 30 Sep 2013 04:22:35 AM JST
py-no-outdent-re "\\(try:\\|except\\(\\s +.*\\)?:\\|while\\s +.*:\\|for\\s +.*:\\|if\\s +.*:\\|elif\\s +.*:\\)\\([ 	]*\\_<\\(return\\|raise\\|break\\|continue\\|pass\\)\\_>[ 	\n]\\)")
* Mon 30 Sep 2013 04:24:27 AM JST
(defconst py-assignment-re "\\_<\\w+\\_>[ \t]*\\(=\\|+=\\|*=\\|%=\\|&=\\|^=\\|<<=\\|-=\\|/=\\|**=\\||=\\|>>=\\|//=\\)"
  "If looking at the beginning of an assignment. ")

(defconst py-block-re "[ \t]*\\_<\\(class\\|def\\|for\\|if\\|try\\|while\\|with\\)\\_>[: \n\t]"
  "Matches the beginning of a compound statement. ")

(defconst py-minor-block-re "[ \t]*\\_<\\(for\\|if\\|try\\|with\\)\\_>[: \n\t]"
  "Matches the beginning of an `for', `if', `try' or `with' block. ")

(defconst py-try-block-re "[ \t]*\\_<try\\_>[: \n\t]"
  "Matches the beginning of an `if' or `try' block. ")

(defconst py-class-re "[ \t]*\\_<\\(class\\)\\_>[ \n\t]"
  "Matches the beginning of a class definition. ")

(defconst py-def-or-class-re "[ \t]*\\_<\\(def\\|class\\)\\_>[ \n\t]"
  "Matches the beginning of a class- or functions definition. ")

(defconst py-def-re "[ \t]*\\_<\\(def\\)\\_>[ \n\t]"
  "Matches the beginning of a functions definition. ")

(defconst py-block-or-clause-re "[ \t]*\\_<\\(def\\|class\\|if\\|else\\|elif\\|while\\|for\\|try\\|except\\|finally\\|with\\)\\_>[: \n\t]"
  "Matches the beginning of a compound statement or it's clause. ")
;; (setq py-block-or-clause-re "[ \t]*\\_<\\(if\\|else\\|elif\\|while\\|for\\|try\\|except\\|finally\\|with\\)\\_>[: \n\t]")

(defconst py-extended-block-or-clause-re "[ \t]*\\_<\\(def\\|class\\|if\\|else\\|elif\\|while\\|for\\|try\\|except\\|finally\\|with\\)\\_>[: \n\t]"
  "Matches the beginning of a compound statement or it's clause.
Includes def and class. ")

(defconst py-clause-re "[ \t]*\\_<\\(else\\|elif\\|except\\|finally\\)\\_>[: \n\t]"
  "Matches the beginning of a compound statement's clause. ")
;; (setq py-clause-re "[ \t]*\\_<\\(else\\|elif\\|except\\|finally\\)\\_>[: \n\t]")

(defconst py-elif-re "[ \t]*\\_<\\elif\\_>[: \n\t]"
  "Matches the beginning of a compound if-statement's clause exclusively. ")

(defconst py-try-clause-re "[ \t]*\\_<\\(except\\|else\\|finally\\)\\_>[: \n\t]"
  "Matches the beginning of a compound try-statement's clause. ")

(defconst py-if-re "[ \t]*\\_<if\\_>[ \n\t]"
  "Matches the beginning of a compound statement saying `if'. ")

(defconst py-try-re "[ \t]*\\_<try\\_>[: \n\t]"
  "Matches the beginning of a compound statement saying `try'. " )

* Mon 30 Sep 2013 11:08:26 AM JST

* Mon 30 Sep 2013 11:08:26 AM JST

* Mon 30 Sep 2013 11:08:26 AM JST
del cmds, client

* Mon 30 Sep 2013 11:17:31 AM JST
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)
    format = '%(levelname)s: %(filename)s %(funcName)s(%(lineno)d): %(message)s'
    rotating = RotatingFileHandler('/tmp/PyWO.log', 'a', 1024*50, 2)
    rotating.setFormatter(logging.Formatter(format))
    rotating.setLevel(logging.DEBUG)
    logger.addHandler(rotating)
    console = logging.StreamHandler()
    console.setLevel(logging.INFO)
    logger.addHandler(console)

* Mon 30 Sep 2013 11:20:27 AM JST
'%(asctime)s,%(levelname)s,line:%(lineno)d,func:%(funcName)s,'
             'mod:%(module)s,%(message)s'
* Mon 30 Sep 2013 11:20:57 AM JST
             
* Mon 30 Sep 2013 11:21:39 AM JST
%(funcName)s
* Mon 30 Sep 2013 11:21:49 AM JST
%(module)s
* Mon 30 Sep 2013 11:22:37 AM JST
'%(levelname)s: %(filename)s %(funcName)s(%(lineno)d): %(message)s'
* Mon 30 Sep 2013 11:23:52 AM JST
${3:$$(yas/choose-value '("NOTSET" "DEBUG" "INFO" "WARN" "ERROR" "FATAL"))}
* Mon 30 Sep 2013 11:24:34 AM JST
${2:'/var/log'}
* Mon 30 Sep 2013 11:24:49 AM JST
logpath = os.path.join(logdir, logname)
* Mon 30 Sep 2013 11:26:05 AM JST
'${4:$$(yas/choose-value '("w" "a"))}'
* Mon 30 Sep 2013 11:26:52 AM JST
${1:$$(yas/choose-value '("NOTSET" "DEBUG" "INFO" "WARN" "ERROR" "FATAL"))})
* Mon 30 Sep 2013 11:26:58 AM JST
${1:$$(yas/choose-value '("NOTSET" "DEBUG" "INFO" "WARN" "ERROR" "FATAL"))}
* Mon 30 Sep 2013 11:33:19 AM JST
(rx line-start "if" (+ space) "__name__"
    (+ space) "==" (+ space)
    (any ?' ?\") "__main__" (any ?' ?\")
    (* space) ?:)
* Mon 30 Sep 2013 11:36:14 AM JST
    
* Mon 30 Sep 2013 11:36:25 AM JST
(insert "\n" (make-string (current-indentation) 32))
* Mon 30 Sep 2013 11:37:24 AM JST
(insert "_logging_setup()" (make-string (current-indentation) 32))
* Mon 30 Sep 2013 11:38:07 AM JST
(make-string (current-indentation) 32)
* Mon 30 Sep 2013 11:38:20 AM JST
(insert "\n" (make-string (current-indentation) 32) "_logging_setup()")
* Mon 30 Sep 2013 11:40:05 AM JST

* Mon 30 Sep 2013 11:40:05 AM JST

* Mon 30 Sep 2013 11:40:05 AM JST
    pass

* Mon 30 Sep 2013 11:40:05 AM JST
    pass

* Mon 30 Sep 2013 11:40:05 AM JST
    pass
    return 0

* Mon 30 Sep 2013 11:41:19 AM JST
(when (re-search-forward "def[ \t]+_main.+:" nil 'noerror)
       (skip-chars-forward " \t\n")
       (when (looking-at "[\"']")
         (t1-forward-thing 1))
       (when (looking-at "$")
         (insert "\n" (make-string (current-indentation) 32)))
       (insert "parser = _predef_options()\n"
               (make-string (current-indentation) 32))
       (insert "opts = parser.parse_args()\n"
               (make-string (current-indentation) 32))
       (insert "parser.print_usage()"
               (make-string (current-indentation) 32)))
* Mon 30 Sep 2013 11:41:35 AM JST
  
* Mon 30 Sep 2013 11:42:02 AM JST
(save-excursion
     (goto-char (point-min))
     (when (re-search-forward "def[ \t]+_main.+:" nil 'noerror)
       (skip-chars-forward " \t\n")
       (when (looking-at "[\"']")
         (t1-forward-thing 1))
       (when (looking-at "$")
         (insert "\n" (make-string (current-indentation) 32)))
       (insert "parser = _predef_options()\n"
               (make-string (current-indentation) 32))
       (insert "opts = parser.parse_args()\n"
               (make-string (current-indentation) 32))
       (insert "parser.print_usage()"
               (make-string (current-indentation) 32))))
* Mon 30 Sep 2013 11:42:23 AM JST
    
* Mon 30 Sep 2013 11:42:26 AM JST
n
* Mon 30 Sep 2013 11:42:26 AM JST
args()\n
* Mon 30 Sep 2013 11:42:26 AM JST
parse_args()\n
* Mon 30 Sep 2013 11:42:26 AM JST
parser.parse_args()\n
* Mon 30 Sep 2013 11:42:26 AM JST
opts = parser.parse_args()\n
* Mon 30 Sep 2013 11:42:45 AM JST
(save-excursion
  (goto-char (point-min))
  (when (re-search-forward "def[ \t]+_main.+:" nil 'noerror)
    (skip-chars-forward " \t\n")
    (when (looking-at "[\"']")
      (t1-forward-thing 1))
    (when (looking-at "$")
      (insert "\n" (make-string (current-indentation) 32)))
    (insert "_logging_setup()"
            (make-string (current-indentation) 32))))
* Mon 30 Sep 2013 11:46:23 AM JST
(py--insert-imports "argparse" "import argparse")
* Mon 30 Sep 2013 11:46:32 AM JST
argparse
* Mon 30 Sep 2013 11:46:37 AM JST
argparse
* Mon 30 Sep 2013 11:46:52 AM JST
_logging_setup()   
* Mon 30 Sep 2013 11:47:44 AM JST

* Mon 30 Sep 2013 11:47:44 AM JST

* Mon 30 Sep 2013 11:47:44 AM JST
import logging

* Mon 30 Sep 2013 11:47:47 AM JST

* Mon 30 Sep 2013 11:47:47 AM JST

* Mon 30 Sep 2013 11:47:47 AM JST
    _logging_setup()

* Mon 30 Sep 2013 11:49:43 AM JST

* Mon 30 Sep 2013 11:49:43 AM JST

* Mon 30 Sep 2013 11:49:43 AM JST
    logfmt = '%(asctime)s;%(levelname)s;%(module)s %(funcName)s(%(lineno)d);%(message)s'

* Mon 30 Sep 2013 11:54:32 AM JST
%(levelname)s
* Mon 30 Sep 2013 11:54:40 AM JST
%(module)s %(funcName)s(%(lineno)d)
* Mon 30 Sep 2013 11:55:01 AM JST
%(message)s
* Mon 30 Sep 2013 11:55:07 AM JST

* Mon 30 Sep 2013 11:55:07 AM JST

* Mon 30 Sep 2013 11:55:07 AM JST
    logfmt = '%(asctime)s;%(levelname)s;%(module)s %(funcName)s(%(lineno)d);%(message)s'

* Mon 30 Sep 2013 11:55:25 AM JST
    logfmt = ';'.join(['%(asctime)s', '%(levelname)s',
                       '%(module)s %(funcName)s(%(lineno)d)', '%(message)s'])

* Mon 30 Sep 2013 11:55:37 AM JST
    logfmt = ';'.join(['%(asctime)s', '%(levelname)s',
                       '%(module)s %(funcName)s(%(lineno)d)', '%(message)s'])

* Mon 30 Sep 2013 11:57:41 AM JST
# log rotate
* Mon 30 Sep 2013 11:57:49 AM JST
# console
* Mon 30 Sep 2013 11:58:44 AM JST

* Mon 30 Sep 2013 11:58:44 AM JST

* Mon 30 Sep 2013 11:58:44 AM JST
    pass

* Mon 30 Sep 2013 12:00:40 PM JST

* Mon 30 Sep 2013 12:00:40 PM JST

* Mon 30 Sep 2013 12:00:40 PM JST
    _logging_setup()

* Mon 30 Sep 2013 12:02:01 PM JST
# rotate level
* Mon 30 Sep 2013 12:03:21 PM JST

* Mon 30 Sep 2013 12:03:21 PM JST

* Mon 30 Sep 2013 12:03:21 PM JST
    _logging_setup()

* Mon 30 Sep 2013 12:05:13 PM JST
logging.handlers import RotatingFileHandler
* Mon 30 Sep 2013 12:06:22 PM JST
rotate
* Mon 30 Sep 2013 12:06:22 PM JST
log rotate
* Mon 30 Sep 2013 12:10:12 PM JST
"NOTSET" 
* Mon 30 Sep 2013 12:10:16 PM JST
"NOTSET" 
* Mon 30 Sep 2013 12:10:25 PM JST
"NOTSET" 
* Mon 30 Sep 2013 12:10:33 PM JST
"INFO" 
* Mon 30 Sep 2013 12:13:28 PM JST
logging.log(logging.${1:$$(yas/choose-value '("DEBUG" "INFO" "WARN" "ERROR" "FATAL"))}, ${2:TEXT})
* Mon 30 Sep 2013 12:14:12 PM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Mon 30 Sep 2013 12:14:24 PM JST
debug
* Mon 30 Sep 2013 12:14:26 PM JST
debug
* Mon 30 Sep 2013 12:14:31 PM JST
debug
* Mon 30 Sep 2013 12:15:05 PM JST
"DEBUG" "INFO" "WARN" "ERROR" "FATAL"
* Mon 30 Sep 2013 12:15:34 PM JST
info
* Mon 30 Sep 2013 12:15:38 PM JST
info
* Mon 30 Sep 2013 12:15:44 PM JST
info
* Mon 30 Sep 2013 12:16:37 PM JST
warning
* Mon 30 Sep 2013 12:17:47 PM JST
warning
* Mon 30 Sep 2013 12:17:52 PM JST
warning
* Mon 30 Sep 2013 12:17:54 PM JST
warning
* Mon 30 Sep 2013 12:19:09 PM JST
warning
* Mon 30 Sep 2013 12:19:12 PM JST
warning
* Mon 30 Sep 2013 12:19:18 PM JST
warning
* Mon 30 Sep 2013 12:19:38 PM JST
critical
* Mon 30 Sep 2013 12:22:05 PM JST
logging
* Mon 30 Sep 2013 12:24:28 PM JST
RotatingFileHandler
* Mon 30 Sep 2013 12:25:35 PM JST
RotatingFileHandler
* Mon 30 Sep 2013 12:25:38 PM JST
handlers.
* Mon 30 Sep 2013 12:25:38 PM JST
logging.handlers.
* Mon 30 Sep 2013 12:27:35 PM JST
 # General level
* Mon 30 Sep 2013 12:27:37 PM JST
 # rotate level
* Mon 30 Sep 2013 12:27:44 PM JST
 # console level
* Mon 30 Sep 2013 12:27:59 PM JST

* Mon 30 Sep 2013 12:27:59 PM JST

* Mon 30 Sep 2013 12:27:59 PM JST
    _logging_setup()

* Mon 30 Sep 2013 12:37:01 PM JST
.critical
* Mon 30 Sep 2013 12:37:11 PM JST
.debug
* Mon 30 Sep 2013 12:37:18 PM JST
.error
* Mon 30 Sep 2013 12:37:25 PM JST
.fatal
* Mon 30 Sep 2013 12:37:30 PM JST
.info
* Mon 30 Sep 2013 12:37:37 PM JST
.log
* Mon 30 Sep 2013 12:37:39 PM JST
.log
* Mon 30 Sep 2013 12:37:48 PM JST
.warning
* Mon 30 Sep 2013 12:38:22 PM JST

* Mon 30 Sep 2013 12:38:22 PM JST

* Mon 30 Sep 2013 12:38:22 PM JST
    ("\C-i"           'python-indent-dedent-line)

* Mon 30 Sep 2013 12:38:24 PM JST

* Mon 30 Sep 2013 12:38:24 PM JST

* Mon 30 Sep 2013 12:38:24 PM JST
    ("\C-i"           'python-indent-dedent-line)

* Mon 30 Sep 2013 12:38:25 PM JST

* Mon 30 Sep 2013 12:38:25 PM JST

* Mon 30 Sep 2013 12:38:25 PM JST
    ((kbd "TAB")      'python-indent-dedent-line)

* Mon 30 Sep 2013 12:39:25 PM JST

* Mon 30 Sep 2013 12:39:25 PM JST

* Mon 30 Sep 2013 12:39:25 PM JST
    logging.info('hello')

* Mon 30 Sep 2013 12:39:58 PM JST
.log(logging.DEBUG, TEXT)
* Mon 30 Sep 2013 12:40:04 PM JST

* Mon 30 Sep 2013 12:40:04 PM JST

* Mon 30 Sep 2013 12:40:05 PM JST
    logging.log(logging.DEBUG, TEXT)

* Mon 30 Sep 2013 12:40:37 PM JST
# condition: (and (not (python-in-string/comment)) (not (equal (this-command-keys-vector) [32])))
* Mon 30 Sep 2013 12:41:07 PM JST
logging.
* Mon 30 Sep 2013 12:41:34 PM JST
logging.
* Mon 30 Sep 2013 12:42:09 PM JST
logging.
* Mon 30 Sep 2013 12:42:19 PM JST
logging.
* Mon 30 Sep 2013 12:42:38 PM JST
logging.
* Mon 30 Sep 2013 12:42:45 PM JST
logging.
* Mon 30 Sep 2013 12:43:20 PM JST
(not (equal (this-command-keys-vector) [32]))
* Mon 30 Sep 2013 12:45:05 PM JST

* Mon 30 Sep 2013 12:45:05 PM JST

* Mon 30 Sep 2013 12:45:05 PM JST
    logging.warning(TEXT)

* Mon 30 Sep 2013 12:46:55 PM JST

* Mon 30 Sep 2013 12:46:55 PM JST

* Mon 30 Sep 2013 12:46:55 PM JST
    logging.

* Mon 30 Sep 2013 12:48:33 PM JST

* Mon 30 Sep 2013 12:48:33 PM JST

* Mon 30 Sep 2013 12:48:33 PM JST
    logging.error(hello)

* Mon 30 Sep 2013 12:48:53 PM JST
logging.
* Mon 30 Sep 2013 12:51:21 PM JST
TEXT
* Mon 30 Sep 2013 12:53:30 PM JST
.yasnippet
* Mon 30 Sep 2013 12:56:11 PM JST
 (logging)
* Mon 30 Sep 2013 12:56:18 PM JST
    (logging)
* Mon 30 Sep 2013 12:56:28 PM JST
     (logging)
* Mon 30 Sep 2013 12:56:42 PM JST
logging)
* Mon 30 Sep 2013 01:02:34 PM JST
DEBUG
* Mon 30 Sep 2013 01:03:56 PM JST
DEBUG
* Mon 30 Sep 2013 01:04:00 PM JST
ERROR
* Mon 30 Sep 2013 01:11:51 PM JST
"DEBUG" 
* Mon 30 Sep 2013 01:12:15 PM JST
ERROR
* Mon 30 Sep 2013 01:13:28 PM JST
hello
* Mon 30 Sep 2013 01:13:31 PM JST
is 
* Mon 30 Sep 2013 01:13:31 PM JST
this is 
* Mon 30 Sep 2013 01:13:38 PM JST
hello
* Mon 30 Sep 2013 01:13:42 PM JST
hello
* Mon 30 Sep 2013 01:13:46 PM JST
hello
* Mon 30 Sep 2013 01:13:58 PM JST
hello
* Mon 30 Sep 2013 01:14:09 PM JST
hello
* Mon 30 Sep 2013 01:14:11 PM JST
world
* Mon 30 Sep 2013 01:22:39 PM JST
'{0:*^30}'.format(' daily start ')
* Mon 30 Sep 2013 01:22:40 PM JST

* Mon 30 Sep 2013 01:22:41 PM JST

* Mon 30 Sep 2013 01:22:41 PM JST
    logging.log(10, )

* Mon 30 Sep 2013 01:23:01 PM JST
'We will try rss.'
* Mon 30 Sep 2013 01:23:03 PM JST

* Mon 30 Sep 2013 01:23:03 PM JST

* Mon 30 Sep 2013 01:23:03 PM JST
        logging.log(10, )

* Mon 30 Sep 2013 01:23:11 PM JST
10, 
* Mon 30 Sep 2013 01:23:15 PM JST
log
* Mon 30 Sep 2013 01:23:17 PM JST
10, 
* Mon 30 Sep 2013 01:23:34 PM JST
log
* Mon 30 Sep 2013 01:23:41 PM JST
DEBUG, 
* Mon 30 Sep 2013 01:23:41 PM JST
logging.DEBUG, 
* Mon 30 Sep 2013 01:23:49 PM JST
log
* Mon 30 Sep 2013 01:23:51 PM JST
INFO, 
* Mon 30 Sep 2013 01:23:52 PM JST
logging.INFO, 
* Mon 30 Sep 2013 01:23:58 PM JST
log
* Mon 30 Sep 2013 01:24:01 PM JST
INFO, 
* Mon 30 Sep 2013 01:24:01 PM JST
logging.INFO, 
* Mon 30 Sep 2013 01:24:09 PM JST
INFO, 
* Mon 30 Sep 2013 01:24:09 PM JST
logging.INFO, 
* Mon 30 Sep 2013 01:24:24 PM JST
log
* Mon 30 Sep 2013 01:24:28 PM JST
INFO, 
* Mon 30 Sep 2013 01:24:28 PM JST
logging.INFO, 
* Mon 30 Sep 2013 01:24:33 PM JST
log
* Mon 30 Sep 2013 01:24:36 PM JST
DEBUG, 
* Mon 30 Sep 2013 01:24:37 PM JST
logging.DEBUG, 
* Mon 30 Sep 2013 01:24:43 PM JST
DEBUG, 
* Mon 30 Sep 2013 01:24:43 PM JST
logging.DEBUG, 
* Mon 30 Sep 2013 01:24:45 PM JST
log
* Mon 30 Sep 2013 01:24:51 PM JST
log
* Mon 30 Sep 2013 01:24:54 PM JST
DEBUG, 
* Mon 30 Sep 2013 01:24:54 PM JST
logging.DEBUG, 
* Mon 30 Sep 2013 01:25:02 PM JST
log
* Mon 30 Sep 2013 01:25:07 PM JST
log
* Mon 30 Sep 2013 01:25:11 PM JST
DEBUG,
* Mon 30 Sep 2013 01:25:11 PM JST
logging.DEBUG,
* Mon 30 Sep 2013 01:25:14 PM JST
DEBUG, 
* Mon 30 Sep 2013 01:25:14 PM JST
logging.DEBUG, 
* Mon 30 Sep 2013 01:25:33 PM JST
INFO, 
* Mon 30 Sep 2013 01:25:33 PM JST
logging.INFO, 
* Mon 30 Sep 2013 01:25:43 PM JST
INFO, 
* Mon 30 Sep 2013 01:25:44 PM JST
logging.INFO, 
* Mon 30 Sep 2013 01:25:49 PM JST
log
* Mon 30 Sep 2013 01:25:52 PM JST
DEBUG, 
* Mon 30 Sep 2013 01:25:53 PM JST
logging.DEBUG, 
* Mon 30 Sep 2013 01:26:18 PM JST
log
* Mon 30 Sep 2013 01:26:22 PM JST
10, 
* Mon 30 Sep 2013 01:31:52 PM JST
log
* Mon 30 Sep 2013 01:31:54 PM JST
10, 
* Mon 30 Sep 2013 01:32:15 PM JST
'\n\n{0:#^40}'.format(' Auto clean Downloads ')
* Mon 30 Sep 2013 01:32:18 PM JST

* Mon 30 Sep 2013 01:32:18 PM JST

* Mon 30 Sep 2013 01:32:18 PM JST
    logging.info('\n\n{0:#^40}'.format(' Auto clean Downloads '))

* Mon 30 Sep 2013 01:32:19 PM JST

* Mon 30 Sep 2013 01:32:19 PM JST

* Mon 30 Sep 2013 01:32:19 PM JST
    print()

* Mon 30 Sep 2013 01:32:37 PM JST
10, 
* Mon 30 Sep 2013 01:32:37 PM JST

* Mon 30 Sep 2013 01:32:37 PM JST

* Mon 30 Sep 2013 01:32:37 PM JST
        print(msg)

* Mon 30 Sep 2013 01:32:51 PM JST
'Will remove: {}'.format(', '.join(removable))
* Mon 30 Sep 2013 01:32:53 PM JST

* Mon 30 Sep 2013 01:32:53 PM JST

* Mon 30 Sep 2013 01:32:53 PM JST
        msg = 

* Mon 30 Sep 2013 01:33:07 PM JST
'\n\n{0:#^40}'.format(' Clean Downloads ')
* Mon 30 Sep 2013 01:33:09 PM JST

* Mon 30 Sep 2013 01:33:09 PM JST

* Mon 30 Sep 2013 01:33:09 PM JST
    print()

* Mon 30 Sep 2013 01:33:14 PM JST
10, 
* Mon 30 Sep 2013 01:33:19 PM JST
10, 
* Mon 30 Sep 2013 01:33:20 PM JST
log
* Mon 30 Sep 2013 01:33:22 PM JST
10, 
* Mon 30 Sep 2013 01:33:24 PM JST
log
* Mon 30 Sep 2013 01:33:35 PM JST
10, 
* Mon 30 Sep 2013 01:33:44 PM JST
10, 
* Mon 30 Sep 2013 01:33:44 PM JST
log
* Mon 30 Sep 2013 01:33:46 PM JST

* Mon 30 Sep 2013 01:33:46 PM JST

* Mon 30 Sep 2013 01:33:46 PM JST
        print(msg)

* Mon 30 Sep 2013 01:33:57 PM JST
10, 
* Mon 30 Sep 2013 01:33:57 PM JST
log
* Mon 30 Sep 2013 01:34:00 PM JST

* Mon 30 Sep 2013 01:34:00 PM JST

* Mon 30 Sep 2013 01:34:00 PM JST
        print('Failed: OSError, {}'.format(dir_))

* Mon 30 Sep 2013 01:34:05 PM JST
info
* Mon 30 Sep 2013 01:34:22 PM JST
fatal
* Mon 30 Sep 2013 01:34:34 PM JST
10, 
* Mon 30 Sep 2013 01:34:35 PM JST
log
* Mon 30 Sep 2013 01:34:39 PM JST
log
* Mon 30 Sep 2013 01:34:41 PM JST
10,
* Mon 30 Sep 2013 01:34:46 PM JST
'TimeoutError {}'.format(title)
* Mon 30 Sep 2013 01:34:51 PM JST

* Mon 30 Sep 2013 01:34:51 PM JST

* Mon 30 Sep 2013 01:34:51 PM JST
            msg = 

* Mon 30 Sep 2013 01:34:59 PM JST
info
* Mon 30 Sep 2013 01:35:21 PM JST
10, 
* Mon 30 Sep 2013 01:35:23 PM JST
log
* Mon 30 Sep 2013 01:35:28 PM JST
10, 
* Mon 30 Sep 2013 01:35:29 PM JST
log
* Mon 30 Sep 2013 01:35:36 PM JST
10, 
* Mon 30 Sep 2013 01:35:37 PM JST
log
* Mon 30 Sep 2013 01:35:50 PM JST
info
* Mon 30 Sep 2013 01:35:55 PM JST
info
* Mon 30 Sep 2013 01:36:09 PM JST
10, 
* Mon 30 Sep 2013 01:36:10 PM JST
log
* Mon 30 Sep 2013 01:36:15 PM JST
log
* Mon 30 Sep 2013 01:36:16 PM JST
10
* Mon 30 Sep 2013 01:36:20 PM JST

* Mon 30 Sep 2013 01:36:20 PM JST

* Mon 30 Sep 2013 01:36:20 PM JST
        print(msg)

* Mon 30 Sep 2013 01:36:23 PM JST
'Will remove: {}'.format(', '.join(removable))
* Mon 30 Sep 2013 01:36:25 PM JST

* Mon 30 Sep 2013 01:36:25 PM JST

* Mon 30 Sep 2013 01:36:25 PM JST
        msg = 

* Mon 30 Sep 2013 01:36:35 PM JST
print
* Mon 30 Sep 2013 01:37:12 PM JST
'Not mounted remote /data.'
* Mon 30 Sep 2013 01:37:24 PM JST
print
* Mon 30 Sep 2013 01:37:39 PM JST
'Failed: apt-get'
* Mon 30 Sep 2013 01:37:41 PM JST

* Mon 30 Sep 2013 01:37:41 PM JST

* Mon 30 Sep 2013 01:37:41 PM JST
        print()

* Mon 30 Sep 2013 01:38:17 PM JST

* Mon 30 Sep 2013 01:38:17 PM JST

* Mon 30 Sep 2013 01:38:17 PM JST
        print('Failed: ')

* Mon 30 Sep 2013 01:38:27 PM JST
print
* Mon 30 Sep 2013 01:38:34 PM JST
print
* Mon 30 Sep 2013 01:38:51 PM JST
print
* Mon 30 Sep 2013 01:39:28 PM JST
print
* Mon 30 Sep 2013 01:39:39 PM JST
print
* Mon 30 Sep 2013 01:40:02 PM JST
10, 
* Mon 30 Sep 2013 01:42:51 PM JST
system
* Mon 30 Sep 2013 01:42:52 PM JST
os.system
* Mon 30 Sep 2013 01:57:44 PM JST
(rx symbol-start (or "def" "class" "if" "elif" "else" "try"
"except" "finally" "for" "while" "with")
symbol-end)
* Mon 30 Sep 2013 01:57:51 PM JST
                             
* Mon 30 Sep 2013 01:58:50 PM JST
(rx line-start (* space) ?@ (any letter ?_)
    (* (any word ?_)))
* Mon 30 Sep 2013 01:59:17 PM JST
if-name-main
* Mon 30 Sep 2013 01:59:31 PM JST
(rx line-start "if" (+ space) "__name__"
    (+ space) "==" (+ space)
    (any ?' ?\") "__main__" (any ?' ?\")
    (* space) ?:)
* Mon 30 Sep 2013 02:00:04 PM JST

* Mon 30 Sep 2013 02:00:04 PM JST

* Mon 30 Sep 2013 02:00:04 PM JST
  ELSE

* Mon 30 Sep 2013 02:00:41 PM JST
open-paren
* Mon 30 Sep 2013 02:00:56 PM JST
(rx (or "{" "[" "("))
* Mon 30 Sep 2013 02:01:15 PM JST
paren
* Mon 30 Sep 2013 02:02:53 PM JST
(rx (or "}" "]" ")"))
* Mon 30 Sep 2013 02:03:34 PM JST
(rx (any ?+ ?- ?/ ?& ?^ ?~ ?| ?* ?< ?> ?= ?%))
* Mon 30 Sep 2013 02:04:37 PM JST
(rx (not (any ?+ ?- ?/ ?& ?^ ?~ ?| ?* ?< ?> ?= ?%)))
* Mon 30 Sep 2013 02:05:29 PM JST
(rx (or "+" "-" "/" "&" "^" "~" "|" "*" "<" ">"
"=" "%" "**" "//" "<<" ">>" "<=" "!="
"==" ">=" "is" "not"))
* Mon 30 Sep 2013 02:05:54 PM JST
assignment-operator
* Mon 30 Sep 2013 02:06:05 PM JST
(rx (or "=" "+=" "-=" "*=" "/=" "//=" "%=" "**="
                                       ">>=" "<<=" "&=" "^=" "|="))
* Mon 30 Sep 2013 02:07:04 PM JST
(rx (and
;; Match even number of backslashes.
(or (not (any ?\\ ?\' ?\")) point
;; Quotes might be preceded by a escaped quote.
(and (or (not (any ?\\)) point) ?\\
(* ?\\ ?\\) (any ?\' ?\")))
(* ?\\ ?\\)
;; Match single or triple quotes of any kind.
(group (or  "\"" "\"\"\"" "'" "'''"))))
* Mon 30 Sep 2013 02:07:39 PM JST
py-blank-or-comment-re
* Mon 30 Sep 2013 02:08:00 PM JST
"[ \t]*\\($\\|#\\)"
* Mon 30 Sep 2013 02:10:53 PM JST
(rx line-start (* space) ?@ (any letter ?_)
                                   (* (any word ?_)))
* Mon 30 Sep 2013 04:51:56 PM JST
(rx (* blank) (group (or line-end ?#)))
* Mon 30 Sep 2013 04:52:25 PM JST
py-block-closing-keywords-re
* Mon 30 Sep 2013 04:53:08 PM JST
"[ \t]*\\_<\\(return\\|raise\\|break\\|continue\\|pass\\)\\_>[ \n\t]"
* Mon 30 Sep 2013 04:53:32 PM JST
"[ \t]*\\_<\\(return\\|raise\\|break\\|continue\\|pass\\)\\_>[ \n\t]"
* Mon 30 Sep 2013 04:54:56 PM JST
word
* Mon 30 Sep 2013 04:55:02 PM JST
word
* Mon 30 Sep 2013 04:56:04 PM JST
group
* Mon 30 Sep 2013 04:56:38 PM JST
group 
* Mon 30 Sep 2013 04:56:56 PM JST
(or "return" "raise" "break" "continue" "pass")
* Mon 30 Sep 2013 04:57:29 PM JST
or
* Mon 30 Sep 2013 04:57:37 PM JST
group
* Mon 30 Sep 2013 05:00:05 PM JST
(rx (char "/n" "\t" " "))
* Mon 30 Sep 2013 05:00:41 PM JST
rx 
* Mon 30 Sep 2013 05:00:55 PM JST
"[[:blank:]]*\\_<\\(?:\\(?:break\\|continue\\|pass\\|r\\(?:aise\\|eturn\\)\\)\\)\\_>[	 /n]"
* Mon 30 Sep 2013 05:02:44 PM JST
(rx (* blank)
    symbol-start (or "return" "raise" "break" "continue" "pass") symbol-end
    (char "/n" "\t" " "))
* Mon 30 Sep 2013 05:03:06 PM JST
"[ \t]*\\_<\\(return\\|raise\\|break\\|continue\\|pass\\)\\_>[ \n\t]"
* Mon 30 Sep 2013 05:03:13 PM JST
                                           
* Mon 30 Sep 2013 05:03:30 PM JST
      
* Mon 30 Sep 2013 05:03:34 PM JST
      
* Mon 30 Sep 2013 05:03:42 PM JST
"[ \t]*\\_<\\(return\\|raise\\|break\\|continue\\|pass\\)\\_>[ \n\t]"
* Mon 30 Sep 2013 05:03:47 PM JST
(rx (* blank) symbol-start
      (or "return" "raise" "break" "continue" "pass") symbol-end
      (char "/n" "\t" " "))
* Mon 30 Sep 2013 05:04:30 PM JST
group
* Mon 30 Sep 2013 05:04:56 PM JST
"[[:blank:]]*\\_<\\(\\(?:break\\|continue\\|pass\\|r\\(?:aise\\|eturn\\)\\)\\)\\_>[	 /n]"
* Mon 30 Sep 2013 05:05:20 PM JST
(rx (* blank) symbol-start
    (group (or "return" "raise" "break" "continue" "pass")) symbol-end
    (char "/n" "\t" " "))
* Mon 30 Sep 2013 05:05:33 PM JST
py-finally-re
* Mon 30 Sep 2013 05:06:07 PM JST
"[ \t]*\\_<finally\\_>[: \n\t]"
* Mon 30 Sep 2013 05:07:29 PM JST
":"
* Mon 30 Sep 2013 05:07:36 PM JST
"\n"
* Mon 30 Sep 2013 05:08:08 PM JST
(rx (* blank) symbol-start "finally" symbol-end (char " " ":" "\t" "\n"))
* Mon 30 Sep 2013 05:08:58 PM JST
"Python finally keyword."
* Mon 30 Sep 2013 05:09:10 PM JST
py-except-re
* Mon 30 Sep 2013 05:09:41 PM JST
                           
* Mon 30 Sep 2013 05:09:52 PM JST
" " ":" "\t" "\n"
* Mon 30 Sep 2013 05:12:07 PM JST
()
* Mon 30 Sep 2013 05:12:10 PM JST
(rx (* blank)
                            symbol-start "finally" symbol-end
                            (char " " ":" "\t" "\n"))
* Mon 30 Sep 2013 05:12:14 PM JST
finally"
* Mon 30 Sep 2013 05:12:19 PM JST
  
* Mon 30 Sep 2013 05:17:44 PM JST
`(progn
     ,@(mapcar #'(lambda (arg)
                   `(define-key ,mode-map ,@arg)) body)))

* Mon 30 Sep 2013 05:17:59 PM JST
(defun py:closing-re-maker (keyword)
  "KEYWORD"
  (rx (* blank)
      symbol-start keyword symbol-end
      (char " " ":" "\t" "\n")))
* Mon 30 Sep 2013 05:19:22 PM JST

* Mon 30 Sep 2013 05:19:22 PM JST

* Mon 30 Sep 2013 05:19:22 PM JST
(py:closing-re-maker "finally")

* Mon 30 Sep 2013 05:19:43 PM JST

* Mon 30 Sep 2013 05:19:44 PM JST

* Mon 30 Sep 2013 05:19:44 PM JST
  `(progn

* Mon 30 Sep 2013 05:26:48 PM JST

* Mon 30 Sep 2013 05:26:48 PM JST

* Mon 30 Sep 2013 05:26:48 PM JST
  `(progn

* Mon 30 Sep 2013 05:26:59 PM JST
(defmacro py:closing-re-maker (keyword)
  "KEYWORD"
  `(rx (* blank)
       symbol-start ,keyword symbol-end
       (char " " ":" "\t" "\n")))
* Mon 30 Sep 2013 05:27:54 PM JST
macro
* Mon 30 Sep 2013 05:30:42 PM JST
(py:closing-re-maker "else")
* Mon 30 Sep 2013 05:30:52 PM JST
(py:closing-re-maker "except")
* Mon 30 Sep 2013 05:32:32 PM JST
"\\(try:\\|except\\(\\s +.*\\)?:\\|while\\s +.*:\\|for\\s +.*:\\|if\\s +.*:\\|elif\\s +.*:\\)\\([ 	]*\\_<\\(return\\|raise\\|break\\|continue\\|pass\\)\\_>[ 	\n]\\)")
* Mon 30 Sep 2013 05:39:37 PM JST
\\(try:\\|except\\(\\s +.*\\)?:\\|while\\s +.*:\\|for\\s +.*:\\|if\\s +.*:\\|elif\\s +.*:\\)
* Mon 30 Sep 2013 05:41:38 PM JST
\\([ 	]*\\_<\\(return\\|raise\\|break\\|continue\\|pass\\)\\_>[ 	\n]\\)
* Mon 30 Sep 2013 05:48:38 PM JST
py-no-outdent-re
* Mon 30 Sep 2013 05:50:00 PM JST
try: print('hello'): except print()
* Mon 30 Sep 2013 05:50:20 PM JST
"\\(try:\\|except\\(\\s +.*\\)?:\\|while\\s +.*:\\|for\\s +.*:\\|if\\s +.*:\\|elif\\s +.*:\\)\\([ 	]*\\_<\\(return\\|raise\\|break\\|continue\\|pass\\)\\_>[ 	\n]\\)"
* Mon 30 Sep 2013 05:52:23 PM JST
"\\(try:\\|except\\(\\s +.*\\)?:\\|while\\s +.*:\\|for\\s +.*:\\|if\\s +.*:\\|elif\\s +.*:\\)\\([ 	]*\\_<\\(return\\|raise\\|break\\|continue\\|pass\\)\\_>[ 	\n]\\)"


* Mon 30 Sep 2013 06:04:46 PM JST
any 
* Mon 30 Sep 2013 06:06:02 PM JST
"except"
* Mon 30 Sep 2013 06:07:50 PM JST
"except"
* Mon 30 Sep 2013 06:27:15 PM JST
"except" 
* Mon 30 Sep 2013 06:27:42 PM JST
"\\(try:\\|except\\(\\s +.*\\)?:\\|while\\s +.*:\\|for\\s +.*:\\|if\\s +.*:\\|elif\\s +.*:\\)\\([ 	]*\\_<\\(return\\|raise\\|break\\|continue\\|pass\\)\\_>[ 	\n]\\)"
* Mon 30 Sep 2013 06:32:18 PM JST
(defconst py-assignment-re "\\_<\\w+\\_>[ \t]*\\(=\\|+=\\|*=\\|%=\\|&=\\|^=\\|<<=\\|-=\\|/=\\|**=\\||=\\|>>=\\|//=\\)"
  "If looking at the beginning of an assignment. ")
* Mon 30 Sep 2013 06:33:31 PM JST
(rx (or "=" "+=" "-=" "*=" "/=" "//=" "%=" "**="
                                            ">>=" "<<=" "&=" "^=" "|="))
* Mon 30 Sep 2013 06:33:51 PM JST
"\\_<\\w+\\_>[ \t]*\\(=\\|+=\\|*=\\|%=\\|&=\\|^=\\|<<=\\|-=\\|/=\\|**=\\||=\\|>>=\\|//=\\)"
* Mon 30 Sep 2013 06:34:32 PM JST
\\_<\\w+\\_>[ \t]*
* Mon 30 Sep 2013 06:34:42 PM JST
\\(?:\\(?:\\*\\*\\|//\\|<<\\|>>\\|[%&*+/|^-]\\)?=\\)
* Mon 30 Sep 2013 06:34:45 PM JST
"\\_<\\w+\\_>[ \t]*\\(?:\\(?:\\*\\*\\|//\\|<<\\|>>\\|[%&*+/|^-]\\)?=\\)"
* Mon 30 Sep 2013 06:36:24 PM JST
"\\_<[[:word:]]+\\_>"
* Mon 30 Sep 2013 06:37:16 PM JST
(rx symbol-start (+ word) symbol-end)
* Mon 30 Sep 2013 06:37:39 PM JST
(concat (rx symbol-start (+ word) symbol-end)
                                        py:assignment-operator-re)
* Mon 30 Sep 2013 06:37:51 PM JST
"\\_<[[:word:]]+\\_>\\(?:\\(?:\\*\\*\\|//\\|<<\\|>>\\|[%&*+/|^-]\\)?=\\)"
* Mon 30 Sep 2013 11:19:14 PM JST
"[ \t]*\\_<\\(class\\|def\\|for\\|if\\|try\\|while\\|with\\)\\_>[: \n\t]"
* Mon 30 Sep 2013 11:19:30 PM JST
blank
* Mon 30 Sep 2013 11:21:16 PM JST
"[[:blank:]]*\\_<\\(\\(?:class\\|def\\|for\\|if\\|try\\|w\\(?:hile\\|ith\\)\\)\\)\\_>[	
 :]"
* Mon 30 Sep 2013 11:21:58 PM JST
(rx (* blank) symbol-start (group (or "class" "def" "for" "if" "try" "while" "with")) symbol-end (any ":" " " "\n" "\t"))
* Mon 30 Sep 2013 11:23:09 PM JST
"[ \t]*\\_<\\(for\\|if\\|try\\|with\\)\\_>[: \n\t]"
* Mon 30 Sep 2013 11:24:04 PM JST
(any ":" " " "\n" "\t")
* Mon 30 Sep 2013 11:24:18 PM JST
(rx (* blank) symbol-start (group (or "for" "if" "try" "with")) symbol-end (any ":" " " "\n" "\t"))
* Mon 30 Sep 2013 11:25:15 PM JST
`for', `if', `try' or `with' block. 
* Mon 30 Sep 2013 11:27:24 PM JST
(rx (* blank) symbol-start "try" symbol-end (any ":" " " "\n" "\t"))
* Mon 30 Sep 2013 11:29:40 PM JST
(rx (* blank) symbol-start (group "class") symbol-end (any " " "\n" "\t"))
* Mon 30 Sep 2013 11:30:32 PM JST
(rx (* blank)
                          symbol-start (group "class") symbol-end
                          (any " " "\n" "\t"))
* Mon 30 Sep 2013 11:30:41 PM JST
class
* Mon 30 Sep 2013 11:30:55 PM JST
or
* Mon 30 Sep 2013 11:31:36 PM JST
rx )
* Mon 30 Sep 2013 11:32:16 PM JST
(any " " "\n" "\t")
* Mon 30 Sep 2013 11:32:42 PM JST
(rx (* blank) symbol-start (group (or "class" "def") symbol-end (any " " "\n" "\t")))
* Mon 30 Sep 2013 11:33:19 PM JST
(rx (* blank)
                                 symbol-start (group (or "class" "def"))
                                                     symbol-end
                                                     (any " " "\n" "\t"))
* Mon 30 Sep 2013 11:34:14 PM JST
"[ \t]*\\_<\\(def\\|class\\|if\\|else\\|elif\\|while\\|for\\|try\\|except\\|finally\\|with\\)\\_>[: \n\t]"
* Mon 30 Sep 2013 11:36:09 PM JST
(rx (* blank) symbol-start (group (or "def" "class" "if" "else" "elif" "while" "for"
                                      "try" "except" "finally" "with"))
    symbol-end (any ":" " " "\n" "\t"))
* Mon 30 Sep 2013 11:36:22 PM JST
                                             