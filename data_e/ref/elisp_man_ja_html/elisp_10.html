<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML lang="ja">
<!-- Created on October, 1  2005 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=euc-jp">
<META NAME="keywords" CONTENT="meadow,mule,emacs,lisp,elisp,gnus,setting,設定,unix,cygwin">
<META http-equiv="Content-Script-Type" content="text/javascript">
<META NAME="description" CONTENT="Meadowの設定を紹介するページです">
<TITLE>GNU Emacs Lispリファレンスマニュアル:  制御構造</TITLE>

<META NAME="description" CONTENT="GNU Emacs Lispリファレンスマニュアル:  制御構造">
<META NAME="keywords" CONTENT="GNU Emacs Lispリファレンスマニュアル:  制御構造">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

<LINK REL="contents" HREF="elisp_toc.html#SEC_Contents">
<LINK REL="index" HREF="elisp_48.html#SEC681">
<LINK REL="next" HREF="elisp_11.html#SEC136">
<LINK REL="prev" HREF="elisp_9.html#SEC109">

<META http-equiv="Content-Style-Type" content="text/css">
<!-- 鶯と龜 ←日本語EUC誤判別対策用らしい; -->
<link rel="StyleSheet" href="../../../../soft/css/midnight.css" type="text/css" id="css1">
<script type="text/javascript" src="style1.js"></script>
<link rel="stylesheet" type="text/css" href="../../../../soft/css/meadowmemo.css">

</HEAD>
<BODY LANG="ja" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<!--Infoseek Analyzer start-->
<script LANGUAGE="javascript">PgNo=6;</script>
<script src="http://js1.infoseek.co.jp/bin/57/00170.js"></script>
<noscript><a href="http://ax1.www.infoseek.co.jp/bin/go?0017057f" target="_blank">
<img src="http://ax1.www.infoseek.co.jp/bin/logo?0017057f" border=0></a></noscript>
<!--Infoseek Analyzer end-->
<a name="top"> </a>

<br><A NAME="SEC122"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_9.html#SEC121"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC123"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_9.html#SEC109"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_11.html#SEC136"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top">表紙</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_toc.html#SEC_Contents">目次</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_48.html#SEC681">索引</A>]</TD>
<TD> [<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=search">検索</a>] [<a href="#top">上端</a> / <a href="#bottom">下端</a>]</TD></TR></TABLE>
<A NAME="Control Structures"></A>
<H1> 9. 制御構造 </H1>
<!--docid::SEC122::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Control%20Structures">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Control%20Structures</a>"<br>
"texi/elisp21/制御構造"への<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=Meadow%20memo&cmd=read&page=texi%2Felisp21%2F%C0%A9%B8%E6%B9%BD%C2%A4">コメント</a>(無し)</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">検索<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=index VALUE=memo CHECKED><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME="memoall" VALUE="on" CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>全文<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="検索"></div></FORM>
<A NAME="IDX528"></A>
<A NAME="IDX529"></A>
<P>

Lispプログラムは、式、すなわち、<EM>フォーム</EM>（forms、see 節 <A HREF="elisp_9.html#SEC111">8.2 フォームの種類</A>）から
成ります。
フォームを<EM>制御構造</EM>（control structures）で囲むことで、
フォームの実行順序を制御します。
制御構造はスペシャルフォームであり、
その内側にあるフォームの実行をいつ行うか、行わないか、
何回行うかを制御します。
<P>

もっとも単純な実行順序は逐次実行です。
最初のフォーム<VAR>a</VAR>を実行し、
それからつぎのフォーム<VAR>b</VAR>を実行し、といった具合です。
関数の本体やLispコードのファイルのトップレベルに複数のフォームを順に書くと、
このようになります。
つまり、書かれている順番にフォームを実行します。
これを<EM>テキスト上の順序</EM>（textual order）と呼びます。
たとえば、関数本体が2つのフォーム<VAR>a</VAR>と<VAR>b</VAR>から成る場合、
関数を評価すると、まず<VAR>a</VAR>を評価し、つぎに<VAR>b</VAR>を評価して、
関数の値は<VAR>b</VAR>の値になります。
<P>

明示的な制御構造により、逐次実行以外の実行順序が可能になります。
<P>

Emacs Lispには数種類の制御構造があり、
逐次実行の変形、条件付き実行、繰り返し実行、
（制御された）ジャンプなどです。
これらすべては、以下に説明します。
組み込みの制御構造はスペシャルフォームです。
というのは、それらのサブフォームは必ずしも評価しませんし、
逐次評価するわけでもないからです。
マクロを使えば、独自の制御構造の構文を定義できます（see 節 <A HREF="elisp_13.html#SEC171">12. マクロ</A>）。
<P>

<div class="menuindex"><SCRIPT language=JavaScript src="index9.js"></SCRIPT></div><noscript><BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp_10.html#SEC123">9.1 逐次実行</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Evaluation in textual order.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp_10.html#SEC124">9.2 条件付き実行</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"><CODE>if</CODE>, <CODE>cond</CODE>, <CODE>when</CODE>, <CODE>unless</CODE>.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp_10.html#SEC125">9.3 条件の組み合わせ</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"><CODE>and</CODE>, <CODE>or</CODE>, <CODE>not</CODE>.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp_10.html#SEC126">9.4 繰り返し</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"><CODE>while</CODE> loops.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp_10.html#SEC127">9.5 非ローカル脱出</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Jumping out of a sequence.</TD></TR>
</TABLE></BLOCKQUOTE></noscript>
<P>

<A NAME="Sequencing"></A>
<HR SIZE="6">
<br><A NAME="SEC123"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC122"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC124"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top">表紙</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_toc.html#SEC_Contents">目次</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_48.html#SEC681">索引</A>]</TD>
<TD> [<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=search">検索</a>] [<a href="#top">上端</a> / <a href="#bottom">下端</a>]</TD></TR></TABLE>
<A NAME="Sequencing"></A>
<H2> 9.1 逐次実行 </H2>
<!--docid::SEC123::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Sequencing">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Sequencing</a>"<br>
"texi/elisp21/逐次実行"への<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=Meadow%20memo&cmd=read&page=texi%2Felisp21%2F%C3%E0%BC%A1%BC%C2%B9%D4">コメント</a>(無し)</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">検索<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=index VALUE=memo CHECKED><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME="memoall" VALUE="on" CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>全文<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="検索"></div></FORM>
<P>

現れる順番にフォームを評価することは、
1つのフォームから別のフォームへ制御を移すもっとも一般的な方法です。
関数本体などのある種の文脈では、自動的にこのようになります。
それ以外では、これを行う制御構造の構文を使う必要があります。
<CODE>progn</CODE>がその制御構造で、Lispのもっとも単純な制御構造です。
<P>

スペシャルフォーム<CODE>progn</CODE>はつぎのような形です。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(progn <VAR>a</VAR> <VAR>b</VAR> <VAR>c</VAR> <small>...</small>)
</pre></td></tr></table><P>

これは、フォーム、<VAR>a</VAR>、<VAR>b</VAR>、<VAR>c</VAR>、…をこの順に評価します。
これらのフォームを<CODE>progn</CODE>フォームの本体と呼びます。
本体の最後のフォームの値が、<CODE>progn</CODE>全体の値になります。
<P>

<A NAME="IDX530"></A>
初期のころのLispでは、<CODE>progn</CODE>は、
2つ以上のフォームを逐次実行しそれらの最後の値を使う唯一の方法でした。
しかし、プログラマは、（当時は）1つのフォームしか許されていない
関数の本体では、
<CODE>progn</CODE>を使う必要がしばしばあることに気づきました。
そのため、関数本体を『暗黙の<CODE>progn</CODE>』にしたのです。
つまり、実際の<CODE>progn</CODE>の本体のように、
複数のフォームを許すようにしたのです。
多くの他の制御構造も、同様に、暗黙の<CODE>progn</CODE>です。
その結果、<CODE>progn</CODE>は、かつてほどは多用されません。
現在では、<CODE>unwind-protect</CODE>、<CODE>and</CODE>、<CODE>or</CODE>の内側や、
<CODE>if</CODE>の<VAR>then</VAR>部分で必要とされるのがほとんどです。
<P>

<A NAME="IDX531"></A>
<DL>
<DT><U>Special Form:</U> <B>progn</B> <I>forms<small>...</small></I>
<DD>このスペシャルフォームは、<VAR>forms</VAR>のフォームすべてを
テキスト上の順に評価し、最後のフォームの結果を返す。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(progn (print "The first form")
       (print "The second form")
       (print "The third form"))
     -| "The first form"
     -| "The second form"
     -| "The third form"
=> "The third form"
</pre></td></tr></table></DL>
<P>

他の2つの制御構造も同様にフォームを逐次評価しますが、
返す値が異なります。
<P>

<A NAME="IDX532"></A>
<DL>
<DT><U>Special Form:</U> <B>prog1</B> <I>form1 forms<small>...</small></I>
<DD>このスペシャルフォームは、<VAR>form1</VAR>、<VAR>forms</VAR>のフォームすべてを
テキスト上の順に評価し、<VAR>form1</VAR>の結果を返す。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(prog1 (print "The first form")
       (print "The second form")
       (print "The third form"))
     -| "The first form"
     -| "The second form"
     -| "The third form"
=> "The first form"
</pre></td></tr></table><P>

変数のリストから先頭要素を取り除き、取り除いた要素を返すにはつぎのように書く。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(prog1 (car x) (setq x (cdr x)))
</pre></td></tr></table></DL>
<P>

<A NAME="IDX533"></A>
<DL>
<DT><U>Special Form:</U> <B>prog2</B> <I>form1 form2 forms<small>...</small></I>
<DD>このスペシャルフォームは、<VAR>form1</VAR>、<VAR>form2</VAR>、<VAR>forms</VAR>の
フォームすべてをテキスト上の順に評価し、<VAR>form2</VAR>の結果を返す。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(prog2 (print "The first form")
       (print "The second form")
       (print "The third form"))
     -| "The first form"
     -| "The second form"
     -| "The third form"
=> "The second form"
</pre></td></tr></table></DL>
<P>

<A NAME="Conditionals"></A>
<HR SIZE="6">
<br><A NAME="SEC124"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC123"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC125"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top">表紙</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_toc.html#SEC_Contents">目次</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_48.html#SEC681">索引</A>]</TD>
<TD> [<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=search">検索</a>] [<a href="#top">上端</a> / <a href="#bottom">下端</a>]</TD></TR></TABLE>
<A NAME="Conditionals"></A>
<H2> 9.2 条件付き実行 </H2>
<!--docid::SEC124::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Conditionals">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Conditionals</a>"<br>
"texi/elisp21/条件付き実行"への<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=Meadow%20memo&cmd=read&page=texi%2Felisp21%2F%BE%F2%B7%EF%C9%D5%A4%AD%BC%C2%B9%D4">コメント</a>(無し)</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">検索<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=index VALUE=memo CHECKED><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME="memoall" VALUE="on" CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>全文<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="検索"></div></FORM>
<A NAME="IDX534"></A>
<A NAME="IDX535"></A>
<P>

条件付き制御構造は、選択肢を選びます。
Emacs Lispには、4つの条件付きフォームがあります。
他の言語のものとほとんど同じ<CODE>if</CODE>、
<CODE>if</CODE>の変形である<CODE>when</CODE>や<CODE>unless</CODE>、
一般化したcase文である<CODE>cond</CODE>です。
<P>

<A NAME="IDX536"></A>
<DL>
<DT><U>Special Form:</U> <B>if</B> <I>condition then-form else-forms<small>...</small></I>
<DD><CODE>if</CODE>は、<VAR>condition</VAR>をもとにして、
<VAR>then-form</VAR>か<VAR>else-forms</VAR>を選ぶ。
<VAR>condition</VAR>が<CODE>nil</CODE>以外に評価されると、
<VAR>then-form</VAR>を評価し、その結果を返す。
さもなければ、<VAR>else-forms</VAR>をテキスト上の順に評価し、
その最後のものの値を返す。
（<CODE>if</CODE>の<VAR>else</VAR>部分は、暗黙の<CODE>progn</CODE>の例である。
see 節 <A HREF="elisp_10.html#SEC123">9.1 逐次実行</A>。）
<P>

<VAR>condition</VAR>が値<CODE>nil</CODE>であり、かつ、<VAR>else-forms</VAR>がないと、
<CODE>if</CODE>は<CODE>nil</CODE>を返す。
<P>

<CODE>if</CODE>がスペシャルフォームであるのは、
選択しなかった分岐をけっして評価しないからである。
したがって、つぎの例では、
<CODE>print</CODE>はけっして呼ばれないため<CODE>true</CODE>は表示されない。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(if nil 
    (print 'true) 
  'very-false)
=> very-false
</pre></td></tr></table></DL>
<P>

<A NAME="IDX537"></A>
<DL>
<DT><U>Macro:</U> <B>when</B> <I>condition then-forms<small>...</small></I>
<DD><A NAME="IDX538"></A>
これは<CODE>if</CODE>の変形であり、<VAR>else-forms</VAR>がなく、
<VAR>then-forms</VAR>は複数のフォームでもよい。
特に、
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(when <VAR>condition</VAR> <VAR>a</VAR> <VAR>b</VAR> <VAR>c</VAR>)
</pre></td></tr></table><P>

は、つぎとまったく等価である。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(if <VAR>condition</VAR> (progn <VAR>a</VAR> <VAR>b</VAR> <VAR>c</VAR>) nil)
</pre></td></tr></table></DL>
<P>

<A NAME="IDX539"></A>
<DL>
<DT><U>Macro:</U> <B>unless</B> <I>condition forms<small>...</small></I>
<DD><A NAME="IDX540"></A>
これは<VAR>then-form</VAR>がない<CODE>if</CODE>の変形である。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(unless <VAR>condition</VAR> <VAR>a</VAR> <VAR>b</VAR> <VAR>c</VAR>)
</pre></td></tr></table><P>

は、つぎとまったく等価である。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(if <VAR>condition</VAR> nil
   <VAR>a</VAR> <VAR>b</VAR> <VAR>c</VAR>)
</pre></td></tr></table></DL>
<P>

<A NAME="IDX541"></A>
<DL>
<DT><U>Special Form:</U> <B>cond</B> <I>clause<small>...</small></I>
<DD><CODE>cond</CODE>は任意個数の選択肢から1つを選ぶ。
<CODE>cond</CODE>の各節<VAR>clause</VAR>はリストである必要がある。
このリストのCARが<VAR>condition</VAR>（条件）である。
残りの要素は、あれば、<VAR>body-forms</VAR>（本体フォーム）である。
つまり、各節はつぎのようになる。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(<VAR>condition</VAR> <VAR>body-forms</VAR><small>...</small>)
</pre></td></tr></table><P>

<CODE>cond</CODE>は、各節の<VAR>condition</VAR>を評価して、
各節をテキスト上の順に試す。
<VAR>condition</VAR>の値が<CODE>nil</CODE>以外であれば、
その節は『成功』する。
そうすると、<CODE>cond</CODE>はその節の<VAR>body-forms</VAR>を評価し、
<VAR>body-forms</VAR>の最後の値が<CODE>cond</CODE>の値となる。
残りの節は無視する。
<P>

<VAR>condition</VAR>の値が<CODE>nil</CODE>であると、
その節は『失敗』し、
<CODE>cond</CODE>はつぎの節へ移りその<VAR>condition</VAR>を試す。
<P>

各<VAR>condition</VAR>が<CODE>nil</CODE>に評価されると、
すべての節が失敗し、<CODE>cond</CODE>は<CODE>nil</CODE>を返す。
<P>

節<VAR>clause</VAR>は、つぎの形式でもよい。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(<VAR>condition</VAR>)
</pre></td></tr></table><P>

この場合、<VAR>condition</VAR>が<CODE>nil</CODE>以外であると、
<VAR>condition</VAR>が<CODE>cond</CODE>フォームの値になる。
<P>

以下の例には4つの節があり、
<CODE>x</CODE>の値が、数、文字列、バッファ、シンボルかどうか調べる。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(cond ((numberp x) x)
      ((stringp x) x)
      ((bufferp x)
       (setq temporary-hack x) ; 1つの節に
       (buffer-name x))        ; 複数個の本体フォーム
      ((symbolp x) (symbol-value x)))
</pre></td></tr></table><P>

最後の節を除くそれよりまえの節がどれも成功しないときには、
最後の節を実行したいことがしばしばある。
これを行うには、<CODE>(t <VAR>body-forms</VAR>)</CODE>のように
最後の節の<VAR>condition</VAR>に<CODE>t</CODE>を使う。
フォーム<CODE>t</CODE>は<CODE>t</CODE>と評価され、けっして<CODE>nil</CODE>ではない。
そのため、<CODE>cond</CODE>がこの節に達したときには、
この節が失敗することはない。
<P>

たとえば、つぎのとおり。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(cond ((eq a 'hack) 'foo)
      (t "default"))
=> "default"
</pre></td></tr></table><P>

この式は、<CODE>a</CODE>の値が<CODE>hack</CODE>のときには<CODE>foo</CODE>を返し、
さもなければ文字列<CODE>"default"</CODE>を返す<CODE>cond</CODE>である。
</DL>
<P>

任意の条件付き構造は、<CODE>cond</CODE>や<CODE>if</CODE>で表現できます。
したがって、どちらを使うかは好みの問題です。
たとえば、つぎのとおりです。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(if <VAR>a</VAR> <VAR>b</VAR> <VAR>c</VAR>)
==
(cond (<VAR>a</VAR> <VAR>b</VAR>) (t <VAR>c</VAR>))
</pre></td></tr></table><P>

<A NAME="Combining Conditions"></A>
<HR SIZE="6">
<br><A NAME="SEC125"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC124"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC126"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top">表紙</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_toc.html#SEC_Contents">目次</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_48.html#SEC681">索引</A>]</TD>
<TD> [<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=search">検索</a>] [<a href="#top">上端</a> / <a href="#bottom">下端</a>]</TD></TR></TABLE>
<A NAME="Combining Conditions"></A>
<H2> 9.3 条件の組み合わせ </H2>
<!--docid::SEC125::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Combining%20Conditions">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Combining%20Conditions</a>"<br>
"texi/elisp21/条件の組み合わせ"への<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=Meadow%20memo&cmd=read&page=texi%2Felisp21%2F%BE%F2%B7%EF%A4%CE%C1%C8%A4%DF%B9%E7%A4%EF%A4%BB">コメント</a>(無し)</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">検索<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=index VALUE=memo CHECKED><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME="memoall" VALUE="on" CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>全文<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="検索"></div></FORM>
<P>

本節では、<CODE>if</CODE>や<CODE>cond</CODE>とともに用いて複雑な条件を表現するために
しばしば使われる3つの構造を説明します。
<CODE>and</CODE>や<CODE>or</CODE>の構造は、
複数の条件付き構造の一種として単独で使うこともできます。
<P>

<A NAME="IDX542"></A>
<DL>
<DT><U>Function:</U> <B>not</B> <I>condition</I>
<DD>この関数は、<VAR>condition</VAR>が偽であるかどうか調べる。
<VAR>condition</VAR>が<CODE>nil</CODE>であれば<CODE>t</CODE>を返し、
さもなければ<CODE>nil</CODE>を返す。
関数<CODE>not</CODE>は<CODE>null</CODE>と同一であるが、
空リストかどうか調べる場合には、<CODE>null</CODE>を使うことを勧める。
</DL>
<P>

<A NAME="IDX543"></A>
<DL>
<DT><U>Special Form:</U> <B>and</B> <I>conditions<small>...</small></I>
<DD>スペシャルフォーム<CODE>and</CODE>は、
すべての<VAR>conditions</VAR>が真であるかどうか調べる。
<VAR>conditions</VAR>を1つ1つ書かれた順に評価して調べる。
<P>

<VAR>conditions</VAR>のどれかが<CODE>nil</CODE>に評価されると、
<CODE>and</CODE>の結果は、残りの<VAR>conditions</VAR>に関係なく、<CODE>nil</CODE>になる。
つまり、<CODE>and</CODE>はただちに完了し、
<VAR>conditions</VAR>の残りを無視する。
<P>

<VAR>conditions</VAR>すべてが<CODE>nil</CODE>以外であることがわかると、
それらの最後の値がフォーム<CODE>and</CODE>の値となる。
<P>

例を示そう。
最初の条件は整数1を返し、これは<CODE>nil</CODE>ではない。
同様に、2番目の条件は整数2を返し、<CODE>nil</CODE>ではない。
3番目の条件は<CODE>nil</CODE>なので、残りの条件を評価しない。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(and (print 1) (print 2) nil (print 3))
     -| 1
     -| 2
=> nil
</pre></td></tr></table><P>

<CODE>and</CODE>を使ったより現実的な例はつぎのとおり。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(if (and (consp foo) (eq (car foo) 'x))
    (message "foo is a list starting with x"))
</pre></td></tr></table><P>

<CODE>(consp foo)</CODE>が<CODE>nil</CODE>を返すと<CODE>(car foo)</CODE>は実行されず、
そのためエラーを回避することに注意。
<P>

<CODE>and</CODE>は、<CODE>if</CODE>や<CODE>cond</CODE>で表現できる。
たとえば、つぎのとおり。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(and <VAR>arg1</VAR> <VAR>arg2</VAR> <VAR>arg3</VAR>)
==
(if <VAR>arg1</VAR> (if <VAR>arg2</VAR> <VAR>arg3</VAR>))
==
(cond (<VAR>arg1</VAR> (cond (<VAR>arg2</VAR> <VAR>arg3</VAR>))))
</pre></td></tr></table></DL>
<P>

<A NAME="IDX544"></A>
<DL>
<DT><U>Special Form:</U> <B>or</B> <I>conditions<small>...</small></I>
<DD>スペシャルフォーム<CODE>or</CODE>は、
<VAR>conditions</VAR>の少なくとも1つが真であるかどうか調べる。
<VAR>conditions</VAR>を1つ1つ書かれた順に評価して調べる。
<P>

<VAR>conditions</VAR>のどれかが<CODE>nil</CODE>以外に評価されると、
<CODE>or</CODE>の結果は<CODE>nil</CODE>以外になる。
そして、<CODE>or</CODE>はただちに完了し、
<VAR>conditions</VAR>の残りを無視する。
戻り値は、<CODE>nil</CODE>以外に評価された値である。
<P>

<VAR>conditions</VAR>すべてが<CODE>nil</CODE>であることがわかると、
<CODE>or</CODE>は<CODE>nil</CODE>を返す。
<P>

たとえば、つぎの式は、<CODE>x</CODE>が0か<CODE>nil</CODE>であることを調べる。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(or (eq x nil) (eq x 0))
</pre></td></tr></table><P>

<CODE>and</CODE>構造と同様に、<CODE>or</CODE>は<CODE>cond</CODE>で書き表せる。
たとえば、つぎのとおり。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(or <VAR>arg1</VAR> <VAR>arg2</VAR> <VAR>arg3</VAR>)
==
(cond (<VAR>arg1</VAR>)
      (<VAR>arg2</VAR>)
      (<VAR>arg3</VAR>))
</pre></td></tr></table><P>

<CODE>or</CODE>を<CODE>if</CODE>で書くこともだいたいできるが、
途中で抜け出せない。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(if <VAR>arg1</VAR> <VAR>arg1</VAR>
  (if <VAR>arg2</VAR> <VAR>arg2</VAR> 
    <VAR>arg3</VAR>))
</pre></td></tr></table><P>

これは完全には同一ではない。
というのは、<VAR>arg1</VAR>や<VAR>arg2</VAR>を2度評価するからである。
一方、<CODE>(or <VAR>arg1</VAR> <VAR>arg2</VAR> <VAR>arg3</VAR>)</CODE>は、
どの引数も一度だけ評価する。
</DL>
<P>

<A NAME="Iteration"></A>
<HR SIZE="6">
<br><A NAME="SEC126"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC125"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC127"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top">表紙</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_toc.html#SEC_Contents">目次</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_48.html#SEC681">索引</A>]</TD>
<TD> [<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=search">検索</a>] [<a href="#top">上端</a> / <a href="#bottom">下端</a>]</TD></TR></TABLE>
<A NAME="Iteration"></A>
<H2> 9.4 繰り返し </H2>
<!--docid::SEC126::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Iteration">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Iteration</a>"<br>
"texi/elisp21/繰り返し"への<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=Meadow%20memo&cmd=read&page=texi%2Felisp21%2F%B7%AB%A4%EA%CA%D6%A4%B7">コメント</a>(無し)</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">検索<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=index VALUE=memo CHECKED><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME="memoall" VALUE="on" CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>全文<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="検索"></div></FORM>
<A NAME="IDX545"></A>
<A NAME="IDX546"></A>
<P>

繰り返しとは、プログラムのある部分を何度も実行することです。
たとえば、リストの各要素や0から<VAR>n</VAR>の各整数について
1回ずつある計算を行いたい場合です。
Emacs Lispでこれを行うには、スペシャルフォーム<CODE>while</CODE>を使います。
<P>

<A NAME="IDX547"></A>
<DL>
<DT><U>Special Form:</U> <B>while</B> <I>condition forms<small>...</small></I>
<DD><CODE>while</CODE>は、まず<VAR>condition</VAR>を評価する。
結果が<CODE>nil</CODE>以外であれば、<VAR>forms</VAR>をテキスト上の順で評価する。
そして、<VAR>condition</VAR>を評価し直し、その結果が<CODE>nil</CODE>以外であれば、
再度<VAR>forms</VAR>を評価する。
この処理を<VAR>condition</VAR>が<CODE>nil</CODE>に評価されるまで繰り返す。
<P>

繰り返し回数に制限はない。
ループは、<VAR>condition</VAR>が<CODE>nil</CODE>に評価される、
エラーが発生する、<CODE>throw</CODE>によりループから抜け出す
（see 節 <A HREF="elisp_10.html#SEC127">9.5 非ローカル脱出</A>）のいずれかが起こるまで繰り返される。
<P>

フォーム<CODE>while</CODE>の値はつねに<CODE>nil</CODE>である。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(setq num 0)
     => 0
(while (&#60; num 4)
  (princ (format "Iteration %d." num))
  (setq num (1+ num)))
     -| Iteration 0.
     -| Iteration 1.
     -| Iteration 2.
     -| Iteration 3.
     => nil
</pre></td></tr></table><P>

終了検査のまえに各繰り返しごとに実行したいことがあれば、
以下のように、それらと終了検査を<CODE>progn</CODE>でまとめたものを
<CODE>while</CODE>の第1引数にする。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(while (progn
         (forward-line 1)
         (not (looking-at "^$"))))
</pre></td></tr></table><P>

これは、1行先へ移動し、空行に達するまで、移動を繰り返す。
この<CODE>while</CODE>には本体がなく、
終了検査（かつポイントを実際に動かす）だけであるという点で、
風変わりである。
</DL>
<P>

<A NAME="Nonlocal Exits"></A>
<HR SIZE="6">
<br><A NAME="SEC127"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC126"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC128"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top">表紙</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_toc.html#SEC_Contents">目次</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_48.html#SEC681">索引</A>]</TD>
<TD> [<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=search">検索</a>] [<a href="#top">上端</a> / <a href="#bottom">下端</a>]</TD></TR></TABLE>
<A NAME="Nonlocal Exits"></A>
<H2> 9.5 非ローカル脱出 </H2>
<!--docid::SEC127::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Nonlocal%20Exits">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Nonlocal%20Exits</a>"<br>
"texi/elisp21/非ローカル脱出"への<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=Meadow%20memo&cmd=read&page=texi%2Felisp21%2F%C8%F3%A5%ED%A1%BC%A5%AB%A5%EB%C3%A6%BD%D0">コメント</a>(無し)</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">検索<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=index VALUE=memo CHECKED><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME="memoall" VALUE="on" CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>全文<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="検索"></div></FORM>
<A NAME="IDX548"></A>
<P>

<EM>非ローカル脱出</EM>（nonlocal exit）とは、
プログラムのある場所から別の離れた場所へ制御を移すことです。
Emacs Lispでは、エラーの結果として非ローカル脱出が発生します。
非ローカル脱出は、明示的な制御にも使えます。
非ローカル脱出は、脱出対象の構造で作成したすべての変数束縛を解きます。
<P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp_10.html#SEC128">9.5.1 明示的な非ローカル脱出：<CODE> </CODE><CODE>catch</CODE>と<CODE>throw</CODE></A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Nonlocal exits for the program's own purposes.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp_10.html#SEC129">9.5.2 <CODE>catch</CODE>と<CODE>throw</CODE>の例</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Showing how such nonlocal exits can be written.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp_10.html#SEC130">9.5.3 エラー</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">How errors are signaled and handled.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp_10.html#SEC135">9.5.4 非ローカル脱出時の後始末</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Arranging to run a cleanup form if an error happens.</TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Catch and Throw"></A>
<HR SIZE="6">
<br><A NAME="SEC128"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC127"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC129"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top">表紙</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_toc.html#SEC_Contents">目次</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_48.html#SEC681">索引</A>]</TD>
<TD> [<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=search">検索</a>] [<a href="#top">上端</a> / <a href="#bottom">下端</a>]</TD></TR></TABLE>
<A NAME="Catch and Throw"></A>
<H3> 9.5.1 明示的な非ローカル脱出：<CODE> </CODE><CODE>catch</CODE>と<CODE>throw</CODE> </H3>
<!--docid::SEC128::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Catch%20and%20Throw">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Catch%20and%20Throw</a>"<br>
"texi/elisp21/明示的な非ローカル脱出：<CODE></CODE><CODE>catch</CODE>と<CODE>throw</CODE>"への<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=Meadow%20memo&cmd=read&page=texi%2Felisp21%2F%CC%C0%BC%A8%C5%AA%A4%CA%C8%F3%A5%ED%A1%BC%A5%AB%A5%EB%C3%A6%BD%D0%A1%A7%3CCODE%3E%3C%2FCODE%3E%3CCODE%3Ecatch%3C%2FCODE%3E%A4%C8%3CCODE%3Ethrow%3C%2FCODE%3E">コメント</a>(無し)</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">検索<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=index VALUE=memo CHECKED><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME="memoall" VALUE="on" CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>全文<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="検索"></div></FORM>
<P>

ほとんどの制御構造は、その構造内での制御の流れだけに影響します。
関数<CODE>throw</CODE>は、通常のプログラム実行のこのような規則の例外です。
つまり、要求に従って非ローカルな脱出を行います。
（ほかにも例外はあるが、それらはエラー処理のためだけである。）
<CODE>throw</CODE>は<CODE>catch</CODE>の内側で使い、
その<CODE>catch</CODE>へ戻ります。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun foo-outer ()
  (catch 'foo
    (foo-inner)))

(defun foo-inner ()
  <small>...</small>
  (if x
      (throw 'foo t))
  <small>...</small>)
</pre></td></tr></table><P>

フォーム<CODE>throw</CODE>を実行すると、対応する<CODE>catch</CODE>へ制御が戻り、
その<CODE>catch</CODE>はただちに終了します。
<CODE>throw</CODE>に続くコードは実行されません。
<CODE>throw</CODE>の第2引数は、<CODE>catch</CODE>の戻り値として使われます。
<P>

関数<CODE>throw</CODE>は、その第1引数に基づいて対応する<CODE>catch</CODE>を探します。
つまり、<CODE>catch</CODE>の第1引数が
<CODE>throw</CODE>に指定されたものに<CODE>eq</CODE>である<CODE>catch</CODE>を探します。
そのような<CODE>catch</CODE>が複数個ある場合には、
もっとも内側のものを優先します。
したがって、上の例では、<CODE>throw</CODE>は<CODE>foo</CODE>を指定し、
<CODE>foo-outer</CODE>の<CODE>catch</CODE>は同じシンボルを指定しているので、
その<CODE>catch</CODE>を使います
（ただし、これらのあいだには他の一致する<CODE>catch</CODE>がないとして）。
<P>

<CODE>throw</CODE>の実行により、
対応する<CODE>catch</CODE>までのすべてのLispの構造を抜け出します。
これには関数呼び出しも含みます。
<CODE>let</CODE>や関数呼び出しなどの束縛を作る構造からもこのように抜け出すので、
通常どおり抜け出す場合と同様に束縛を解きます
（see 節 <A HREF="elisp_11.html#SEC139">10.3 ローカル変数</A>）。
同様に、<CODE>throw</CODE>は、<CODE>save-excursion</CODE>（see 節 <A HREF="elisp_30.html#SEC472">29.3 エクスカージョン</A>）で
保存したバッファや位置情報、
<CODE>save-restriction</CODE>で保存したナロイング状態、
<CODE>save-window-excursion</CODE>（see 節 <A HREF="elisp_28.html#SEC432">27.16 ウィンドウ構成</A>）で保存した
ウィンドウの選択状態も復元します。
さらに、スペシャルフォーム<CODE>unwind-protect</CODE>で設定した後始末を
このフォームから抜け出すときに実行します（see 節 <A HREF="elisp_10.html#SEC135">9.5.4 非ローカル脱出時の後始末</A>）。
<P>

<CODE>throw</CODE>は、テキスト上で、
ジャンプ先である<CODE>catch</CODE>の内側に現れる必要はありません。
<CODE>throw</CODE>は、<CODE>catch</CODE>内から呼ばれた別の関数からも戻ることもできます。
<CODE>throw</CODE>の実行が、
時間的に<CODE>catch</CODE>に入ったあとで、かつ、それから抜けるまえである限り、
<CODE>throw</CODE>は対応する<CODE>catch</CODE>を参照できます。
エディタコマンドループ（see 節 <A HREF="elisp_21.html#SEC313">20.11 再帰編集</A>）から抜ける
<CODE>exit-recursive-edit</CODE>などのコマンドで
<CODE>throw</CODE>を使えるのは、このような理由からです。
<P>

<A NAME="IDX549"></A>
<BLOCKQUOTE>
<B>Common Lispに関した注意：</B><CODE> </CODE>
Common Lispを含むほとんどの他のLispには、
非逐次的に制御を移す方法がいくつかある。
たとえば、<CODE>return</CODE>、<CODE>return-from</CODE>、<CODE>go</CODE>。
Emacs Lispには<CODE>throw</CODE>しかない。
</BLOCKQUOTE>
<P>

<A NAME="IDX550"></A>
<DL>
<DT><U>Special Form:</U> <B>catch</B> <I>tag body<small>...</small></I>
<DD><A NAME="IDX551"></A>
<CODE>catch</CODE>は、関数<CODE>throw</CODE>向けに戻り位置を確立する。
その戻り位置は、<VAR>tag</VAR>によって他の戻り位置と区別される。
<VAR>tag</VAR>は、<CODE>nil</CODE>以外ならば任意のLispオブジェクトでよい。
引数<VAR>tag</VAR>は、戻り位置を確立するまえに、通常どおり評価される。
<P>

戻り位置を確立してから、<CODE>catch</CODE>は、<VAR>body</VAR>のフォームを
テキスト上の順に評価する。
エラーや非ローカル脱出なしにフォームの実行が普通に終了した場合、
<CODE>catch</CODE>は、最後の本体フォームの値を返す。
<P>

<VAR>body</VAR>の内側で、<VAR>tag</VAR>と同じ値を指定した<CODE>throw</CODE>が実行されると、
<CODE>catch</CODE>はただちに終了する。
このとき返す値は、<CODE>throw</CODE>の第2引数に指定されたものである。
</DL>
<P>

<A NAME="IDX552"></A>
<DL>
<DT><U>Function:</U> <B>throw</B> <I>tag value</I>
<DD><CODE>throw</CODE>の目的は、
<CODE>catch</CODE>でまえもって確立しておいた戻り位置へ復帰することである。
引数<VAR>tag</VAR>は、さまざまな既存の戻り位置から選ぶために使う。
<VAR>tag</VAR>は、<CODE>catch</CODE>で指定した値と<CODE>eq</CODE>である必要がある。
<VAR>tag</VAR>に複数の戻り位置が一致する場合には、もっとも内側のものを使う。
<P>

引数<VAR>value</VAR>は、対応する<CODE>catch</CODE>の戻り値として使う。
<P>

<A NAME="IDX553"></A>
タグ<VAR>tag</VAR>である有効な戻り位置がなければ、
<CODE>(<VAR>tag</VAR> <VAR>value</VAR>)</CODE>を伴ったエラー<CODE>no-catch</CODE>を通知する。
</DL>
<P>

<A NAME="Examples of Catch"></A>
<HR SIZE="6">
<br><A NAME="SEC129"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC128"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC130"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top">表紙</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_toc.html#SEC_Contents">目次</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_48.html#SEC681">索引</A>]</TD>
<TD> [<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=search">検索</a>] [<a href="#top">上端</a> / <a href="#bottom">下端</a>]</TD></TR></TABLE>
<A NAME="Examples of Catch"></A>
<H3> 9.5.2 <CODE>catch</CODE>と<CODE>throw</CODE>の例 </H3>
<!--docid::SEC129::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Examples%20of%20Catch">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Examples%20of%20Catch</a>"<br>
"texi/elisp21/<CODE>catch</CODE>と<CODE>throw</CODE>の例"への<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=Meadow%20memo&cmd=read&page=texi%2Felisp21%2F%3CCODE%3Ecatch%3C%2FCODE%3E%A4%C8%3CCODE%3Ethrow%3C%2FCODE%3E%A4%CE%CE%E3">コメント</a>(無し)</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">検索<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=index VALUE=memo CHECKED><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME="memoall" VALUE="on" CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>全文<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="検索"></div></FORM>
<P>

<CODE>catch</CODE>と<CODE>throw</CODE>の使い方の1つは、
2重のループからの脱出です。
（ほとんどの言語では、これを『go to』で行うであろう。）
ここでは、<VAR>i</VAR>と<VAR>j</VAR>を0から9に変えながら、
<CODE>(foo <VAR>i</VAR> <VAR>j</VAR>)</CODE>を計算します。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun search-foo ()
  (catch 'loop
    (let ((i 0))
      (while (&#60; i 10)
        (let ((j 0))
          (while (&#60; j 10)
            (if (foo i j)
                (throw 'loop (list i j)))
            (setq j (1+ j))))
        (setq i (1+ i))))))
</pre></td></tr></table><P>

<CODE>foo</CODE>がある時点で<CODE>nil</CODE>以外を返すと、
ただちに止まって<VAR>i</VAR>と<VAR>j</VAR>のリストを返します。
<CODE>foo</CODE>がつねに<CODE>nil</CODE>を返すと、
<CODE>catch</CODE>は通常どおりに戻って、その値は<CODE>nil</CODE>です。
というのは、<CODE>while</CODE>の結果は<CODE>nil</CODE>だからです。
<P>

2つの巧妙な例をあげましょう。
多少異なる2つの戻り位置が同時に存在します。
まず、同じタグ<CODE>hack</CODE>で2つの戻り位置があります。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun catch2 (tag)
  (catch tag
    (throw 'hack 'yes)))
=> catch2

(catch 'hack 
  (print (catch2 'hack))
  'no)
-| yes
=> no
</pre></td></tr></table><P>

どちらの戻り位置も<CODE>throw</CODE>に一致するタグなので、
内側のもの、つまり、<CODE>catch2</CODE>で確立したものに戻ります。
したがって、<CODE>catch2</CODE>は値<CODE>yes</CODE>で通常どおり戻り、
この値が表示されます。
最後に、外側の<CODE>catch</CODE>の2番目の本体フォーム、
つまり、<CODE>'no</CODE>が評価され、外側の<CODE>catch</CODE>から戻ります。
<P>

今度は、<CODE>catch2</CODE>に指定する引数を変更してみます。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun catch2 (tag)
  (catch tag
    (throw 'hack 'yes)))
=> catch2

(catch 'hack
  (print (catch2 'quux))
  'no)
=> yes
</pre></td></tr></table><P>

ここでも2つの戻り位置がありますが、
今度は外側のものだけがタグ<CODE>hack</CODE>です。
内側のものはタグ<CODE>quux</CODE>です。
したがって、<CODE>throw</CODE>により、外側の<CODE>catch</CODE>が値<CODE>yes</CODE>を返します。
関数<CODE>print</CODE>はけっして呼ばれず、
本体フォーム<CODE>'no</CODE>もけっして評価されません。
<P>

<A NAME="Errors"></A>
<HR SIZE="6">
<br><A NAME="SEC130"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC129"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC131"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top">表紙</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_toc.html#SEC_Contents">目次</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_48.html#SEC681">索引</A>]</TD>
<TD> [<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=search">検索</a>] [<a href="#top">上端</a> / <a href="#bottom">下端</a>]</TD></TR></TABLE>
<A NAME="Errors"></A>
<H3> 9.5.3 エラー </H3>
<!--docid::SEC130::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Errors">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Errors</a>"<br>
"texi/elisp21/エラー"への<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=Meadow%20memo&cmd=read&page=texi%2Felisp21%2F%A5%A8%A5%E9%A1%BC">コメント</a>(無し)</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">検索<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=index VALUE=memo CHECKED><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME="memoall" VALUE="on" CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>全文<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="検索"></div></FORM>
<A NAME="IDX554"></A>
<P>

Emacs Lispが、なんらかの理由で評価できないフォームを評価しようとしたときには、
Emacs Lispは<EM>エラー</EM>（error）を<EM>通知</EM>（signals）します。
<P>

エラーが通知されると、Emacsのデフォルトの動作は、
エラーメッセージを表示し、現在のコマンドの実行を終了します。
バッファの末尾で<KBD>C-f</KBD>を打ったときなどのように、
これはほとんどの場合、適切なことです。
<P>

複雑なプログラムでは、単に終了するだけでは満足できないこともあります。
たとえば、プログラムではデータ構造に一時的な変更を加えていたり、
プログラム終了時には削除する必要がある一時的なバッファを作成するでしょう。
そのような場合には、<CODE>unwind-protect</CODE>を使って、
エラー発生時に評価される<EM>後始末式</EM>（cleanup expressions）を
確立しておきます。
（see 節 <A HREF="elisp_10.html#SEC135">9.5.4 非ローカル脱出時の後始末</A>。）
場合によっては、サブルーティンでエラーが発生しても、
プログラムの実行を継続したいこともあるでしょう。
このような場合には、<CODE>condition-case</CODE>を使って、
エラー状態から制御を回復するための
<EM>エラーハンドラ</EM>（error handlers）を確立しておきます。
<P>

エラー処理を用いてプログラムのある場所から別の場所へ制御を移す、
という誘惑には耐えてください。
そのかわりに<CODE>catch</CODE>と<CODE>throw</CODE>を使いましょう。
See 節 <A HREF="elisp_10.html#SEC128">9.5.1 明示的な非ローカル脱出：<CODE> </CODE><CODE>catch</CODE>と<CODE>throw</CODE></A>。
<P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp_10.html#SEC131">9.5.3.1 エラーの通知方法</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">How to report an error.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp_10.html#SEC132">9.5.3.2 Emacsのエラー処理方法</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">What Emacs does when you report an error.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp_10.html#SEC133">9.5.3.3 エラーハンドラの書き方</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">How you can trap errors and continue execution.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="elisp_10.html#SEC134">9.5.3.4 エラーシンボルと条件名</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">How errors are classified for trapping them.</TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Signaling Errors"></A>
<HR SIZE="6">
<br><A NAME="SEC131"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC130"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC132"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top">表紙</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_toc.html#SEC_Contents">目次</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_48.html#SEC681">索引</A>]</TD>
<TD> [<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=search">検索</a>] [<a href="#top">上端</a> / <a href="#bottom">下端</a>]</TD></TR></TABLE>
<A NAME="Signaling Errors"></A>
<H4> 9.5.3.1 エラーの通知方法 </H4>
<!--docid::SEC131::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Signaling%20Errors">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Signaling%20Errors</a>"<br>
"texi/elisp21/エラーの通知方法"への<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=Meadow%20memo&cmd=read&page=texi%2Felisp21%2F%A5%A8%A5%E9%A1%BC%A4%CE%C4%CC%C3%CE%CA%FD%CB%A1">コメント</a>(無し)</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">検索<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=index VALUE=memo CHECKED><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME="memoall" VALUE="on" CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>全文<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="検索"></div></FORM>
<A NAME="IDX555"></A>
<P>

ほとんどのエラーは、他の目的で呼び出したLisp関数の内部で『自動的』に
通知されます。
整数のCARを計算しようとしたり、
バッファの末尾で1文字進めようとしたりしたときなどです。
関数<CODE>error</CODE>や関数<CODE>signal</CODE>で、
明示的にエラーを通知することもできます。
<P>

ユーザーが<KBD>C-g</KBD>を打ったときに発生する中断は、
エラーとは考えませんが、エラーのように扱います。
<P>

<A NAME="IDX556"></A>
<DL>
<DT><U>Function:</U> <B>error</B> <I>format-string &#38;rest args</I>
<DD>この関数は、<VAR>format-string</VAR>と<VAR>args</VAR>に
<CODE>format</CODE>（see 節 <A HREF="elisp_5.html#SEC77">4.6 文字と文字列の変換</A>）を適用して作った
エラーメッセージを伴ったエラーを通知する。
<P>

<CODE>error</CODE>の典型的な使い方を以下に示す。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(error "That is an error -- try something else")
     error--> That is an error -- try something else

(error "You have committed %d errors" 10)
     error--> You have committed 10 errors
</pre></td></tr></table><P>

<CODE>error</CODE>は、2つの引数、
エラーシンボル<CODE>error</CODE>と<CODE>format</CODE>が返す文字列を含むリスト
で<CODE>signal</CODE>を呼び出すことで動作する。
<P>

<STRONG>警告：</STRONG><CODE> </CODE>
独自のエラーメッセージをそのまま使いたい場合に、
単に<CODE>(error <VAR>string</VAR>)</CODE>とは書かないこと。
<VAR>string</VAR>に`<SAMP>%</SAMP>'が含まれていると、
それは書式付け指定と解釈され、予測不能な結果を招く。
そのかわりに、<CODE>(error "%s" <VAR>string</VAR>)</CODE>を使う。
</DL>
<P>

<A NAME="IDX557"></A>
<DL>
<DT><U>Function:</U> <B>signal</B> <I>error-symbol data</I>
<DD>この関数は、<VAR>error-symbol</VAR>という名前のエラーを通知する。
引数<VAR>data</VAR>は、エラーの状況に関連したLispオブジェクトのリストである。
<P>

引数<VAR>error-symbol</VAR>は、<EM>エラーシンボル</EM>（error symbol）である
必要がある。
つまり、属性<CODE>error-conditions</CODE>を持つシンボルであり、
その属性値は条件名のリストである。
これにより、Emacsはエラーの異なる種類を分類する。
<P>

<VAR>data</VAR>のオブジェクトの個数と重要性は<VAR>error-symbol</VAR>に依存する。
たとえば、エラー<CODE>wrong-type-arg</CODE>では、
リストには2つのオブジェクトがあるはずで、
予期した型を表す述語とその型に一致しなかったオブジェクトである。
エラーシンボルの説明は、see 節 <A HREF="elisp_10.html#SEC134">9.5.3.4 エラーシンボルと条件名</A>。
<P>

<VAR>error-symbol</VAR>と<VAR>data</VAR>の両者は、
任意のエラーハンドラで利用できる。
<CODE>condition-case</CODE>は、ローカル変数に
フォーム<CODE>(<VAR>error-symbol</VAR> . <VAR>data</VAR>)</CODE>のリストを束縛する
（see 節 <A HREF="elisp_10.html#SEC133">9.5.3.3 エラーハンドラの書き方</A>）。
エラーが処理されないと、これらの2つの値はエラーメッセージの表示に使われる。
<P>

関数<CODE>signal</CODE>はけっして戻らない
（しかし、Emacsの古い版では戻る場合もある）。
<P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(signal 'wrong-number-of-arguments '(x y))
     error--> Wrong number of arguments: x, y

(signal 'no-such-error '("My unknown error condition"))
     error--> peculiar error: "My unknown error condition"
</FONT></pre></td></tr></table></DL>
<P>

<A NAME="IDX558"></A>
<BLOCKQUOTE>
<B>Common Lispに関した注意：</B><CODE> </CODE>
Emacsには、Common lispの継続可能なエラーの概念に相当するものはない。
</BLOCKQUOTE>
<P>

<A NAME="Processing of Errors"></A>
<HR SIZE="6">
<br><A NAME="SEC132"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC131"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC133"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top">表紙</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_toc.html#SEC_Contents">目次</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_48.html#SEC681">索引</A>]</TD>
<TD> [<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=search">検索</a>] [<a href="#top">上端</a> / <a href="#bottom">下端</a>]</TD></TR></TABLE>
<A NAME="Processing of Errors"></A>
<H4> 9.5.3.2 Emacsのエラー処理方法 </H4>
<!--docid::SEC132::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Processing%20of%20Errors">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Processing%20of%20Errors</a>"<br>
"texi/elisp21/Emacsのエラー処理方法"への<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=Meadow%20memo&cmd=read&page=texi%2Felisp21%2FEmacs%A4%CE%A5%A8%A5%E9%A1%BC%BD%E8%CD%FD%CA%FD%CB%A1">コメント</a>(無し)</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">検索<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=index VALUE=memo CHECKED><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME="memoall" VALUE="on" CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>全文<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="検索"></div></FORM>
<P>

エラーが通知されると、<CODE>signal</CODE>は、
エラーに対する有効な<EM>ハンドラ</EM>（handler）を探します。
ハンドラは、Lispプログラムの一部でエラーが発生した場合に
実行されるように指定されたLisp式の列です。
エラーに対して適用可能なハンドラがあると、
そのハンドラが実行され、ハンドラに続いて制御は復旧します。
ハンドラは、そのハンドラを設定した<CODE>condition-case</CODE>の環境で実行されます。
<CODE>condition-case</CODE>の内側で呼び出された関数はすべて終了しているので、
ハンドラからそれらへ戻ることはできません。
<P>

エラーに適用可能なハンドラがなければ、
現在のコマンドは終了し、制御はエディタコマンドループへ戻ります。
というのは、コマンドループには、
すべての種類のエラーに対する暗黙のハンドラがあるからです。
コマンドループのハンドラは、エラーシンボルと関連するデータを使って
エラーメッセージを表示します。
<P>

<A NAME="IDX559"></A>
明示的なハンドラがないエラーは、Lispデバッガを呼び出すこともあります。
変数<CODE>debug-on-error</CODE>（see 節 <A HREF="elisp_18.html#SEC221">17.1.1 エラーによるデバッガの起動</A>）が
<CODE>nil</CODE>以外であると、デバッガが有効になります。
エラーハンドラと違って、デバッガはエラーの環境で実行されるので、
エラー時の変数の正確な値を調べることができます。
<P>

<A NAME="Handling Errors"></A>
<HR SIZE="6">
<br><A NAME="SEC133"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC132"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC134"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top">表紙</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_toc.html#SEC_Contents">目次</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_48.html#SEC681">索引</A>]</TD>
<TD> [<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=search">検索</a>] [<a href="#top">上端</a> / <a href="#bottom">下端</a>]</TD></TR></TABLE>
<A NAME="Handling Errors"></A>
<H4> 9.5.3.3 エラーハンドラの書き方 </H4>
<!--docid::SEC133::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Handling%20Errors">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Handling%20Errors</a>"<br>
"texi/elisp21/エラーハンドラの書き方"への<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=Meadow%20memo&cmd=read&page=texi%2Felisp21%2F%A5%A8%A5%E9%A1%BC%A5%CF%A5%F3%A5%C9%A5%E9%A4%CE%BD%F1%A4%AD%CA%FD">コメント</a>(無し)</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">検索<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=index VALUE=memo CHECKED><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME="memoall" VALUE="on" CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>全文<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="検索"></div></FORM>
<A NAME="IDX560"></A>
<A NAME="IDX561"></A>
<P>

エラーを通知することの普通の効果は、
実行中のコマンドを終了し、Emacsのエディタコマンドループにただちに戻ります。
読者のプログラムの一部で発生したエラーを捕捉するようにするには、
スペシャルフォーム<CODE>condition-case</CODE>を使ってエラーハンドラを設定します。
単純な例はつぎのようになります。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(condition-case nil
    (delete-file filename)
  (error nil))
</pre></td></tr></table><P>

これは<VAR>filename</VAR>という名前のファイルを削除しますが、
エラーが発生するとどんなエラーでも捕捉して<CODE>nil</CODE>を返します。
<P>

<CODE>condition-case</CODE>の第2引数を
<EM>保護されたフォーム</EM>（protected form）と呼びます。
（上の例では、保護されたフォームは<CODE>delete-file</CODE>の呼び出し。）
このフォームの実行を開始するとエラーハンドラが有効になり、
このフォームから戻るとエラーハンドラは取り除かれます。
そのあいだは、つねにエラーハンドラは有効です。
特に、このフォームから呼び出される関数の実行中、
それらのサブルーティンの実行中などには、エラーハンドラは有効です。
これは大切なことで、厳密にいえば、
エラーが通知されるのは、保護されたフォームから呼び出された
（<CODE>signal</CODE>や<CODE>error</CODE>を含む）Lisp基本関数の実行中であって、
保護されたフォームそのものからではないからです。
<P>

保護されたフォームのうしろにある引数は、ハンドラです。
各ハンドラは1つ以上の（シンボルである）<EM>条件名</EM>
（condition names）を列挙し、処理するエラーを指定します。
エラーが通知されたときのエラーシンボルも条件名のリストを定義します。
それらに共通の条件名があるとき、
エラーハンドラがエラーに適用されます。
上の例では、1つのハンドラがあり、条件名は1つ、<CODE>error</CODE>を指定しています。
この条件名はすべてのエラーを意味します。
<P>

適用可能なハンドラの探索では、
もっとも最近に確立されたハンドラから始めて、
確立されたすべてのハンドラを調べます。
したがって、フォーム<CODE>condition-case</CODE>が2つ入れ子になっていて
同じ名前のハンドラを確立していると、内側のものが実際に処理を受け持ちます。
<P>

フォーム<CODE>condition-case</CODE>でエラーが処理されるときには、
<CODE>debug-on-error</CODE>でエラーによりデバッガを起動するように指定してあっても
デバッガは実行されません。
See 節 <A HREF="elisp_18.html#SEC221">17.1.1 エラーによるデバッガの起動</A>。
<CODE>condition-case</CODE>で捕捉されるエラーをデバッグしたいときには、
変数<CODE>debug-on-signal</CODE>に<CODE>nil</CODE>以外の値を設定します。
<P>

エラーを処理できる場合には、制御はハンドラに移ります。
こうするまえに、Emacsは、抜け出し対象となる束縛作成構造が設定した
すべての変数束縛を解き、抜け出し対象となるフォーム<CODE>unwind-protect</CODE>
すべての後始末を実行します。
ハンドラに制御が移ると、ハンドラの本体を実行します。
<P>

ハンドラ本体の実行を完了すると、
フォーム<CODE>condition-case</CODE>から戻ります。
ハンドラを実行するまえに保護されたフォームから完全に抜けているので、
ハンドラでは、エラー発生時点から再開したり、
保護されたフォームの内側で作られた変数束縛を調べたりすることはできません。
ハンドラでできることは、後始末をして先へ進むことだけです。
<P>

<CODE>condition-case</CODE>構造は、<CODE>insert-file-contents</CODE>の呼び出しで
ファイルのオープンに失敗するなどの予測可能なエラーを捕捉するために
しばしば使われます。
プログラムがユーザーから読み取った式を評価する場合のように、
まったく予測不可能なエラーを捕捉するためにも使われます。
<P>

エラー通知とエラー処理は、<CODE>throw</CODE>と<CODE>catch</CODE>に多少似ていますが、
それらはまったく別の機能です。
<CODE>catch</CODE>ではエラーを捕捉できませんし、
エラーハンドラでは<CODE>throw</CODE>を処理できません
（しかしながら、適切な<CODE>catch</CODE>がない<CODE>throw</CODE>を使うと、
処理できるエラーを通知する）。
<P>

<A NAME="IDX562"></A>
<DL>
<DT><U>Special Form:</U> <B>condition-case</B> <I>var protected-form handlers<small>...</small></I>
<DD>このスペシャルフォームは、<VAR>protected-form</VAR>の実行中は
エラーハンドラ<VAR>handlers</VAR>を確立する。
<VAR>protected-form</VAR>がエラーなしに完了すると、
その戻り値がフォーム<CODE>condition-case</CODE>の値になる。
この場合、<CODE>condition-case</CODE>はなんの効果もない。
フォーム<CODE>condition-case</CODE>で違いがでるのは、
<VAR>protected-form</VAR>の実行中にエラーが起こった場合である。
<P>

各<VAR>handlers</VAR>は、<CODE>(<VAR>conditions</VAR> <VAR>body</VAR><small>...</small>)</CODE>の形式の
リストである。
ここで<VAR>conditions</VAR>は、処理すべきエラーの条件名か条件名のリストである。
<VAR>body</VAR>は1つ以上のLisp式であり、
このハンドラがエラーを処理するときに実行される。
ハンドラの例を示す。
<P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(error nil)

(arith-error (message "Division by zero"))

((arith-error file-error)
 (message
  "Either division by zero or failure to open a file"))
</FONT></pre></td></tr></table><P>

生起する各エラーには、
そのエラーの種類を表す<EM>エラーシンボル</EM>（error symbol）がある。
そのシンボルの属性<CODE>error-conditions</CODE>は、
条件名のリストである（see 節 <A HREF="elisp_10.html#SEC134">9.5.3.4 エラーシンボルと条件名</A>）。
Emacsは、有効なフォーム<CODE>condition-case</CODE>すべてを探索し、
これらの条件名を1つ以上指定したハンドラを探す。
もっとも内側の一致する<CODE>condition-case</CODE>がエラーを処理する。
この<CODE>condition-case</CODE>の内側では、
適用可能な最初のハンドラがエラーを処理する。
<P>

ハンドラの本体の実行を完了すると、
<CODE>condition-case</CODE>は通常のように戻り、
ハンドラの本体の最後のフォームの値を全体としての値に使う。
<P>

<A NAME="IDX563"></A>
引数<VAR>var</VAR>は変数である。
<CODE>condition-case</CODE>は、<VAR>protected-form</VAR>を実行するときには
この変数を束縛せず、エラーを処理するときだけ束縛する。
そのとき、<VAR>var</VAR>はローカルに<EM>エラー記述</EM>
（error description）に束縛される。
これは、エラーの詳細を与えるリストである。
エラー記述は、<CODE>(<VAR>error-symbol</VAR> . <VAR>data</VAR>)</CODE>の形式である。
ハンドラは、動作を決定するためにこのリストを参照できる。
たとえば、ファイルのオープンに失敗したエラーであれば、
<VAR>data</VAR>の第2要素、エラー記述の第3要素がファイル名である。
<P>

<VAR>var</VAR>が<CODE>nil</CODE>であると、変数を束縛しなことを意味する。
そうすると、ハンドラではエラーシンボルと関連するデータを使えない。
</DL>
<P>

<A NAME="IDX564"></A>
<DL>
<DT><U>Function:</U> <B>error-message-string</B> <I>error-description</I>
<DD>この関数は、指定したエラー記述に対するエラーメッセージ文字列を返す。
エラーに対する普通のエラーメッセージを表示して、
エラーを処理したい場合に便利である。
</DL>
<P>

<A NAME="IDX565"></A>
ゼロ除算の結果であるエラーを処理する<CODE>condition-case</CODE>の使用例を示します。
ハンドラはエラーメッセージを（ベルを鳴らさずに）表示して、
大きな数を返します。
<P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(defun safe-divide (dividend divisor)
  (condition-case err                
      ;; 保護されたフォーム
      (/ dividend divisor)              
    ;; ハンドラ
    (arith-error                        ; 条件
     ;; このエラーに対する普通のメッセージを表示する
     (message "%s" (error-message-string err))
     1000000)))
=> safe-divide

(safe-divide 5 0)
     -| Arithmetic error: (arith-error)
=> 1000000
</FONT></pre></td></tr></table><P>

ハンドラは条件名<CODE>arith-error</CODE>を指定しているので、
ゼロ除算エラーだけを処理します。
少なくともこの<CODE>condition-case</CODE>では他の種類のエラーは処理しません。
したがって、つぎのようになります
<P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(safe-divide nil 3)
     error--> Wrong type argument: number-or-marker-p, nil
</FONT></pre></td></tr></table><P>

以下は、<CODE>error</CODE>で通知されるエラーも含めて、
すべての種類のエラーを捕捉する<CODE>condition-case</CODE>です。
<P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(setq baz 34)
     => 34

(condition-case err
    (if (eq baz 35)
        t
      ;; これは関数<CODE>error</CODE>の呼び出し
      (error "Rats!  The variable %s was %s, not 35" 'baz baz))
  ;; これはハンドラ。フォームではない
  (error (princ (format "The error was: %s" err)) 
         2))
-| The error was: (error "Rats!  The variable baz was 34, not 35")
=> 2
</FONT></pre></td></tr></table><P>

<A NAME="Error Symbols"></A>
<HR SIZE="6">
<br><A NAME="SEC134"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC133"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC135"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top">表紙</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_toc.html#SEC_Contents">目次</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_48.html#SEC681">索引</A>]</TD>
<TD> [<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=search">検索</a>] [<a href="#top">上端</a> / <a href="#bottom">下端</a>]</TD></TR></TABLE>
<A NAME="Error Symbols"></A>
<H4> 9.5.3.4 エラーシンボルと条件名 </H4>
<!--docid::SEC134::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Error%20Symbols">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Error%20Symbols</a>"<br>
"texi/elisp21/エラーシンボルと条件名"への<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=Meadow%20memo&cmd=read&page=texi%2Felisp21%2F%A5%A8%A5%E9%A1%BC%A5%B7%A5%F3%A5%DC%A5%EB%A4%C8%BE%F2%B7%EF%CC%BE">コメント</a>(無し)</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">検索<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=index VALUE=memo CHECKED><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME="memoall" VALUE="on" CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>全文<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="検索"></div></FORM>
<A NAME="IDX566"></A>
<A NAME="IDX567"></A>
<A NAME="IDX568"></A>
<A NAME="IDX569"></A>
<A NAME="IDX570"></A>
<P>

エラーを通知するときには、読者が意図するエラーの種類を指定する
<EM>エラーシンボル</EM>（error symbol）を指定します。
各エラーには、それを分類する一意な名前があります。
これは、Emacs Lisp言語で定義されたエラーを細分類したものです。
<P>

これらの細分類は、<EM>エラー条件</EM>（error conditions）と呼ばれる
より大きなクラスの階層にまとめられています。
エラー条件は、<EM>条件名</EM>（condition names）で識別します。
もっとも細かい分類は、エラーシンボルそのものです。
各エラーシンボルは条件名でもあります。
より大きなクラスを表す条件名<CODE>error</CODE>もあります。
これはすべての種類のエラーを表します。
したがって、各エラーには、1つ以上の条件名があります。
つまり、<CODE>error</CODE>、<CODE>error</CODE>とは別のエラーシンボル、あるいは、
その中間の分類に属するものです。
<P>

あるシンボルがエラーシンボルであるためには、そのシンボルには、
条件名のリストを与える属性<CODE>error-conditions</CODE>があることが必要です。
このリストは、そのエラーが属するエラー条件を定義します。
（エラーシンボルそのものと、シンボル<CODE>error</CODE>は、
つねにこのリストの要素であること。）
したがって、条件名の階層は、
エラーシンボルの属性<CODE>error-conditions</CODE>で定義されます。
<P>

<CODE>error-conditions</CODE>リストに加えて、
エラーシンボルには、属性<CODE>error-message</CODE>も必要です。
この属性の値は、そのエラーが処理されないときに表示される文字列です。
属性<CODE>error-message</CODE>があるのに、それが文字列でなければ、
エラーメッセージ`<SAMP>peculiar error</SAMP>'を使います。
<A NAME="IDX571"></A>
<A NAME="IDX572"></A>
<P>

以下に、新たなエラーシンボル<CODE>new-error</CODE>の定義方法を示します。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(put 'new-error
     'error-conditions
     '(error my-own-errors new-error))       
=> (error my-own-errors new-error)
(put 'new-error 'error-message "A new error")
=> "A new error"
</pre></td></tr></table><P>

このエラーには、3つの条件名があります。
もっとも細かい分類である<CODE>new-error</CODE>、
それより大きな分類とであると考えている<CODE>my-own-error</CODE>、
もっとも大きな分類である<CODE>error</CODE>です。
<P>

エラー文字列は大文字で始めるべきですが、ピリオドで終えません。
これは、Emacsの他の慣習と整合をとるためです。
 
普通、Emacs自身が<CODE>new-error</CODE>を通知することはありえません。
つぎのように、読者のコードで明示的に
<CODE>signal</CODE>（see 節 <A HREF="elisp_10.html#SEC131">9.5.3.1 エラーの通知方法</A>）を呼んだときだけです。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(signal 'new-error '(x y))
     error--> A new error: x, y
</pre></td></tr></table><P>

このエラーは、3つの条件名のどれでも処理できます。
つぎの例は、<CODE>new-error</CODE>と
クラス<CODE>my-own-errors</CODE>の任意の他のエラーを処理します。
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(condition-case foo
    (bar nil t)
  (my-own-errors nil))
</pre></td></tr></table><P>

エラーを分類する重要な方法は、それらの条件名によることです。
つまり、エラーに一致するハンドラを探すために条件名を使います。
エラーシンボルは、意図したエラーメッセージと条件名のリストを指定する
簡便な方法を提供するだけです。
<CODE>signal</CODE>に、1つのエラーシンボルではなく、
条件名のリストを指定するのではわずらわしいでしょう。
<P>

一方、条件名なしにエラーシンボルだけを使うのでは、
<CODE>condition-case</CODE>の能力をいちじるしく損ないます。
条件名があることで、エラーハンドラを書くときにさまざまなレベルに
一般化してエラーを分類できるのです。
エラーシンボルだけを使ったのでは、
最細分類以外のレベルを削除してしまうことになります。
<P>

すべての標準エラー名とそれらの条件名については、
See 節 <A HREF="elisp_44.html#SEC677">D. 標準のエラー</A>。
<P>

<A NAME="Cleanups"></A>
<HR SIZE="6">
<br><A NAME="SEC135"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_10.html#SEC134"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_11.html#SEC136"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top">表紙</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_toc.html#SEC_Contents">目次</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_48.html#SEC681">索引</A>]</TD>
<TD> [<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=search">検索</a>] [<a href="#top">上端</a> / <a href="#bottom">下端</a>]</TD></TR></TABLE>
<A NAME="Cleanups"></A>
<H3> 9.5.4 非ローカル脱出時の後始末 </H3>
<!--docid::SEC135::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Cleanups">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=elisp21&node=Cleanups</a>"<br>
"texi/elisp21/非ローカル脱出時の後始末"への<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=Meadow%20memo&cmd=read&page=texi%2Felisp21%2F%C8%F3%A5%ED%A1%BC%A5%AB%A5%EB%C3%A6%BD%D0%BB%FE%A4%CE%B8%E5%BB%CF%CB%F6">コメント</a>(無し)</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">検索<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=index VALUE=memo CHECKED><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME="memoall" VALUE="on" CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>全文<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="検索"></div></FORM>
<P>

<CODE>unwind-protect</CODE>構造は、データ構造を一時的に整合性のない状態に
するときには本質的です。
この構造により、エラーや非ローカル脱出が起こったときに、
データの整合性を回復できます。
<P>

<A NAME="IDX573"></A>
<DL>
<DT><U>Special Form:</U> <B>unwind-protect</B> <I>body cleanup-forms<small>...</small></I>
<DD><A NAME="IDX574"></A>
<A NAME="IDX575"></A>
<A NAME="IDX576"></A>
<CODE>unwind-protect</CODE>は、<VAR>body</VAR>からどのように制御が離れた場合にも
<VAR>cleanup-forms</VAR>の実行を保証して、<VAR>body</VAR>を実行する。
<VAR>body</VAR>は通常どおり完了するか、
<CODE>throw</CODE>を実行して<CODE>unwind-protect</CODE>から脱出するか、
エラーを引き起こす。
いずれの場合でも、<VAR>cleanup-forms</VAR>は評価される。
<P>

フォーム<VAR>body</VAR>が正常に終了すると、
<CODE>unwind-protect</CODE>は、<VAR>cleanup-forms</VAR>を評価したあとに、
フォーム<VAR>body</VAR>の最後の値を返す。
フォーム<VAR>body</VAR>が完了しなかった場合、
<CODE>unwind-protect</CODE>は普通の意味での値は返さない。
<P>

<CODE>unwind-protect</CODE>が保護するのは<VAR>body</VAR>だけである。
<VAR>cleanup-forms</VAR>そのもののどれかが（<CODE>throw</CODE>やエラーで）
非ローカル脱出を行うと、<CODE>unwind-protect</CODE>は、
<VAR>cleanup-forms</VAR>の残りを評価することを保証<EM>しない</EM>。
<VAR>cleanup-forms</VAR>のどれかが失敗するとトラブルになる危険性がある場合には、
<VAR>cleanup-forms</VAR>を別の<CODE>unwind-protect</CODE>で保護する。
<P>

フォーム<CODE>unwind-protect</CODE>の現在の入れ子の個数は、
ローカル変数束縛の個数とともに数えられ、
<CODE>max-specpdl-size</CODE>に制限されている（see 節 <A HREF="elisp_11.html#SEC139">10.3 ローカル変数</A>）。
</DL>
<P>

たとえば、表示しないバッファを一時的に作成し、
終了前に確実にそれを消去したいとしましょう。
<P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(save-excursion
  (let ((buffer (get-buffer-create " *temp*")))
    (set-buffer buffer)
    (unwind-protect
        <VAR>body</VAR>
      (kill-buffer buffer))))
</FONT></pre></td></tr></table><P>

変数<CODE>buffer</CODE>を使わずに<CODE>(kill-buffer (current-buffer))</CODE>と
書くだけで十分だと考えるかもしれません。
しかし、別のバッファに切り替えたあとで<VAR>body</VAR>でエラーが発生した場合には、
上の方法はより安全です。
（あるいは、<VAR>body</VAR>の周りに別の<CODE>save-excursion</CODE>を書いて、
一時バッファを消去するときに、それがカレントバッファになることを
保証する。）
<P>

Emacsには、上のようなコードに展開される<CODE>with-temp-buffer</CODE>という
標準マクロがあります（see 節 <A HREF="elisp_27.html#SEC405">26.2 カレントバッファ <EM>(2003/10/30)</EM></A>）。
本書で定義しているマクロのいくつかでは、
このように<CODE>unwind-protect</CODE>を使っています。
<P>

<A NAME="IDX577"></A>
ファイル`<TT>ftp.el</TT>'から持ってきた実際の例を示しましょう。
リモートの計算機への接続を確立するプロセス（see 節 <A HREF="elisp_37.html#SEC583">36. プロセス</A>）を作ります。
関数<CODE>ftp-login</CODE>は、その関数の作成者が予想できないほどの
数多くの問題に対してとても敏感ですから、
失敗したときにプロセスを消去することを保証するフォームで保護します。
さもないと、Emacsは、無用なサブプロセスで満たされてしまいます。
<P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(let ((win nil))
  (unwind-protect
      (progn
        (setq process (ftp-setup-buffer host file))
        (if (setq win (ftp-login process host user password))
            (message "Logged in")
          (error "Ftp login failed")))
    (or win (and process (delete-process process)))))
</FONT></pre></td></tr></table><P>

この例には、小さなバグが1つあります。
ユーザーが<KBD>C-g</KBD>を打って中断しようとして、かつ、
関数<CODE>ftp-setup-buffer</CODE>の終了後に
変数<CODE>process</CODE>を設定するまえに実際に中断が行われると、
プロセスは消去されません。
このバグを直す簡単な方法はありませんが、
少なくとも、ほとんど起こりえません。
<A NAME="Variables"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp.html#SEC_Top">表紙</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_toc.html#SEC_Contents">目次</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="elisp_48.html#SEC681">索引</A>]</TD>
<TD> [<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=search">検索</a>] [<a href="#top">上端</a> / <a href="#bottom">下端</a>]</TD></TR></TABLE>
<a name="bottom"> </a>
<script type="text/javascript" src="style2.js"></script>
<div class="footer">
    <br>
    このページはMeadow (Emacs) の紹介ページです <br>
このWebページの各文書は自由にリンク・複製・再配布・改変していただいて構いません．
<br>ただし，複製・再配布・改変の場合は Meadow Memo のURLを記載しておいて下さい．<br>
<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=about%20link">Medow memoへのリンクについて</a>．<br>

間違い，要望等があれば<a href="mailto:akihisa@mail.ne.jp">akihisa@mail.ne.jp</a> か下記でどうぞ<br>

<br>

<FORM METHOD="post" ACTION="http://www.bookshelf.jp/cgi-bin/wwwmail.cgi" >
お名前：<INPUT TYPE="text" NAME="name" SIZE="30" MAXLENGTH="40" VALUE="ななしさん"><br>
メールアドレス：<INPUT TYPE="text" NAME="EMAIL" SIZE="25" MAXLENGTH="60" VALUE="secret@mail.adr"><br>
<input type="hidden" name="HPAGE" value="">
つっこみ：<br><TEXTAREA NAME="MESSAGE" ROWS="5" COLS="50">
</TEXTAREA><br><br>
<INPUT TYPE="submit" VALUE="送信">
<INPUT TYPE="reset" VALUE="クリア">
</FORM>

<br><A HREF="http://www.bookshelf.jp/cgi-bin/xct.cgi">ページ別カウンタ</a>
<br> Since 2002/12/13 <br>
</div>

</BODY>

</HTML>
