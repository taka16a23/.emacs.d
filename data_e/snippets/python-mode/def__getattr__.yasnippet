# -*- mode: snippet -*-
# name: __getattr__(self, name):
# key: defgetattr
# condition: (not (py:at-string|comment-p))
# expand-env: ((yas/indent-line 'fixed) (yas/wrap-around-region 'nil))

#
# 属性値の検索を行った結果、通常の場所に属性値が見つからなかった場合 (すなわ
# ち、self のインスタンス属性でなく、かつクラスツリーにも見つからなかった場
# 合) に呼び出されます。このメソッドは (計算された) 属性値を返すか、
# AttributeError 例外を送出しなければなりません。

# 通常のメカニズムを介して属性値が見つかった場合、__getattr__() は呼び出され
# ないので注意してください。(__getattr__() と __setattr__() の間は意図的に非
# 対称性にされています。これは__getattr__() および __setattr__() 双方にとって
# の効率性という理由と、こうしなければ __setattr__() がインスタンスの他の属性
# 値にアクセスする方法がなくなるためです。少なくともインスタンス変数に対して
# は、値をインスタンスの属性値辞書に挿入しないようにして (代わりに他のオブジ
# ェクトに挿入することで) 属性値が完全に制御されているように見せかけられるこ
# とに注意してください。新スタイルクラスで実際に完全な制御を行う方法は、以下
# の __getattribute__() メソッドを参照してください。
# --
def __getattr__(self, name):
    return $0
