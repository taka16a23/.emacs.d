# -*- mode: snippet -*-
# name: __hash__(self):
# key: defhash
# condition: (not (py:at-string|comment-p))
# expand-env: ((yas/indent-line 'fixed) (yas/wrap-around-region 'nil))
#
# 辞書演算の際にキーとなるオブジェクトに対して呼び出されたり、組み込み関数
# hash() から呼び出されたりします。辞書演算におけるハッシュ値として利用できる
# 、32 ビットの整数を返さなければなりません。このメソッドに必要な性質は、比較
# 結果が等価であるオブジェクトは同じハッシュ値をもつということです; オブジェ
# クト間で比較を行う際には、オブジェクトの各要素に対するハッシュ値を (排他的
# 論理和をとるなどして) 何らかの方法で混合するよう勧めます。クラスが __cmp__
# () メソッドを定義していない場合、 __hash__() メソッドも定義してはなりませ
# ん; クラスが __cmp__() または __eq__() を定義しているが、 __hash__() を定義
# していない場合、インスタンスを辞書のキーとして使うことはできません。クラス
# が変更可能なオブジェクトを定義しており、__cmp__() または __eq__() メソッド
# を実装している場合、__hash__() を定義してはなりません。これは、辞書の実装に
# おいてハッシュ値が変更不能であることが要求されているからです (オブジェクト
# のハッシュ値が変化すると、キーが誤ったハッシュバケツ: hash bucket に入って
# いることになってしまいます)。
# 
# バージョン 2.5 で変更された仕様: __hash__() は現在では長整数オブジェクトも
# 返すでしょう。32ビット整数はこのオブジェクトのハッシュから導出されます。
# --
def __hash__(self, ):
    return ${1:hash($2)}$0