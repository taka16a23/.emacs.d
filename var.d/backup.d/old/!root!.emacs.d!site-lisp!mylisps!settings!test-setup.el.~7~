;;; test-setup.el ---   test setting space
;;
;; Copyright (C) 2012 Atami
;;
;; Author:       Atami
;; Maintainer:   Atami
;; Version:      1.0
;; Created:      Sun Dec  9 18:29:09 2012 (+0900)
;; Last-Updated:2015/10/15 15:05:44 (+0900)
;; Last-Updated: 2015/10/12 21:59:39 (+0900)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This file is part of Emacs.
;;
;; This file is free software: you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free
;; Software Foundation, either version 3 of the License, or (at your option)
;; any later version.
;;
;; This program is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
;; more details.
;;
;; You should have received a copy of the GNU General Public License along
;; with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;  ===========
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;  ===========
;;
;; 2012/12/09    Atami
;;    Created this header.
;;
;;
;;; Code:


(eval-when-compile
  (require 'cl "cl" 'noerr)
  (require 'subroutines "subroutines" 'noerr)
  (require 't1macro "t1macro" 'noerr)
  (require 'bindings-setup "bindings-setup" 'noerr))

(unless (windows-p)
  (defvar usb-drive-letter))

;;;; for debug
;;
(defun debug-on ()
  "Debug mode on."
  (interactive)
  (setq debug-on-error t))

(defun degug-off ()
  "Debug mode off."
  (interactive)
  (setq debug-on-error nil))


;; 透明
;; (set-frame-parameter nil 'alpha '(75 65))
;; (set-frame-parameter nil 'alpha '(100 65))
;; (set-frame-parameter (selected-frame) 'alpha '(70 50))
;; (set-frame-parameter (selected-frame) 'alpha '(100 10))
;; (set-frame-parameter nil 'alpha '80)

;;;; mark-multiple
;;
;; (require 'inline-string-rectangle)
(global-set-key (kbd "s-r") 'inline-string-rectangle)

;;;; for other window
(global-set-key "\C-x\C-o"     'nil)
(global-set-key "\C-x\C-o\C-f" 'find-file-other-window)
(global-set-key "\C-x\C-o\C-r" 'find-file-read-only-other-window)

;;;; reopen as root
;;
(defun file-root-p (filename)
  "Return t if file FILENAME created by root."
  (eq 0 (nth 2 (file-attributes filename))))

(defun change-as-root ()
  "Opens FILE with root privileges."
  (interactive)
  (set-buffer (find-file (concat "/sudo::" buffer-file-name))))
;;
;;;; end


;;;; reverse things
;;
(defun reverse-words (beg end)
  "Reverse the order of words in region.
BEG: start of region
END: end of region"
  (interactive "*r")
  (apply 'insert (reverse (split-string
                           (delete-and-extract-region beg end) "\\b"))))

(defalias 'reverse-line-region 'reverse-region)
;;
;;;;

;; http://www.google.com/url?q=http://stackoverflow.com/questions/6172054/how-can-i-random-sort-lines-in-a-buffer&sa=U&ei=IcjXUOe3EcfDmQWynID4CQ&ved=0CC8QFjAJOAo&usg=AFQjCNEjRUrW_v7iAjaq3MpOoS_1WtwyCA
(defun sort-lines-random (beg end)
  "Sort lines in region randomly.
Argument BEG Region of beggining.
Argument END Region of ending."
  (interactive "r")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (let ;; To make `end-of-line' and etc. to ignore fields.
          ((inhibit-field-text-motion t))
        (sort-subr nil 'forward-line 'end-of-line nil nil
                   (lambda (s1 s2) (eq (random 2) 0)))))))

;; http://www.emacswiki.org/emacs/SortWords
(defun sort-words (reverse beg end)
  "Sort words in region alphabetically, in REVERSE if negative.
    Prefixed with negative \\[universal-argument], sorts in reverse.

    The variable `sort-fold-case' determines whether alphabetic case
    affects the sort order.

    See `sort-regexp-fields'."
  (interactive "*P\nr")
  (sort-regexp-fields reverse "\\w+" "\\&" beg end))

(defun sort-symbols (reverse beg end)
  "Sort symbols in region alphabetically, in REVERSE if negative.
    See `sort-words'."
  (interactive "*P\nr")
  (sort-regexp-fields reverse "\\(\\sw\\|\\s_\\)+" "\\&" beg end))
;;
;;;;

;;;; renumber
;;
(defun renumber (&optional num)
  "Renumber the list items in the current paragraph,
    starting at point."
  (interactive "p")
  (setq num (or num 1))
  (let ((end (save-excursion
               (forward-paragraph)
               (point))))
    (while (re-search-forward "^[0-9]+" end t)
      (replace-match (number-to-string num))
      (setq num (1+ num)))))

(defun renumber-list (start end &optional num)
  "Renumber the list items in the current START..END region.
    If optional prefix arg NUM is given, start numbering from that number
    instead of 1."
  (interactive "*r\np")
  (save-excursion
    (goto-char start)
    (setq num (or num 1))
    (save-match-data
      (while (re-search-forward "^[0-9]+" end t)
        (replace-match (number-to-string num))
        (setq num (1+ num))))))

;;;; increment
;;
(defun increment-number-at-point ()
  (interactive)
  (skip-chars-backward "0123456789")
  (or (looking-at "[0123456789]+")
      (error "No number at point"))
  (replace-match (number-to-string (1+ (string-to-number (match-string 0))))))

(defun decrement-number-at-point ()
  (interactive)
  (skip-chars-backward "0123456789")
  (or (looking-at "[0123456789]+")
      (error "No number at point"))
  (replace-match (number-to-string (1- (string-to-number (match-string 0))))))

;; (define-key ctl-e-map "+" 'increment-number-at-point)

(defun insert-buffer-file-name ()
  (interactive)
  (insert (buffer-file-name)))

(defun insert-file-name-nondirectory ()
  (interactive)
  (insert (file-name-nondirectory (buffer-file-name))))

(defun insert-capitalize-file-name-nondirectory-nonextension ()
  (interactive)
  (insert (upcase (file-name-sans-extension (file-name-nondirectory (buffer-file-name))))))

(defun insert-capitalize-file-name-nondirectory ()
  (interactive)
  (insert (upcase (file-name-nondirectory (buffer-file-name)))))

;;;; align space
;;
(defun align--space (arg)
  ""
  (let ((count 0)
        (startc (current-column))
        endc)
    (save-excursion
      (line-move arg nil nil 'try-vscroll)
      (while (and (blank-line-p)
                  (not (bobp))
                  (> 10 count))
        (incf count)
        (line-move arg nil nil 'try-vscroll))
      (skip-chars-forward " \t")
      (setq endc (current-column)))
    (insert-char 32 (- endc startc))
    ))

(defun backward-align-space (arg)
  "align-space"
  (interactive "p")
  (align--space (- arg)))

(defun forward-align-space (arg)
  "align-space"
  (interactive "p")
  (align--space arg))
;; (define-key ctl-e-map "F" 'backward-align-space)
;; (define-key ctl-e-map "\M-f" 'backward-align-space)

;;;; alias
;;
(defalias 'symf 'symbol-file)

;;;; python
(defun py--go-to-paren-class ()
  "go-to-paren-class"
  (while (and (not (looking-at "^\\_<\\(def\\|class\\)\\_>[ \n\t]"))
              (re-search-backward
               "[ \t]*\\_<\\(def\\|class\\)\\_>[ \n\t]" nil 'noerror))))

;;;; alias
;;
(defalias 're-in-string 'string-match)

;;;; toggle-mode-line
;;


;;;; replace "\" to "\\"
;;
(defun replace-dir-sep ()
  "replace-dir-sep"
  (interactive)
  (query-replace "\\" "\\\\"))
;; (define-key ctl-e-map "\\" 'replace-dir-sep)


;;;; moccur
;;
(defadvice moccur-set-key
  (after moccur-set-key-hook activate)
  (color-moccur-mode-map-predefine)
  )


;;;; replace directory separator
;;
(autoload 'replace-string "replace")
(defun rep-dir-sep (start end)
  "Replace directory separator.
START: start of region
END: end of region"
  (interactive "r")
  (save-excursion
    (cond
     ((save-excursion (search-backward "\\\\" start 'noerror))
      (replace-string "\\\\" "/" nil start end))
     ((save-excursion (search-backward "\\" start 'noerror))
      (replace-string "\\" "\\\\" nil start end))
     ((save-excursion (search-backward "/" start 'noerror))
      (replace-string "/" "\\" nil start end))
     )))
;; (define-key ctl-e-map "\\" 'rep-dir-sep)

;;;; stack point
;;
(defvar stack-point nil)
(defvar stack-point-max 20)
(defun stack-point ()
  ""
  (setq stack-point (cons (list (buffer-file-name) (point)) stack-point))
  (length stack-point)
  (when (> (length stack-point) stack-point-max)
    (setcdr (nthcdr (1- stack-point-max) stack-point) nil))
  )

(defun pop-stack-point ()
  ""
  (interactive)
  (let ((dst (pop stack-point)))
    (when (eq dst nil)
      (error "No stack point"))
    (when (not (eq (car dst) nil))
      (find-file (car dst))
      (goto-char (car (cdr dst)))
      )))


;;;; uniq region
;;
(defun uniq-region (start end)
  ""
  (interactive "*r")
  (shell-command-on-region start end "uniq" nil 'replace)
  )

;;;; alias
;;
(defalias 'bookmark-most-using-t1 'bookmark-set)

;;;; recompile recursively
(defun myrecompile-recursively (dirs)
  "Recompile recursively.
DIRS: directory."
  (interactive)
  (dolist (dir (recursive-directory dirs))
    (dolist (f (directory-files dir 'full "\\.el\\`"))
      (unless (file-accessible-directory-p f)
        (batch-byte-compile-file f)))))

(defun recursive-files (dir &optional regexp) ;[2013/11/24]
  "DIR
REGEXP"
  (flatten (mapcar
            (lambda (d) (directory-files d 'full regexp))
            (recursive-directory dir))))

(defun flatten (list)
  (cond ((null list) nil)
        ((atom list) (list list))
        (t
         (append (flatten (car list)) (flatten (cdr list))))))

(defun walk-edit (func dir &optional regexp exclude save kill) ;[2013/11/25]
  "DIR
REGEXP"
  (let ((co-check-type-miss t))
    (dolist (file (recursive-files dir regexp))
      (unless (and exclude (string-match exclude file))
        (with-current-buffer (find-file-noselect file)
          (read-only-mode -1)
          (goto-char (point-min))
          (widen)
          (funcall func)
          (and save (save-buffer))
          (and (not (buffer-modified-p)) kill (kill-this-buffer)))))))

;;;; walk-edit
;;
(defun walk-edit-dirs (func dirs &optional nosave nokill)
  "edit-dirs
ex. (\"l:/Office/emacs/.emacs.d/elisp/mylisp\" 'fullpath \".el$\")"
  (let ((files (walk--edit-target-files-from-dirs dirs)))
    (walk--edit func files nosave nokill)
    ))
;; ex. (walk-edit-dirs 'delete-header '(("p:/Office/emacs/.emacs.d/elisp/start.d" 'full ".el$")))

;; ex. (walk-edit-dirs 'python-refactor '(("D:/MYTEMP/updater" 'fullpath ".py$")))
(defun walk--edit (func file-list &optional nosave nokill)
  (dolist (file file-list)
    (do-func--on-file func file nosave nokill)
    ))

(defun walk--edit-target-files-from-dirs (dirs)
  (let (files)
    (dolist (d dirs)
      (message (car d))
      (setq files (append (eval `(directory-files ,@d)) files)))
    files))

(defun do-func--on-file (func file &optional nosave nokill)
  "walk-edit"
  (let ((inhibit-read-only t)
        (no-check-type-miss t))
    (with-current-buffer
        (find-file-noselect file)
      (funcall func)
      (and (buffer-modified-p) (not nosave) (save-buffer))
      (and (not nokill) (kill-this-buffer))
      )
    ))

;;;; indirect region
;;
;; [2013/09/27]
;; copied from http://www.emacswiki.org/emacs/IndirectBuffers and modified.
(defvar indirect-mode-name nil
  "Mode to set for indirect buffers.")
(make-variable-buffer-local 'indirect-mode-name)

(defun indirect-region (start end &optional buffname)
  "Edit the current region in another buffer.
START:start of region.
END:end of region.
BUFFNAME:extention buffer name.
    If the buffer-local variable `indirect-mode-name' is not set, prompt
    for mode name to choose for the indirect buffer interactively.
    Otherwise, use the value of said variable as argument to a funcall."
  (interactive "r")
  (if buffname
      (setq buffname (concat " " buffname))
    (setq buffname ""))
  (let ((buffer-name (generate-new-buffer-name (concat "*indirect" buffname "*")))
        (mode
         (if (not indirect-mode-name)
             (setq indirect-mode-name
                   (intern
                    (completing-read
                     "Mode: "
                     (mapcar (lambda (e)
                               (list (symbol-name e)))
                             (apropos-internal "-mode$" 'commandp))
                     nil t)))
           indirect-mode-name)))
    (pop-to-buffer (make-indirect-buffer (current-buffer) buffer-name))
    (funcall mode)
    (narrow-to-region start end)
    (goto-char (point-min))
    ;; (shrink-window-if-larger-than-buffer)
    ))

;; advice eval-last-sexp
(defadvice eval-last-sexp
  (before align-eval-last-sexp activate)
  "Align indent before `eval-last-sexp'."
  (unless buffer-read-only
    (save-excursion
      (let ((orig-line (1+ (count-lines 1 (point))))
            start-line)
        (backward-list 1)
        (indent-and-next (- orig-line (1+ (count-lines 1 (point)))))
        ))))
;; (progn (ad-disable-advice 'eval-last-sexp 'before 'align-eval-last-sexp) (ad-update 'eval-last-sexp))

;;;; move-text-up basic-edit-toolkit.el
;;
(defadvice move-text-up
  (after move-text-up-previous-line activate)
  (let ((column (current-column)))
    (forward-line (- arg))
    (line-move-to-column column))
  )
;; (progn (ad-disable-advice 'move-text-up 'after 'move-text-up-previous-line) (ad-update 'move-text-up)))

;;;; snippet helper
;;
(defun prev-def-name ()
  (save-excursion
    (if (re-search-backward "def +\\(.+?\\)(" nil t)
        (match-string 1))))

(defun prev-def-args ()
  (save-excursion
    (if (re-search-backward "def +\\(.+?\\)( *self *,? *\\(.*\\))" nil t)
        (match-string 2))))

(defun prev-class-name ()
  (save-excursion
    (if (re-search-backward "class +\\(.+?\\) *[(:]" nil t)
        (match-string 1))))


(defun before-save-align-tail () ;[2013/11/03]
  "For `before-save-hook'."
  (let ((inhibit-read-only t))
    (save-excursion
      (goto-char (point-max))
      (when (and (re-search-backward "" nil 'noerror)
                 (not (looking-back "\n\n\n")))
        (forward-char -1)
        (delete-blank-lines)
        (insert "\n\n"))
      )))

;; for no log on anything *Anything Log*
;; (setq debug-on-error nil)

(defun elisp-save-buffer (ARGS) ;[2013/11/03]
  "For `before-save-hook'.
ARGS:"
  (interactive "p")
  (let ((inhibit-read-only t))
    (save-excursion
      (goto-char (point-max))
      (when (and (re-search-backward "" nil 'noerror)
                 (or (looking-back "\n\n\n\n")
                     (not (looking-back "\n\n\n"))))
        (forward-char -1)
        (delete-blank-lines) ;for no blank line
        (delete-blank-lines)
        (insert "\n\n"))))
  (save-buffer ARGS))



(add-hook 'prog-mode-hook '(lambda () (setq backup-inhibited nil)))
;; (remove-hook 'prog-mode-hook '(lambda () (setq backup-inhibited nil)))

(defadvice save-buffer
  (before save-buffer-make-backup activate)
  (when (called-interactively-p 'interactive)
    (setq backup-inhibited nil))
  )
;; (progn (ad-disable-advice 'save-buffer 'before 'save-buffer-make-backup) (ad-update 'save-buffer)))

;;;; beep handling
;;
(defun my-bell-function ()
  (unless (memq this-command
                '(isearch-abort
                  abort-recursive-edit
                  exit-minibuffer
                  keyboard-quit
                  mwheel-scroll
                  down
                  up
                  next-line
                  previous-line
                  backward-char
                  forward-char))
    (ding)))

(setq ring-bell-function 'my-bell-function)

;;;; keyboard macro
(global-set-key (kbd "s-<f4>") 'kmacro-edit-macro)
(global-set-key (kbd "C-x <f4>") 'name-last-kbd-macro)
(global-set-key (kbd "C-x s-<f4>") 'insert-kbd-macro)

(defalias 'symbol-to-string 'symbol-name)

;;;; syslog-mode
;;
(add-to-list
 'auto-mode-alist
 '("\\(messages\\(\\.[0-9]\\)?\\|SYSLOG\\)\\'" . syslog-mode))



(defalias 'expandmacro 'macroexpand)
(defalias 'expand-macro 'macroexpand)
(defalias 'macro-expand 'macroexpand)


(defun insert-register-disable-exchange (register) ;[2014/06/12]
  "REGISTER"
  (interactive "*cInsert register: ")
  (insert-register register t)
  )


;;;###autoload
(defun grep-edit-finish-save (save) ;[2014/09/05]
  "SAVE"
  (interactive "p")
  (grep-edit-finish-edit)
  (when (or (= save 4) (y-or-n-p "Save some buffer? y or n: "))
    (let ((inhibit-read-only t))
      (save-some-buffers 'noquetion))))

;;;###autoload
(defun list-matched-buffers (re) ;[2014/09/11]
  "RE"
  (interactive)
  (let (buffers)
    (dolist (buf (buffer-list))
      (with-current-buffer buf
        (when (string-match re (buffer-name))
          (add-to-list 'buffers buf))))
    buffers))

(defun kill-some-buffers-by-regexp (re) ;[2014/09/09] [2014/09/11]
  "RE"
  (dolist (buf (list-matched-buffers re))
    (kill-buffer buf)))

(defun kill-some-buffers-by-extension (ext) ;[2013/11/25] [2014/09/09]
  "EXT"
  (interactive "sExtension: ")
  (let ((re (format "\\.%s\\'" ext)))
    (message "kill-buffer by %s" re)
    (kill-some-buffers-by-regexp re)
    (message "Finished." )))


;; 'grow-only to t for flycheck
(setq resize-mini-windows t)

(defun e2wm:dp-pycode-navi-relaunch-sub-ipython () ;[2014/12/28]
  ""
  (interactive)
  (let ((buf (get-buffer "*IPython*")))
    (when buf
      (kill-buffer buf))
    (e2wm:dp-pycode-navi-sub-ipython)))




;;;; e2wm
;;
;; override
(defun e2wm:def-plugin-files (frame wm winfo)
  (let* ((buf (wlf:get-buffer (e2wm:pst-get-wm) 'main))
         (wname (wlf:window-name winfo))
         (opts (wlf:window-option-get winfo :plugin-args))
         (opt-sort-key (or (plist-get opts ':sort) 'name))
         (opt-hide-hidden (not (plist-get opts ':show-hidden)))
         (dir (with-current-buffer buf
                (or default-directory ".")))
         (buf-name (format " *WM:Files-%s*" wname))
         (dbuf (get-buffer buf-name)) pos)
    (unless (and dbuf (buffer-live-p dbuf))
      (setq dbuf (get-buffer-create buf-name))
      (with-current-buffer dbuf
        (e2wm:def-plugin-files-mode)
        (set (make-local-variable 'e2wm:def-plugin-files-dir) dir)
        (set (make-local-variable 'e2wm:def-plugin-files-sort-key) opt-sort-key)
        (set (make-local-variable 'e2wm:def-plugin-files-hide-hidden-files) opt-hide-hidden)
        (setq buffer-read-only t)
        (buffer-disable-undo dbuf)
        (setq pos (point-min))
        (hl-line-mode 1)))
    (with-current-buffer dbuf
      (unwind-protect
          (progn
            (setq buffer-read-only nil)
            (setq pos
                  (if (and e2wm:def-plugin-files-dir
                           (equal e2wm:def-plugin-files-dir dir))
                      (point) (point-min)))
            (setq e2wm:def-plugin-files-dir dir)
            (erase-buffer)
            (e2wm:def-plugin-files-update-buffer dir)
            (goto-char pos))
        (setq buffer-read-only t)))
    (wlf:set-buffer wm wname dbuf)))


(defun delete-buffer-regexp (regexp) ;[2015/08/06]
  ""
  (interactive "sSearch keywords as regexp: ")
  (dolist (buffer (buffer-list))
    (when (string-match regexp (buffer-name buffer))
      (kill-buffer buffer)
      )))




;;;###autoload
(defun add-doing (description) ;[2015/10/02]
  "DESCRIPTION"
  (interactive "sDoing? \n")
  (find-file my-allinone-path)
  (unless (file-exists-p my-allinone-path)
    (error (format "Not exists %s" my-allinone-path)))
  (goto-char (point-max))
  (let ((inhibit-read-only t))
    (when (re-search-backward "^\* ----- DOING -----" nil 'noerror)
      (forward-line 1)
      (insert "** TODO " description "\n"
              "  " (format-time-string "<%Y-%m-%d %a %H:%M>\n"))
      (save-buffer)
      (bury-buffer)
      ))
  )

(define-key global-map (kbd "<f7>") 'add-doing)

(dolist (elt '((show-paren-mode        1)
			   (savehist-mode          1)
			   ;; (auto-image-file-mode   1)
			   ;; (auto-compression-mode  1) ;Edit gz, tar.. file
			   (winner-mode            1)
               (global-auto-revert-mode 1)
			   ))
  (when (fboundp (car elt))
	(apply (car elt) (cdr elt))))

;; (default-view-bind-set messages-buffer-mode-map)
(require 'bind-key "bind-key" 'noerr)
(bind-keys :map messages-buffer-mode-map
           ("n" . next-line)
           ("l" . forward-char)
           ("j" . backward-char)
           ("k" . previous-line)
           ("-" . my-forward-seq)
           ("o" . other-window)
           ("p" . cua-scroll-down)
           ("h" . my-backward-seq)
           ("v" . next-line)
           ("f" . forward-char)
           ("d" . previous-line)
           ("s" . backward-char)
           ("g" . my-forward-seq)
           ("e" . cua-scroll-down)
           ;; common
           ("a" . my-backward-seq)
           ("\d" . nil)
           ("c" . nil)
           ("b" . cua-scroll-up))


;;;; python
;;
;;;; python check point is in the class block.
;;
(defun py-in-class-block-p ()
  "Return t if point in class block.
Also end of block has indented return t."
  (and (save-excursion
         (py--go-to-paren-class)
         (looking-at "^\\_<\\(class\\)\\_>[ \n\t]"))
       (or (<= 4 (current-indentation))
           (looking-at "^\\_<\\(class\\)\\_>[ \n\t]")
           (save-excursion
             (while (and (or (blank-line-p)
                             (eq (what-face-at-point)
                                 (or 'font-lock-string-face
                                     'font-lock-comment-face)))
                         (not (eobp)))
               (forward-line 1))
             (<= 4 (current-indentation)))
           )))

;;; test function so far
(defun py-go-to-end-of-class ()
  "to-end-of-class"
  (interactive)
  (while (py-in-class-block-p) (not (eobp))
         (forward-line)))

(defun py:insert-conma-end-brackets ()
  ""
  (interactive)
  (py:end-of-brackets)
  (unless (save-excursion (skip-chars-backward " \t\n") (looking-back ","))
    (insert ","))
  (newline-and-indent))

(defun yas-argparse-determine-prog ()
  ""
  (save-excursion
    (goto-char (point-min))
    (if (re-search-forward "\\(.+\\)[ ]+=[ ]+sys.argv\\[0\\]" nil 'noerror)
        (match-string 1)
      (goto-char (py--determine-after-import))
      (insert "\n\nPROG_NAME = sys.argv[0]")
      (message "Inserted \"PROG_NAME = sys.argv[0]\"")
      "PROG_NAME")))


;;;; python debugger pdb
;;
(defun pdb-this-buffer ()
  ""
  (interactive)
  (and (buffer-modified-p)
       (y-or-n-p "Save bufffer? ")
       (save-buffer))
  (let ((cmd (read-from-minibuffer
              "pdb command: "
              (concat "python -u "
                      usb-drive-letter "system/PortablePython/App/Lib/pdb.py "
                      (buffer-file-name)))))
    (pdb cmd)))

(defun py-insert-pdb-set-trace ()
  "Python insert-pdb-set-trace."
  (interactive)
  (ll-debug-open-fresh-line)
  (insert "import pdb; pdb.set_trace()")
  (forward-line)
  (indent-according-to-mode)
  )

;;;; transpose
;;
(defun py-transpose-ope ()
  (interactive)
  (cond ((member (thing-at-point 'symbol) '("and" "is" "or"))
         (transpose-by-operation2))
        ((looking-at
          "\\(+\\|=\\|-\\|*\\|&\\|%\\||\\|\\^\\|>>\\|<<\\|<\\|<=\\|>\\|>=\\|==\\|!=\\)")
         (transpose-by-operation))
        (t (message "tes"))))

(defvar skip-ope "\\(+\\|=\\|-\\|*\\|&\\|%\\||\\|\\^\\|>>\\|<<\\|<\\|<=\\|>\\|>=\\|==\\|!=\\)")
(defvar py-trance-re "[ \t]*\\(+\\|=\\|:\\|-\\|*\\|&\\|%\\||\\|\\^\\|>>\\|<<\\|<\\|<=\\|>\\|>=\\|==\\|!=\\|\\_<\\(?:\\(?:and\\|el\\(?:if\\|se\\)\\|if\\|not\\|or\\)\\)\\_>\\)[ \t]*")

(defun transpose-by-operation ()
  "by-operation"
  (let (startr1 endr1 startr2 endr2)
    (save-excursion
      (setq endr1 (progn
                    (skip-chars-backward skip-ope)
                    (skip-chars-backward "[ \t]")
                    (point)))
      (setq startr1 (progn
                      (re-search-backward py-trance-re nil 'noerror)
                      (match-end 0))))
    (save-excursion
      (setq startr2 (progn
                      (skip-chars-forward skip-ope)
                      (skip-chars-forward "[ \t]")
                      (point)))
      (setq endr2 (progn
                    (re-search-forward py-trance-re nil 'noerror)
                    (match-beginning 0))))
    (transpose-regions startr1 endr1 startr2 endr2)
    ))

(defvar py-trance-re2 "[ \t]*\\(:\\|\\_<\\(?:\\(?:and\\|el\\(?:if\\|se\\)\\|if\\|or\\)\\)\\_>\\)[ \t]*")

(defun transpose-by-operation2 ()
  "by-operation"
  (let (startr1 endr1 startr2 endr2)
    (save-excursion
      (setq endr1 (progn
                    (unless (looking-at "\\_<")
                      (backward-sexp))
                    (skip-chars-backward "[ \t]")
                    (point)))
      (setq startr1 (progn
                      (re-search-backward py-trance-re2 nil 'noerror)
                      (match-end 0))))
    (save-excursion
      (setq startr2 (progn
                      (forward-sexp)
                      (skip-chars-forward "[ \t]")
                      (point)))
      (setq endr2 (progn
                    (re-search-forward py-trance-re2 nil 'noerror)
                    (match-beginning 0))))
    (transpose-regions startr1 endr1 startr2 endr2)
    ))

;;;; pycallgraph
;;
(defvar py-callgraph-result-buffer "*pycallgraph*")

(defun py-callgraph-this-buffer ()
  ""
  (interactive)
  (with-current-buffer (get-buffer-create py-callgraph-result-buffer)
    (erase-buffer))
  (start-process
   "pycallgraph" py-callgraph-result-buffer
   "python" (concat usb-drive-letter "system/PortablePython/App/Scripts/pycallgraph")
   (buffer-file-name))
  (display-buffer py-callgraph-result-buffer))

;;;; python
;;
(defun t1-py-insert-debug-print ()
  "debug-print"
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((n 0))
      (while (re-search-forward "\\(^[ \t]*\\(:?def[ \t]+\\([a-zA-Z0-9_]+\\)[ \t]*(\\(:?[^:#]*\\))\\)[ \t]*:\\)" nil 'noerror)
        (forward-line)
        (beginning-of-line)
        (setq n (1+ n))
        (insert (make-string (current-indentation) 32)
                "print('"
                (file-name-nondirectory buffer-file-name)
                " [" (number-to-string n) "]" ; increment number
                ": "
                (match-string 3)
                "') # Debug\n")))))

(defun t1-py-delete-debug-print ()
  "delete-debug-print"
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "print('.*\\[[[:digit:]]*\\].*#.*Debug" nil 'noerror)
      (kill-whole-line)
      )))

(defun py-comment-def-or-class ()
  ""
  (interactive)
  (py-mark-def-or-class)
  (my-ll-debug-toggle-comment-region-or-line)
  )

(defun py-comment-or-uncomment-def-or-class ()
  "comment-or-uncomment-def-or-class"
  (interactive)
  (if (t1-py--comment-p)
      (py-uncomment)
    (sit-for 0)
    (py-comment-def-or-class)
    ))

(defsubst t1-py--comment-tes-p ()
  ""
  (let ((face (what-face-at-point)))
    (or (eq 'font-lock-comment-face face)
        (eq 'font-lock-comment-delimiter-face face))))

;;;; python overview
;;
(if (windows-p)
    (defcustom python-overview-command (concat usb-drive-letter
                                               "Lib/.pylib/overview.py")
      "Document"
      :type 'string
      :group 'python-overview)

  ;; posix
  (defcustom python-overview-command (expand-file-name "~/.pylib/overview.py")
    "Document"
    :type 'string
    :group 'python-overview))


(defcustom python-result-buffer "*py-overview*"
  "Document"
  :type 'string
  :group 'python-overview)

(defun python-overview ()
  ""
  (interactive)
  (with-current-buffer (get-buffer-create python-result-buffer)
    (erase-buffer))
  (start-process "overview"
                 (get-buffer-create "*py-overview*")
                 "python"
                 ;; python-overview-command
                 "-m" "overview"
                 (let* ((target (buffer-file-name))
                        (command (concat target)))
                   (read-string "python overview.py: " command t command))))


(defvar py-inhibit-replace-tab nil)
(make-local-variable 'py-inhibit-replace-tab)
(defun py-replace-tab ()
  "ARGS"
  (interactive)
  (let ((inhibit-read-only t))
    (save-restriction
      (goto-char (point-min))
      (and (not py-inhibit-replace-tab)
           (re-search-forward "^\t" nil 'noerror)
           (y-or-n-p "This buffer using tab.  replace to space? ")
           (untabify (point-min) (point-max))))))

(add-hook 'python-mode-hook 'py-replace-tab t)
;; (remove-hook 'python-mode-hook 'py-replace-tab)

(defun py-kill-line (arg)
  "If line is blank, delete all surrounding blank lines, leaving just one.
ARG:
On isolated blank line, delete that one.
On nonblank line, kill whole line."
  (interactive "P*")
  (cond (mark-active
         (cua-cut-region arg))
        ((progn (beginning-of-line) (looking-at "\\(?:def\\|class\\)"))
         (kill-whole-line))
        ((save-excursion
           (re-search-backward "[^ \t\n]" nil 'noerror)
           (forward-line 1)
           (looking-at "^[ \t\n]+[\n\r]\\(?:def\\|class\\)"))
         (if (eq last-command this-command)
             (progn (delete-blank-lines) (kill-whole-line))
           (delete-blank-lines)
           (save-excursion (insert "\n"))))
        ((progn (beginning-of-line) (looking-at "[ \t]*$"))
         (delete-blank-lines))
        (t
         (kill-whole-line))))

(defun py-clean-kill-region (beg end &optional yank-handler)
  "Python clean blank line after kill region.
BEG: begginning of region
END: end of region
YANK-HANDLER"
  (interactive (list (point) (mark)))
  (kill-region beg end)
  (delete-blank-lines))

(defun pyapropos (keyword)
  "Python apropos.
KEYWORD: search keyword."
  (interactive "sSearch keywords as regexp: ")
  ;; (start-process "pyapropos" (get-buffer-create "*pyapropos*")
  ;; "/usr/bin/python" "-m" "apropos" "--color-normal" keyword)
  (let ((cmdline (concat "/usr/bin/python " "-m " "apropos " ;"--color-normal"
                         keyword)))
    (compilation-start cmdline nil (lambda (mode) (concat "*pyapropos*")))))


(defun py:clonedigger-run (&optional target odir interactive) ;[2013/11/24]
  ""
  (save-some-buffers)
  (let* ((cmd "clonedigger")
         (odir (or odir "/tmp/"))
         (output-file (expand-file-name (concat (buffer-name) ".html") odir))
         (options (format "-o %s" output-file))
         (target (or target (file-name-directory (buffer-file-name)) ""))
         (cmdline (s-join " " (list cmd options target)))
         (cmdline (if interactive
                      (read-string "cmdline: " (concat cmdline " ") nil)
                    cmdline)))
    (compilation-start cmdline nil (lambda (mode) (concat "*clonedigger*")))
    (when (functionp 'w3m-find-file)
      (while (not (file-exists-p output-file))
        (sit-for 3))
      (w3m-find-file output-file))))


(defun py:clonedigger () ;[2013/11/25]
  ""
  (interactive)
  (py:clonedigger-run (buffer-file-name) nil 'interactive))

(defun py:clonedigger-project () ;[2013/11/25]
  ""
  (interactive)
  (py:clonedigger-run
   (file-name-directory (buffer-file-name)) nil 'interactive))

;; borrow from dired-aux.el
(defun py:dired-create-directory (directory) ;[2014/01/16]
  "DIRECTORY"
  (interactive
   (list (read-file-name "Create directory: " (dired-current-directory))))
  (let* ((expanded (directory-file-name (expand-file-name directory)))
         (try expanded) new)
    (if (file-exists-p expanded)
        (error "Cannot create directory %s: file exists" expanded))
    ;; Find the topmost nonexistent parent dir (variable `new')
    (while (and try (not (file-exists-p try)) (not (equal new try)))
      (setq new try
            try (directory-file-name (file-name-directory try))))
    ;; (make-directory expanded t)
    (make-directory (concat (file-name-as-directory expanded) "tests") t)
    (shell-command
     (concat "touch " (file-name-as-directory expanded) "tests/__init__.py"))
    (find-file (expand-file-name "__init__.py" expanded))
    )
  )

;;;; python generate tests method
;;
(defvar testsmethod-template "    def test_%s(self, ):
        self.skipTest('Not Implemented')\n")
(defun py:current-classname () ;[2015/02/04]
  ""
  (when (py:in-class-p)
    (py:beginning-of-class 1))
  (when (py:at-beginning-of-class-p)
    (re-search-forward py:class-name-re nil 'noerror)
    (match-string-no-properties 1)))


(defun py:list--testsmethod-template (cls) ;[2015/02/04]
  "CLS"
  (mapcar
   (lambda (x) (format testsmethod-template x))
   (py:list-method-in-class cls)))


;; (defun py:text--testsmethod (cls) ;[2015/02/04]
;;   "CLS"
;;   (kill-new (s-join "\n" (py:list--testsmethod-template cls)))
;;   (message "!tests method text saved to kill-ring.!"))


(defun py:testsmethod-insert-kill-ring (&optional cls) ;[2015/02/04]
  "CLS"
  (interactive)
  (let ((clsname (or cls (py:current-classname))))
    (when (eq clsname nil)
      (setq clsname (read-input "Input class name: ")))
    (kill-new (s-join "\n" (py:list--testsmethod-template clsname)))
    (message "!tests method text saved to kill-ring.!")))


(defun py:current-defname () ;[2015/02/11]
  ""
  (when (py:in-def-p)
    (py:beginning-of-def 1))
  (when (py:at-beginning-of-def-p)
    (re-search-forward py:def-name-re nil 'noerror)
    (match-string-no-properties 1)))

;; for auto-highlight-symbol.el
(defun py:def-start-point () ;[2015/07/25]
  ""
  (car (py:region-def)))

(defun py:def-end-point () ;[2015/07/25]
  ""
  (cdr (py:region-def)))

(defun py:class-start-point () ;[2015/07/25]
  ""
  (car (py:region-class)))

(defun py:class-end-point () ;[2015/07/25]
  ""
  (cdr (py:region-class)))

;;;; for snippet functions
;;

(defun py-snippet:argparse-add_argument-convert-dest-name (text) ;[2015/09/25]
  "ARGS"
  (let* ((lis (mapcar '(lambda (x) (replace-regexp-in-string "[\"' ]" "" x))
                      (split-string text ",")))
         (n 0)
         (length (length lis))
         matched)
    (unless (eq "" (car lis))
      (while (< n length)
        (when (string-match "^--" (nth n lis))
          (setq matched (substring (nth n lis) 2)))
        (incf n))
      (setq n 0)
      (unless matched
        (while (< n length)
          (when (string-match "^-" (nth n lis))
            (setq matched (substring (nth n lis) 1)))
          (incf n)))
      (unless matched
        (setq matched (car lis)))
      (replace-regexp-in-string "-" "_" matched))
    ))



(provide 'test-setup)
;; For Emacs
;; Local Variables:
;; coding: utf-8
;; no-update-autoloads: t
;; End:
;;; test-setup.el ends here
